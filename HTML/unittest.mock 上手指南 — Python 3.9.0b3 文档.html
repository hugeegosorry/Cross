<!DOCTYPE html> <html xmlns=http://www.w3.org/1999/xhtml lang=zh_CN><!--
 Page saved with SingleFile 
 url: https://docs.python.org/zh-cn/3.9/library/unittest.mock-examples.html 
 saved date: Thu Jun 18 2020 05:53:50 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<title>unittest.mock 上手指南 — Python 3.9.0b3 文档</title>
<style>:root{--sf-img-1:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gEGxE4IQYzJ14AAAI3SURBVDjLZZNPSFVBFIe/e9+zd3silBCl0SZoU4s2rVq0EB5tQip4UNvATVGu3QRBiyAi2iltWkgbF5EgRhFFRpiWtrWIzDIV1Pzz7p15M2fmtvDevOqBw8DM9zvnN8ycgF3R/eDtM2mac96ZdrFNxBikqbRV+vHH/ut9gAZczoe7C3gnF0f6au1OLM5avFi8d1Ea+JvAMSAq8nsKOGs5f2cYJ3Y7rc2PO4BqkS8DdD98f9tbe1ysCoxOBo1qlEXHJWcM4b5KPU19zleA0o4Clx99eO3EdqVewHsCoFRugUoVghJO7A6H6Vx9wdtYi27cr5x6dy/03nVtWTU7bWeZh6jNUcAiCaFTURl9A+gs56AviHzh3mnqtdPxm6knfQPLU7UaokASQq/agY7yDrG16Mba6Pz48NP56VdrgAApYObGaicPtkovToFLQBKA/WUxTe3FRk4san15aGKgd3Dj560rrdGJS6FT0X9YYvLuiMKL1kAQOpHZ3PqfyZfP41+9PW1VfzX0RXFSECfgNEmSTgImdDruF2O0E8vvqZG1auQubAsKooIYYHpGvwA2g+xndQBHgWa6cG0ih5cW/w6VvEq3nChwCoBvs+bL2Z7VceBHGTDAIrABpMVuhw+4OiLgLIglOLPYBTQAlfErIeCzjRVg1dtEb1kt5Omv+DTV2YssAN+zNdkzC42N9brV8WdvYp07seOdM2Of1F3AAknW0AJpwN6IgEPAEaANaMlcbmZdl7KRBuAfAb+v//yMAJoAAAAASUVORK5CYII=")}div.clearer{clear:both}div.related{width:100%;font-size:90%}div.related ul{margin:0;padding:0 0 0 10px;list-style:none}div.related li{display:inline}div.related li.right{float:right;margin-right:5px}div.sphinxsidebarwrapper{padding:10px 5px 0 10px}div.sphinxsidebar{float:left;width:230px;margin-left:-100%;word-wrap:break-word;overflow-wrap:break-word}div.sphinxsidebar ul{list-style:none}div.sphinxsidebar ul ul{margin-left:20px;list-style:square}div.sphinxsidebar ul ul{margin-top:0;margin-bottom:0}img{border:0;max-width:100%}div.body{min-width:450px;max-width:800px}div.body p,div.body dd,div.body li{-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto}a.headerlink{visibility:hidden}a.brackets:before,span.brackets>a:before{content:"["}a.brackets:after,span.brackets>a:after{content:"]"}h1:hover>a.headerlink,h2:hover>a.headerlink,h3:hover>a.headerlink,h4:hover>a.headerlink,h5:hover>a.headerlink,h6:hover>a.headerlink,dt:hover>a.headerlink,caption:hover>a.headerlink,p.caption:hover>a.headerlink,div.code-block-caption:hover>a.headerlink{visibility:visible}div.admonition{margin-top:10px;margin-bottom:10px;padding:7px}p.admonition-title{margin:0px 10px 5px 0px;font-weight:bold}li>p:first-child{margin-top:0px}li>p:last-child{margin-bottom:0px}dl.footnote>dt{float:left}dl.footnote>dd{margin-bottom:0em}dl.footnote>dd:after,dl.citation>dd:after{content:"";clear:both}dl{margin-bottom:15px}dd>p:first-child{margin-top:0px}dd{margin-top:3px;margin-left:30px}dt:target,span.highlighted{background-color:#fbe54e}.versionmodified{font-style:italic}.footnote:target{background-color:#ffa}pre{overflow:auto;overflow-y:hidden}span.pre{-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;hyphens:none}div.doctest>div.highlight span.gp{user-select:none}code.xref{background-color:transparent;font-weight:bold}html{background-color:#fff}body{font-family:'Lucida Grande',Arial,sans-serif;font-size:100%;color:#000;margin:0;padding:0}div.document{background-color:white}div.documentwrapper{float:left;width:100%}div.bodywrapper{margin:0 0 0 230px}div.body{background-color:white;color:#222}div.footer{color:#555;padding:9px 0 9px 0;font-size:75%}div.footer a{color:#555;text-decoration:underline}div.related{background-color:white;line-height:30px;color:#666}div.related a{color:#444}div.sphinxsidebar h3{font-family:'Lucida Grande',Arial,sans-serif;color:#444;font-size:1.4em;font-weight:normal;margin:0;padding:0}div.sphinxsidebar h3 a{color:#444}div.sphinxsidebar h4{font-family:'Lucida Grande',Arial,sans-serif;color:#444;font-size:1.3em;font-weight:normal;margin:5px 0 0 0;padding:0}div.sphinxsidebar p{color:#444}div.sphinxsidebar p.topless{margin:5px 10px 10px 10px}div.sphinxsidebar ul{margin:10px;padding:0;color:#444}div.sphinxsidebar a{color:#444}a{color:#0090c0;text-decoration:none}a:visited{color:#00608f;text-decoration:none}a:hover{text-decoration:underline}div.body h1,div.body h2,div.body h3{font-family:'Lucida Grande',Arial,sans-serif;background-color:white;font-weight:normal;color:#1a1a1a;border-bottom:1px solid #ccc}div.body h1{margin-top:0;font-size:200%}div.body h2{font-size:160%}div.body h3{font-size:140%}a.headerlink{font-size:.8em;padding:0 4px 0 4px;text-decoration:none}a.headerlink:hover{background-color:#aaa;color:white}div.body p,div.body dd,div.body li{text-align:justify;line-height:130%}div.admonition p.admonition-title+p{display:inline}div.admonition p{margin-bottom:5px}div.admonition pre{margin-bottom:5px}div.note{background-color:#eee;border:1px solid #ccc}p.admonition-title{display:inline}p.admonition-title:after{content:":"}pre{padding:5px;background-color:#efc;color:#333;line-height:120%;border-left:0;border-right:0}code{background-color:#ecf0f3;padding:0 1px 0 1px}.note code{background:#d6d6d6}body{background-color:white;margin-left:1em;margin-right:1em}div.related{margin-bottom:1.2em;padding:.5em 0;border-top:1px solid #ccc;margin-top:.5em}div.related a:hover{color:#0095c4}div.related:first-child{border-top:0;border-bottom:1px solid #ccc}.inline-search{display:inline}form.inline-search input{display:inline}form.inline-search input[type="submit"]{width:40px}div.sphinxsidebar{background-color:#eee;border-radius:5px;line-height:130%;font-size:smaller}div.sphinxsidebar h3,div.sphinxsidebar h4{margin-top:1.5em}div.sphinxsidebarwrapper>h3:first-child{margin-top:.2em}div.sphinxsidebarwrapper>ul>li>ul>li{margin-bottom:.4em}div.sphinxsidebar a:hover{color:#0095c4}form.inline-search input{font-family:'Lucida Grande',Arial,sans-serif;border:1px solid #999;font-size:smaller;border-radius:3px}div.body{padding:0 0 0 1.2em}div.body p{line-height:140%}div.body h1,div.body h2,div.body h3{margin:0;border:0;padding:.3em 0}div.body pre{border-radius:3px;border:1px solid #ac9}div.body div.admonition{border-radius:3px}div.body a{color:#0072aa}div.body a:visited{color:#6363bb}div.body a:hover{color:#00b0e4}code,pre{font-family:monospace,sans-serif;font-size:96.5%}div.body code{border-radius:3px}div.body code.xref{font-weight:normal}div.footer{line-height:150%;margin-top:-2em;text-align:right;width:auto;margin-right:10px}div.footer a:hover{color:#0095c4}.highlight{background:none!important}.highlight{background:#efc}.highlight .c{color:#408090;font-style:italic}.highlight .k{color:#007020;font-weight:bold}.highlight .o{color:#666}.highlight .c1{color:#408090;font-style:italic}.highlight .gr{color:red}.highlight .go{color:#333}.highlight .gp{color:#c65d09;font-weight:bold}.highlight .gt{color:#04d}.highlight .kc{color:#007020;font-weight:bold}.highlight .kn{color:#007020;font-weight:bold}.highlight .nb{color:#007020}.highlight .nc{color:#0e84b5;font-weight:bold}.highlight .nd{color:#555;font-weight:bold}.highlight .ne{color:#007020}.highlight .nf{color:#06287e}.highlight .nn{color:#0e84b5;font-weight:bold}.highlight .ow{color:#007020;font-weight:bold}.highlight .mi{color:#208050}.highlight .s2{color:#4070a0}.highlight .s1{color:#4070a0}.highlight .bp{color:#007020}.highlight .fm{color:#06287e}</style>
<link rel=search type=application/opensearchdescription+xml title="在 Python 3.9.0b3 文档 中搜索" href=https://docs.python.org/zh-cn/3.9/_static/opensearch.xml>
<link rel=author title=关于这些文档 href=https://docs.python.org/zh-cn/3.9/about.html>
<link rel=index title=索引 href=https://docs.python.org/zh-cn/3.9/genindex.html>
<link rel=search title=搜索 href=https://docs.python.org/zh-cn/3.9/search.html>
<link rel=copyright title=版权所有 href=https://docs.python.org/zh-cn/3.9/copyright.html>
<link rel=next title="2to3 - 自动将 Python 2 代码转为 Python 3 代码" href=https://docs.python.org/zh-cn/3.9/library/2to3.html>
<link rel=prev title="unittest.mock --- mock对象库" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html>
<link rel=canonical href=https://docs.python.org/3/library/unittest.mock-examples.html>
<style>@-webkit-keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@-webkit-keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gEGxE4IQYzJ14AAAI3SURBVDjLZZNPSFVBFIe/e9+zd3silBCl0SZoU4s2rVq0EB5tQip4UNvATVGu3QRBiyAi2iltWkgbF5EgRhFFRpiWtrWIzDIV1Pzz7p15M2fmtvDevOqBw8DM9zvnN8ycgF3R/eDtM2mac96ZdrFNxBikqbRV+vHH/ut9gAZczoe7C3gnF0f6au1OLM5avFi8d1Ea+JvAMSAq8nsKOGs5f2cYJ3Y7rc2PO4BqkS8DdD98f9tbe1ysCoxOBo1qlEXHJWcM4b5KPU19zleA0o4Clx99eO3EdqVewHsCoFRugUoVghJO7A6H6Vx9wdtYi27cr5x6dy/03nVtWTU7bWeZh6jNUcAiCaFTURl9A+gs56AviHzh3mnqtdPxm6knfQPLU7UaokASQq/agY7yDrG16Mba6Pz48NP56VdrgAApYObGaicPtkovToFLQBKA/WUxTe3FRk4san15aGKgd3Dj560rrdGJS6FT0X9YYvLuiMKL1kAQOpHZ3PqfyZfP41+9PW1VfzX0RXFSECfgNEmSTgImdDruF2O0E8vvqZG1auQubAsKooIYYHpGvwA2g+xndQBHgWa6cG0ih5cW/w6VvEq3nChwCoBvs+bL2Z7VceBHGTDAIrABpMVuhw+4OiLgLIglOLPYBTQAlfErIeCzjRVg1dtEb1kt5Omv+DTV2YssAN+zNdkzC42N9brV8WdvYp07seOdM2Of1F3AAknW0AJpwN6IgEPAEaANaMlcbmZdl7KRBuAfAb+v//yMAJoAAAAASUVORK5CYII="><style>.sf-hidden{display:none!important}</style><body><style>.cyxy-target-popup{padding:1.3rem 12px;position:absolute;display:-webkit-flex;flex-direction:row;overflow:scroll;vertical-align:middle;z-index:199099;top:1px;left:1px;background:#fff;opacity:0.98;height:auto;width:auto;border:1px solid #E6E6E6;box-shadow:0 0 8px 0 rgba(0,0,0,0.13);border-radius:5px}@media (max-width:468px){.cyxy-target-popup{left:10%}}.cyxy-footer{position:fixed;bottom:0px;padding:0px 0px;left:0;right:0;margin:auto;border:1px solid #E6E6E6;box-shadow:0 0 8px 0 rgba(0,0,0,0.13);border-radius:2px;z-index:201712;text-align:center}.cyxy-footer-p{padding:12px 0px;margin:0px;font-size:12px;color:#333;background:#fff;text-align:center;line-height:1.6;font-weight:200}@-webkit-keyframes layui-m-anim-scale{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes layui-m-anim-scale{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@-webkit-keyframes layui-m-anim-up{0%{opacity:0;-webkit-transform:translateY(800px);transform:translateY(800px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes layui-m-anim-up{0%{opacity:0;-webkit-transform:translateY(800px);transform:translateY(800px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes layui-m-anim-loading{0%,100%,80%{transform:scale(0);-webkit-transform:scale(0)}40%{transform:scale(1);-webkit-transform:scale(1)}}@keyframes layui-m-anim-loading{0%,100%,80%{transform:scale(0);-webkit-transform:scale(0)}40%{transform:scale(1);-webkit-transform:scale(1)}}.cyxy-function{position:fixed;bottom:140px;right:20px;z-index:109999;cursor:pointer}.cyxy-personal{position:fixed;bottom:190px;right:20px;z-index:109999;cursor:pointer}.cyxy-favorite{position:fixed;bottom:90px;right:20px;z-index:109999;cursor:pointer}.cyxy-favorite-btn{height:36px;width:36px;border-radius:50%;overflow:hidden}</style><style>.cyxy-video-trans{position:fixed;bottom:130px;right:20px;z-index:2147483647!important;cursor:pointer;filter:grayscale(100%);height:50px!important}.cyxy-video-trans-btn{height:36px!important;width:36px!important;border-radius:50%;overflow:hidden}</style>
 
 <div class=related role=navigation aria-label="related navigation">
 <h3 class="cyxy-trs-source cyxy-trs-source-ted sf-hidden">导航</h3><h3 class="cyxy-trs-source cyxy-trs-target sf-hidden">Navigation</h3>
 <ul>
 <li class=right style=margin-right:10px>
 <a href=https://docs.python.org/zh-cn/3.9/genindex.html title=总目录 accesskey=I class="cyxy-trs-source cyxy-trs-source-ted">索引<font class=cyxy-trs-target> Index</font></a></li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/py-modindex.html title="Python 模块索引" class="cyxy-trs-source cyxy-trs-source-ted">模块<font class=cyxy-trs-target> Module</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/2to3.html title="2to3 - 自动将 Python 2 代码转为 Python 3 代码" accesskey=N class="cyxy-trs-source cyxy-trs-source-ted">下一页<font class=cyxy-trs-target> Next page</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html title="unittest.mock --- mock对象库" accesskey=P class="cyxy-trs-source cyxy-trs-source-ted">上一页<font class=cyxy-trs-target> Previous</font></a> |</li>
 <li><img src='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><rect fill-opacity="0"/></svg>' alt style="vertical-align:middle;margin-top:-1px;background-blend-mode:normal!important;background-clip:content-box!important;background-position:50% 50%!important;background-color:rgba(0,0,0,0)!important;background-image:var(--sf-img-1)!important;background-size:100% 100%!important;background-origin:content-box!important;background-repeat:no-repeat!important"></li>
 <li><a href=https://www.python.org/ class="cyxy-trs-source cyxy-trs-source-ted">Python<font class=cyxy-trs-target> 巨蟒</font></a> »</li>
 
 <li>
 <span class=language_switcher_placeholder><select><option value=en>English<option value=fr>French<option value=ja>Japanese<option value=ko>Korean<option value=pt-br>Brazilian Portuguese<option value=zh-cn selected>Simplified Chinese</select></span>
 <span class=version_switcher_placeholder><select><option value=3.10>dev (3.10)<option value=3.9 selected>3.9.0b3<option value=3.8>3.8<option value=3.7>3.7<option value=3.6>3.6<option value=3.5>3.5<option value=2.7>2.7</select></span>
 <a href=https://docs.python.org/zh-cn/3.9/index.html class="cyxy-trs-source cyxy-trs-source-ted">文档<font class=cyxy-trs-target> Documents</font></a> »
 </li>
 <li class="nav-item nav-item-1"><a href=https://docs.python.org/zh-cn/3.9/library/index.html class="cyxy-trs-source cyxy-trs-source-ted">Python 标准库<font class=cyxy-trs-target> Python Standard Library</font></a> »</li>
 <li class="nav-item nav-item-2"><a href=https://docs.python.org/zh-cn/3.9/library/development.html accesskey=U class="cyxy-trs-source cyxy-trs-source-ted">开发工具<font class=cyxy-trs-target> Development Tools</font></a> »</li>
 <li class=right>
 
 <div class=inline-search role=search>
 <form class=inline-search action=../search.html>
 <input placeholder=快速搜索 type=text name=q value>
 <input type=submit value=转向>
 
 
 </form>
 </div>
 
 |
 </li>
 </ul>
 </div> 
 <div class=document>
 <div class=documentwrapper>
 <div class=bodywrapper>
 <div class=body role=main>
 
 <div class=section id=unittest-mock-getting-started>
<h1 class=cyxy-trs-source><a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> 上手指南<font class=cyxy-trs-target> How to get started</font><a class=headerlink href=#unittest-mock-getting-started title=永久链接至标题>¶</a></h1>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.3 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">3.3 new features.</p>
</div>
<span class=target id=getting-started></span><div class=section id=using-mock>
<h2 class=cyxy-trs-source>使用 mock<font class=cyxy-trs-target> Using mocks</font><a class=headerlink href=#using-mock title=永久链接至标题>¶</a></h2>
<div class=section id=mock-patching-methods>
<h3 class=cyxy-trs-source>模拟方法调用<font class=cyxy-trs-target> Simulating a method call</font><a class=headerlink href=#mock-patching-methods title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">使用 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 的常见场景：<p class="cyxy-trs-source cyxy-trs-target">A COMMON SCENARIO FOR USING MOCKS:</p>
<ul class=simple>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">模拟函数调用<p class="cyxy-trs-source cyxy-trs-target">Analog function call</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">记录“对象上的方法调用”<p class="cyxy-trs-source cyxy-trs-target">Record method calls on objects</p></li>
</ul>
<p class="cyxy-trs-source cyxy-trs-source-ted">你可能需要替换一个对象上的方法，用于确认此方法被系统中的其他部分调用过，并且调用时使用了正确的参数。<p class="cyxy-trs-source cyxy-trs-target">You may need to replace a method on an object to make sure that it has been called by another part of the system with the correct parameters.</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>real</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'method'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'value'</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='method()' id='...'&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">使用了 mock（本例中的 <code class="docutils literal notranslate"><span class=pre>real.method</span></code>）之后，它有方法和属性可以让你针对它是被如何使用的下断言。<p class="cyxy-trs-source cyxy-trs-target">With mock (real.method in this case) , it has methods and properties that let you make assertions about how it is used.</p>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">在多数示例中，<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 与 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 两个类可以相互替换，而 <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> 是一个更适用的类，通常情况下，使用它就可以了。<p class="cyxy-trs-source cyxy-trs-target">In most cases, the Mock and the MagicMock classes can be replaced with each other, and MagicMock is a more appropriate class that, in general, you can use.</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">如果 mock 被调用，它的 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.called title=unittest.mock.Mock.called><code class="xref py py-attr docutils literal notranslate"><span class=pre>called</span></code></a> 属性就会变成 <code class="docutils literal notranslate"><span class=pre>True</span></code>，更重要的是，我们可以使用 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> 或者 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> 方法来确认它在被调用时使用了正确的参数。<p class="cyxy-trs-source cyxy-trs-target">If the mock is called, its called attribute becomes True, and more importantly, we can use the assert or assert method to verify that it takes the correct arguments when called.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">在如下的测试示例中，验证对于 <code class="docutils literal notranslate"><span class=pre>ProductionClass().method</span></code> 的调用会导致 <code class="docutils literal notranslate"><span class=pre>something</span></code> 的调用。<p class="cyxy-trs-source cyxy-trs-target">In the following test example, verify for production class. . The call to method causes the call to something.</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>ProductionClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>something</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>something</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>something</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>something</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
</div>
<div class=section id=mock-for-method-calls-on-an-object>
<h3 class=cyxy-trs-source>对象上的方法调用的 mock<font class=cyxy-trs-target> A mock for a method call on an</font><a class=headerlink href=#mock-for-method-calls-on-an-object title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">In the last example we patched a method directly on an object to check that it
was called correctly. Another common use case is to pass an object into a
method (or some part of the system under test) and then check that it is used
in the correct way.<p class="cyxy-trs-source cyxy-trs-target">在上一个示例中，我们直接在对象上修补了一个方法，以检查它是否被正确调用。 另一个常见的用例是将一个对象传递给一个方法(或者被测试系统的某个部分) ，然后检查它是否以正确的方式使用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The simple <code class="docutils literal notranslate"><span class=pre>ProductionClass</span></code> below has a <code class="docutils literal notranslate"><span class=pre>closer</span></code> method. If it is called with
an object then it calls <code class="docutils literal notranslate"><span class=pre>close</span></code> on it.<p class="cyxy-trs-source cyxy-trs-target">下面的简单 ProductionClass 有一个 closer 方法。 如果使用对象调用它，那么它将调用 close。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>ProductionClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>closer</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>something</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>something</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
<span class=gp>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">So to test it we need to pass in an object with a <code class="docutils literal notranslate"><span class=pre>close</span></code> method and check
that it was called correctly.<p class="cyxy-trs-source cyxy-trs-target">因此，为了测试它，我们需要使用 close 方法传入一个对象，并检查它是否被正确调用。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>real</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>closer</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>close</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">We don't have to do any work to provide the 'close' method on our mock.
Accessing close creates it. So, if 'close' hasn't already been called then
accessing it in the test will create it, but <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a>
will raise a failure exception.<p class="cyxy-trs-source cyxy-trs-target">我们不需要做任何工作就可以在 mock 上提供“ close”方法。 近距离接触创造了它。 因此，如果‘ close’还没有被调用，那么在测试中访问它将创建它，但是用()调用的 assert 将引发失败异常。</p>
</div>
<div class=section id=mocking-classes>
<h3 class=cyxy-trs-source>Mocking Classes<font class=cyxy-trs-target> 嘲笑课程</font><a class=headerlink href=#mocking-classes title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">A common use case is to mock out classes instantiated by your code under test.
When you patch a class, then that class is replaced with a mock. Instances
are created by <em>calling the class</em>. This means you access the "mock instance"
by looking at the return value of the mocked class.<p class="cyxy-trs-source cyxy-trs-target">一个常见的用例是模拟出由测试代码实例化的类。 当您修补一个类时，该类将被一个 mock 替换。 实例是通过调用类来创建的。 这意味着通过查看调用类的返回值来访问“模拟实例”。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">In the example below we have a function <code class="docutils literal notranslate"><span class=pre>some_function</span></code> that instantiates <code class="docutils literal notranslate"><span class=pre>Foo</span></code>
and calls a method on it. The call to <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> replaces the class <code class="docutils literal notranslate"><span class=pre>Foo</span></code> with a
mock. The <code class="docutils literal notranslate"><span class=pre>Foo</span></code> instance is the result of calling the mock, so it is configured
by modifying the mock <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">在下面的例子中，我们有一个函数，它实例化了 Foo 并调用了一个方法。 对 patch ()的调用用 mock 替换了 Foo 类。 Foo 实例是调用 mock 的结果，因此可以通过修改 mock 返回值来配置它。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>some_function</span><span class=p>():</span>
<span class=gp>... </span>    <span class=n>instance</span> <span class=o>=</span> <span class=n>module</span><span class=o>.</span><span class=n>Foo</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>instance</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'module.Foo'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>instance</span> <span class=o>=</span> <span class=n>mock</span><span class=o>.</span><span class=n>return_value</span>
<span class=gp>... </span>    <span class=n>instance</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'the result'</span>
<span class=gp>... </span>    <span class=n>result</span> <span class=o>=</span> <span class=n>some_function</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>result</span> <span class=o>==</span> <span class=s1>'the result'</span>
</pre></div>
</div>
</div>
<div class=section id=naming-your-mocks>
<h3 class=cyxy-trs-source>Naming your mocks<font class=cyxy-trs-target> 给你的模拟命名</font><a class=headerlink href=#naming-your-mocks title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">It can be useful to give your mocks a name. The name is shown in the repr of
the mock and can be helpful when the mock appears in test failure messages. The
name is also propagated to attributes or methods of the mock:<p class="cyxy-trs-source cyxy-trs-target">给你的模拟起一个名字是很有用的。 这个名称显示在 mock 的 repr 中，当 mock 出现在测试失败消息中时，它可以提供帮助。 名称也会传播到 mock 的属性或方法:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span>
<span class=go>&lt;MagicMock name='foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span>
<span class=go>&lt;MagicMock name='foo.method' id='...'&gt;</span>
</pre></div>
</div>
</div>
<div class=section id=tracking-all-calls>
<h3 class=cyxy-trs-source>Tracking all Calls<font class=cyxy-trs-target> 追踪所有电话</font><a class=headerlink href=#tracking-all-calls title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Often you want to track more than a single call to a method. The
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> attribute records all calls
to child attributes of the mock - and also to their children.<p class="cyxy-trs-source cyxy-trs-target">通常，您希望跟踪对方法的多个调用。 Mock 调用属性记录对 mock 的子属性以及它们的子属性的所有调用。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>attribute</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=mi>53</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock.attribute.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.method(), call.attribute.method(10, x=53)]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you make an assertion about <code class="docutils literal notranslate"><span class=pre>mock_calls</span></code> and any unexpected methods
have been called, then the assertion will fail. This is useful because as well
as asserting that the calls you expected have been made, you are also checking
that they were made in the right order and with no additional calls:<p class="cyxy-trs-source cyxy-trs-target">如果对模拟调用进行断言，并且调用了任何意外的方法，则断言将失败。 这是非常有用的，因为除了确认你期望的电话已经打出之外，你还要检查它们是否按照正确的顺序打出，没有额外的电话:</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You use the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> object to construct lists for comparing with
<code class="docutils literal notranslate"><span class=pre>mock_calls</span></code>:<p class="cyxy-trs-source cyxy-trs-target">您可以使用 call 对象来构造用于与 mock 调用进行比较的列表:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=o>.</span><span class=n>method</span><span class=p>(),</span> <span class=n>call</span><span class=o>.</span><span class=n>attribute</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=mi>53</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">However, parameters to calls that return mocks are not recorded, which means it is not
possible to track nested calls where the parameters used to create ancestors are important:<p class="cyxy-trs-source cyxy-trs-target">然而，返回模拟的调用的参数没有被记录，这意味着不可能跟踪用于创建祖先的参数非常重要的嵌套调用:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>factory</span><span class=p>(</span><span class=n>important</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span><span class=o>.</span><span class=n>deliver</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.factory().deliver()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>call</span><span class=o>.</span><span class=n>factory</span><span class=p>(</span><span class=n>important</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span><span class=o>.</span><span class=n>deliver</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
<div class=section id=setting-return-values-and-attributes>
<h3 class=cyxy-trs-source>Setting Return Values and Attributes<font class=cyxy-trs-target> 设置返回值和属性</font><a class=headerlink href=#setting-return-values-and-attributes title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Setting the return values on a mock object is trivially easy:<p class="cyxy-trs-source cyxy-trs-target">在模拟对象上设置返回值非常简单:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=mi>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Of course you can do the same for methods on the mock:<p class="cyxy-trs-source cyxy-trs-target">当然，对 mock 上的方法也可以这样做:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=mi>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The return value can also be set in the constructor:<p class="cyxy-trs-source cyxy-trs-target">返回值也可以在构造函数中设置:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you need an attribute setting on your mock, just do it:<p class="cyxy-trs-source cyxy-trs-target">如果您需要在 mock 上设置属性，只需要这样做:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>x</span>
<span class=go>3</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes you want to mock up a more complex situation, like for example
<code class="docutils literal notranslate"><span class=pre>mock.connection.cursor().execute("SELECT</span> <span class=pre>1")</span></code>. If we wanted this call to
return a list, then we have to configure the result of the nested call.<p class="cyxy-trs-source cyxy-trs-target">有时您需要模拟更复杂的情况，例如 mock.connection.cursor ()。 执行(「 SELECT 1」)。 如果我们希望这个调用返回一个列表，那么我们必须配置嵌套调用的结果。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">We can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> to construct the set of calls in a "chained call" like
this for easy assertion afterwards:<p class="cyxy-trs-source cyxy-trs-target">我们可以使用 call 在一个像这样的“链式调用”中构造一组调用，以便在后面简单地断言:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>cursor</span> <span class=o>=</span> <span class=n>mock</span><span class=o>.</span><span class=n>connection</span><span class=o>.</span><span class=n>cursor</span><span class=o>.</span><span class=n>return_value</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=p>[</span><span class=s1>'foo'</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>connection</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>"SELECT 1"</span><span class=p>)</span>
<span class=go>['foo']</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=n>call</span><span class=o>.</span><span class=n>connection</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>"SELECT 1"</span><span class=p>)</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.connection.cursor(), call.connection.cursor().execute('SELECT 1')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">It is the call to <code class="docutils literal notranslate"><span class=pre>.call_list()</span></code> that turns our call object into a list of
calls representing the chained calls.<p class="cyxy-trs-source cyxy-trs-target">这是对. call list ()的调用，它将调用对象转换为表示链接调用的调用列表。</p>
</div>
<div class=section id=raising-exceptions-with-mocks>
<h3 class=cyxy-trs-source>Raising exceptions with mocks<font class=cyxy-trs-target> 使用模拟引发异常</font><a class=headerlink href=#raising-exceptions-with-mocks title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">A useful attribute is <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a>. If you set this to an
exception class or instance then the exception will be raised when the mock
is called.<p class="cyxy-trs-source cyxy-trs-target">一个有用的属性是副作用。 如果将其设置为异常类或实例，则在调用 mock 时将引发异常。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>Exception</span><span class=p>(</span><span class=s1>'Boom!'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>Exception</span><span>: </span><span class=n>Boom!</span>
</pre></div>
</div>
</div>
<div class=section id=side-effect-functions-and-iterables>
<h3 class=cyxy-trs-source>Side effect functions and iterables<font class=cyxy-trs-target> 副作用函数和迭代</font><a class=headerlink href=#side-effect-functions-and-iterables title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>side_effect</span></code> can also be set to a function or an iterable. The use case for
<code class="docutils literal notranslate"><span class=pre>side_effect</span></code> as an iterable is where your mock is going to be called several
times, and you want each call to return a different value. When you set
<code class="docutils literal notranslate"><span class=pre>side_effect</span></code> to an iterable every call to the mock returns the next value
from the iterable:<p class="cyxy-trs-source cyxy-trs-target">副作用也可以设置为一个函数或一个迭代。 作为迭代的副作用的用例是，您的 mock 将被调用多次，并且您希望每次调用返回一个不同的值。 当你为一个可迭代的模拟设置副作用时，每次调用都会返回来自可迭代的下一个值:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>4</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>5</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>6</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">For more advanced use cases, like dynamically varying the return values
depending on what the mock is called with, <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> can be a function.
The function will be called with the same arguments as the mock. Whatever the
function returns is what the call returns:<p class="cyxy-trs-source cyxy-trs-target">对于更高级的用例，比如根据 mock 的调用动态地改变返回值，副作用可以是一个函数。 函数将使用与 mock 相同的参数调用。 无论函数返回什么，调用返回的都是:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>vals</span> <span class=o>=</span> <span class=p>{(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>):</span> <span class=mi>1</span><span class=p>,</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>):</span> <span class=mi>2</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>vals</span><span class=p>[</span><span class=n>args</span><span class=p>]</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>side_effect</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=go>2</span>
</pre></div>
</div>
</div>
<div class=section id=mocking-asynchronous-iterators>
<h3 class=cyxy-trs-source>Mocking asynchronous iterators<font class=cyxy-trs-target> 模仿异步迭代器</font><a class=headerlink href=#mocking-asynchronous-iterators title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Since Python 3.8, <code class="docutils literal notranslate"><span class=pre>AsyncMock</span></code> and <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> have support to mock
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#async-iterators><span class="std std-ref">异步迭代器</span></a> through <code class="docutils literal notranslate"><span class=pre>__aiter__</span></code>. The <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a>
attribute of <code class="docutils literal notranslate"><span class=pre>__aiter__</span></code> can be used to set the return values to be used for
iteration.<p class="cyxy-trs-source cyxy-trs-target">自 Python 3.8以来，AsyncMock 和 MagicMock 通过 aiter 支持 mock something something something。 Aiter 的 return value 属性可用于设置用于迭代的返回值。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>  <span class=c1># AsyncMock also works here</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__aiter__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=p>[</span><span class=n>i</span> <span class=k>async</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>mock</span><span class=p>]</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=go>[1, 2, 3]</span>
</pre></div>
</div>
</div>
<div class=section id=mocking-asynchronous-context-manager>
<h3 class=cyxy-trs-source>Mocking asynchronous context manager<font class=cyxy-trs-target> 模仿异步上下文管理器</font><a class=headerlink href=#mocking-asynchronous-context-manager title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Since Python 3.8, <code class="docutils literal notranslate"><span class=pre>AsyncMock</span></code> and <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> have support to mock
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#async-context-managers><span class="std std-ref">异步上下文管理器</span></a> through <code class="docutils literal notranslate"><span class=pre>__aenter__</span></code> and <code class="docutils literal notranslate"><span class=pre>__aexit__</span></code>.
By default, <code class="docutils literal notranslate"><span class=pre>__aenter__</span></code> and <code class="docutils literal notranslate"><span class=pre>__aexit__</span></code> are <code class="docutils literal notranslate"><span class=pre>AsyncMock</span></code> instances that
return an async function.<p class="cyxy-trs-source cyxy-trs-target">自 Python 3.8以来，AsyncMock 和 MagicMock 通过 aenter 和 aexit 支持 mock something something something something something。 默认情况下，aenter 和 aexit 是 AsyncMock 实例，它们返回一个 async 函数。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>AsyncContextManager</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aenter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=bp>self</span>
<span class=gp>... </span>    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aexit__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>exc_type</span><span class=p>,</span> <span class=n>exc</span><span class=p>,</span> <span class=n>tb</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_instance</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>AsyncContextManager</span><span class=p>())</span>  <span class=c1># AsyncMock also works here</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>async</span> <span class=k>with</span> <span class=n>mock_instance</span> <span class=k>as</span> <span class=n>result</span><span class=p>:</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_instance</span><span class=o>.</span><span class=fm>__aenter__</span><span class=o>.</span><span class=n>assert_awaited_once</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_instance</span><span class=o>.</span><span class=fm>__aexit__</span><span class=o>.</span><span class=n>assert_awaited_once</span><span class=p>()</span>
</pre></div>
</div>
</div>
<div class=section id=creating-a-mock-from-an-existing-object>
<h3 class=cyxy-trs-source>Creating a Mock from an Existing Object<font class=cyxy-trs-target> 从现有对象创建模拟</font><a class=headerlink href=#creating-a-mock-from-an-existing-object title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">One problem with over use of mocking is that it couples your tests to the
implementation of your mocks rather than your real code. Suppose you have a
class that implements <code class="docutils literal notranslate"><span class=pre>some_method</span></code>. In a test for another class, you
provide a mock of this object that <em>also</em> provides <code class="docutils literal notranslate"><span class=pre>some_method</span></code>. If later
you refactor the first class, so that it no longer has <code class="docutils literal notranslate"><span class=pre>some_method</span></code> - then
your tests will continue to pass even though your code is now broken!<p class="cyxy-trs-source cyxy-trs-target">过度使用 mocking 的一个问题是，它将测试与 mock 的实现挂钩，而不是与实际代码挂钩。 假设您有一个实现某个方法的类。 在另一个类的测试中，您提供了这个对象的模拟，它还提供了一些方法。 如果稍后您重构了第一个类，使其不再具有某个方法——那么您的测试将继续通过，即使您的代码现在已经中断！</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> allows you to provide an object as a specification for the mock,
using the <em>spec</em> keyword argument. Accessing methods / attributes on the
mock that don't exist on your specification object will immediately raise an
attribute error. If you change the implementation of your specification, then
tests that use that class will start failing immediately without you having to
instantiate the class in those tests.<p class="cyxy-trs-source cyxy-trs-target">通过使用 spec 关键字参数，Mock 允许您提供一个对象作为 Mock 的规范。 访问模拟上规范对象中不存在的方法 / 属性将立即引发属性错误。 如果您更改了规范的实现，那么使用该类的测试将立即开始失败，而不必在那些测试中实例化该类。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>SomeClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>old_method</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
   <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>object has no attribute 'old_method'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using a specification also enables a smarter matching of calls made to the
mock, regardless of whether some parameters were passed as positional or
named arguments:<p class="cyxy-trs-source cyxy-trs-target">使用规范还可以更聪明地匹配对 mock 的调用，无论某些参数是作为位置参数还是命名参数传递的:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span> <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>f</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=go>&lt;Mock name='mock()' id='140161580456576'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>c</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want this smarter matching to also work with method calls on the mock,
you can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#auto-speccing><span class="std std-ref">auto-speccing</span></a>.<p class="cyxy-trs-source cyxy-trs-target">如果您希望这种更聪明的匹配也能处理 mock 上的方法调用，那么可以使用自动投影。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want a stronger form of specification that prevents the setting
of arbitrary attributes as well as the getting of them then you can use
<em>spec_set</em> instead of <em>spec</em>.<p class="cyxy-trs-source cyxy-trs-target">如果您想要一个更强大的规范形式来防止任意属性的设置以及获取它们，那么您可以使用 spec set 而不是 spec。</p>
</div>
</div>
<div class=section id=patch-decorators>
<h2 class=cyxy-trs-source>Patch Decorators<font class=cyxy-trs-target> 修补装饰者</font><a class=headerlink href=#patch-decorators title=永久链接至标题>¶</a></h2>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">With <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> it matters that you patch objects in the namespace where
they are looked up. This is normally straightforward, but for a quick guide
read <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#where-to-patch><span class="std std-ref">where to patch</span></a>.<p class="cyxy-trs-source cyxy-trs-target">使用 patch ()时，重要的是在查找对象的名称空间中对其进行补丁。 这通常是直截了当的，但作为一个快速指南，请阅读哪里需要修补。</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A common need in tests is to patch a class attribute or a module attribute,
for example patching a builtin or patching a class in a module to test that it
is instantiated. Modules and classes are effectively global, so patching on
them has to be undone after the test or the patch will persist into other
tests and cause hard to diagnose problems.<p class="cyxy-trs-source cyxy-trs-target">测试中的一个常见需求是修补类属性或模块属性，例如修补内建类或修补模块中的类以测试它是否被实例化。 模块和类实际上是全局的，因此必须在测试之后撤消对它们的补丁，否则补丁将持续到其他测试中，从而导致难以诊断问题。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">mock provides three convenient decorators for this: <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>, <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> and
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a>. <code class="docutils literal notranslate"><span class=pre>patch</span></code> takes a single string, of the form
<code class="docutils literal notranslate"><span class=pre>package.module.Class.attribute</span></code> to specify the attribute you are patching. It
also optionally takes a value that you want the attribute (or class or
whatever) to be replaced with. 'patch.object' takes an object and the name of
the attribute you would like patched, plus optionally the value to patch it
with.<p class="cyxy-trs-source cyxy-trs-target">Mock 为此提供了三种方便的装饰器: patch ()、 patc.object ()和 patc.dict ()。 Patch 使用 package.module 格式的一个字符串。 Attribute 来指定要修补的属性。 它还可以选择需要替换属性(或类或其他)的值。 ‘ patch.object’接受一个对象和您希望修补的属性的名称，还可以选择使用哪个值对其进行修补。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>patch.object</span></code>:<p class="cyxy-trs-source cyxy-trs-target">对象:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>attribute</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'attribute'</span><span class=p>,</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>attribute</span> <span class=o>==</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>attribute</span> <span class=o>==</span> <span class=n>original</span>

<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'package.module.attribute'</span><span class=p>,</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=kn>from</span> <span class=nn>package.module</span> <span class=kn>import</span> <span class=n>attribute</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>attribute</span> <span class=ow>is</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you are patching a module (including <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/builtins.html#module-builtins title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class=pre>builtins</span></code></a>) then use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>
instead of <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">如果你正在修补一个模块(包括内建模块) ，那么使用 patch ()代替 patch.object () :</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=n>sentinel</span><span class=o>.</span><span class=n>file_handle</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'builtins.open'</span><span class=p>,</span> <span class=n>mock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>handle</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'filename'</span><span class=p>,</span> <span class=s1>'r'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=s1>'filename'</span><span class=p>,</span> <span class=s1>'r'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>handle</span> <span class=o>==</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>file_handle</span><span class=p>,</span> <span class=s2>"incorrect file handle returned"</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The module name can be 'dotted', in the form <code class="docutils literal notranslate"><span class=pre>package.module</span></code> if needed:<p class="cyxy-trs-source cyxy-trs-target">如果需要，模块名可以在 package.module 表单中加上“虚线” :</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'package.module.ClassName.attribute'</span><span class=p>,</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=kn>from</span> <span class=nn>package.module</span> <span class=kn>import</span> <span class=n>ClassName</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>ClassName</span><span class=o>.</span><span class=n>attribute</span> <span class=o>==</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A nice pattern is to actually decorate test methods themselves:<p class="cyxy-trs-source cyxy-trs-target">一个很好的模式是实际装饰测试方法本身:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'attribute'</span><span class=p>,</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>SomeClass</span><span class=o>.</span><span class=n>attribute</span><span class=p>,</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>attribute</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_something'</span><span class=p>)</span><span class=o>.</span><span class=n>test_something</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>attribute</span> <span class=o>==</span> <span class=n>original</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want to patch with a Mock, you can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> with only one argument
(or <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> with two arguments). The mock will be created for you and
passed into the test function / method:<p class="cyxy-trs-source cyxy-trs-target">如果希望使用 Mock 打补丁，可以只使用一个参数的 patch ()(或者使用两个参数的 patch.object ())。 将为您创建 mock 并将其传递到 test 函数 / 方法中:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'static_method'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>mock_method</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>SomeClass</span><span class=o>.</span><span class=n>static_method</span><span class=p>()</span>
<span class=gp>... </span>        <span class=n>mock_method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_something'</span><span class=p>)</span><span class=o>.</span><span class=n>test_something</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can stack up multiple patch decorators using this pattern:<p class="cyxy-trs-source cyxy-trs-target">你可以使用这个模式堆叠多个修补程序修饰器:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=nd>@patch</span><span class=p>(</span><span class=s1>'package.module.ClassName1'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=nd>@patch</span><span class=p>(</span><span class=s1>'package.module.ClassName2'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>MockClass2</span><span class=p>,</span> <span class=n>MockClass1</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertIs</span><span class=p>(</span><span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>ClassName1</span><span class=p>,</span> <span class=n>MockClass1</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertIs</span><span class=p>(</span><span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>ClassName2</span><span class=p>,</span> <span class=n>MockClass2</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_something'</span><span class=p>)</span><span class=o>.</span><span class=n>test_something</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">When you nest patch decorators the mocks are passed in to the decorated
function in the same order they applied (the normal <em>Python</em> order that
decorators are applied). This means from the bottom up, so in the example
above the mock for <code class="docutils literal notranslate"><span class=pre>test_module.ClassName2</span></code> is passed in first.<p class="cyxy-trs-source cyxy-trs-target">当您使用 nest patch decorator 时，模拟按照它们应用的顺序传递给修饰函数(应用 decorator 的正常 Python 顺序)。 这意味着自下而上，因此在上面的模拟测试模块的示例中。 第一个传入 ClassName2。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">There is also <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> for setting values in a dictionary just
during a scope and restoring the dictionary to its original state when the test
ends:<p class="cyxy-trs-source cyxy-trs-target">还有 patch.dict () ，用于在范围内设置字典中的值，并在测试结束时将字典恢复到原始状态:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'key'</span><span class=p>:</span> <span class=s1>'value'</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>foo</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>},</span> <span class=n>clear</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=n>original</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>patch</span></code>, <code class="docutils literal notranslate"><span class=pre>patch.object</span></code> and <code class="docutils literal notranslate"><span class=pre>patch.dict</span></code> can all be used as context managers.<p class="cyxy-trs-source cyxy-trs-target">Patch、 patch.object 和 patch.dict 都可以用作上下文管理器。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Where you use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> to create a mock for you, you can get a reference to the
mock using the "as" form of the with statement:<p class="cyxy-trs-source cyxy-trs-target">在使用 patch ()创建 mock 的地方，可以使用 with 语句的“ as”形式获得对 mock 的引用:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>ProductionClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>ProductionClass</span><span class=p>,</span> <span class=s1>'method'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_method</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>mock_method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>... </span>    <span class=n>real</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>... </span>    <span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">As an alternative <code class="docutils literal notranslate"><span class=pre>patch</span></code>, <code class="docutils literal notranslate"><span class=pre>patch.object</span></code> and <code class="docutils literal notranslate"><span class=pre>patch.dict</span></code> can be used as
class decorators. When used in this way it is the same as applying the
decorator individually to every method whose name starts with "test".<p class="cyxy-trs-source cyxy-trs-target">作为替代补丁，patc.object 和 patc.dict 可以用作类装饰器。 当以这种方式使用时，它与将 decorator 单独应用于名称以“ test”开头的每个方法是一样的。</p>
</div>
<div class=section id=further-examples>
<span id=id1></span><h2 class=cyxy-trs-source>Further Examples<font class=cyxy-trs-target> 进一步的例子</font><a class=headerlink href=#further-examples title=永久链接至标题>¶</a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">Here are some more examples for some slightly more advanced scenarios.<p class="cyxy-trs-source cyxy-trs-target">下面是一些稍微高级一点的场景的更多示例。</p>
<div class=section id=mocking-chained-calls>
<h3 class=cyxy-trs-source>Mocking chained calls<font class=cyxy-trs-target> 嘲笑连锁呼叫</font><a class=headerlink href=#mocking-chained-calls title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mocking chained calls is actually straightforward with mock once you
understand the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> attribute. When a mock is called for
the first time, or you fetch its <code class="docutils literal notranslate"><span class=pre>return_value</span></code> before it has been called, a
new <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> is created.<p class="cyxy-trs-source cyxy-trs-target">一旦理解了 return value 属性，mock 链式调用实际上是直接的。 当第一次调用 Mock 时，或者在调用 Mock 之前获取其返回值时，将创建一个新的 Mock。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This means that you can see how the object returned from a call to a mocked
object has been used by interrogating the <code class="docutils literal notranslate"><span class=pre>return_value</span></code> mock:<p class="cyxy-trs-source cyxy-trs-target">这意味着您可以通过查询返回值 mock 来查看调用对象返回的对象是如何被使用的:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span><span class=o>.</span><span class=n>foo</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=go>&lt;Mock name='mock().foo()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>foo</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">From here it is a simple step to configure and then make assertions about
chained calls. Of course another alternative is writing your code in a more
testable way in the first place...<p class="cyxy-trs-source cyxy-trs-target">从这里开始，只需要执行一个简单的步骤，即可配置链接调用，然后进行断言。 当然，另一种选择是首先以一种更可测试的方式编写代码... ..。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">So, suppose we have some code that looks a little bit like this:<p class="cyxy-trs-source cyxy-trs-target">所以，假设我们有一些代码，看起来有点像这样:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>backend</span> <span class=o>=</span> <span class=n>BackendProvider</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>response</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>backend</span><span class=o>.</span><span class=n>get_endpoint</span><span class=p>(</span><span class=s1>'foobar'</span><span class=p>)</span><span class=o>.</span><span class=n>create_call</span><span class=p>(</span><span class=s1>'spam'</span><span class=p>,</span> <span class=s1>'eggs'</span><span class=p>)</span><span class=o>.</span><span class=n>start_call</span><span class=p>()</span>
<span class=gp>... </span>        <span class=c1># more code</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Assuming that <code class="docutils literal notranslate"><span class=pre>BackendProvider</span></code> is already well tested, how do we test
<code class="docutils literal notranslate"><span class=pre>method()</span></code>? Specifically, we want to test that the code section <code class="docutils literal notranslate"><span class=pre>#</span> <span class=pre>more</span>
<span class=pre>code</span></code> uses the response object in the correct way.<p class="cyxy-trs-source cyxy-trs-target">假设 BackendProvider 已经进行了很好的测试，那么我们如何测试方法()呢？ 具体来说，我们希望测试代码部分 # more 代码是否正确地使用了响应对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">As this chain of calls is made from an instance attribute we can monkey patch
the <code class="docutils literal notranslate"><span class=pre>backend</span></code> attribute on a <code class="docutils literal notranslate"><span class=pre>Something</span></code> instance. In this particular case
we are only interested in the return value from the final call to
<code class="docutils literal notranslate"><span class=pre>start_call</span></code> so we don't have much configuration to do. Let's assume the
object it returns is 'file-like', so we'll ensure that our response object
uses the builtin <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> as its <code class="docutils literal notranslate"><span class=pre>spec</span></code>.<p class="cyxy-trs-source cyxy-trs-target">由于这个调用链是从实例属性进行的，因此我们可以对 Something 实例的后端属性进行 monkey patch。 在这种特殊情况下，我们只对最终调用 start 调用的返回值感兴趣，所以我们没有太多的配置要做。 让我们假设它返回的对象是“类似于文件”的，因此我们将确保响应对象使用内建的 open ()作为其规范。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">To do this we create a mock instance as our mock backend and create a mock
response object for it. To set the response as the return value for that final
<code class="docutils literal notranslate"><span class=pre>start_call</span></code> we could do this:<p class="cyxy-trs-source cyxy-trs-target">为此，我们创建一个 mock 实例作为我们的 mock 后端，并为它创建一个 mock 响应对象。 为了将响应设置为最终开始调用的返回值，我们可以这样做:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>mock_backend</span><span class=o>.</span><span class=n>get_endpoint</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>create_call</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>start_call</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=n>mock_response</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">We can do that in a slightly nicer way using the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a>
method to directly set the return value for us:<p class="cyxy-trs-source cyxy-trs-target">我们可以使用 configure mock ()方法以更好的方式直接为我们设置返回值:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>something</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_response</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=nb>open</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_backend</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>config</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'get_endpoint.return_value.create_call.return_value.start_call.return_value'</span><span class=p>:</span> <span class=n>mock_response</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_backend</span><span class=o>.</span><span class=n>configure_mock</span><span class=p>(</span><span class=o>**</span><span class=n>config</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">With these we monkey patch the "mock backend" in place and can make the real
call:<p class="cyxy-trs-source cyxy-trs-target">有了这些，我们就可以将“模拟后端”安装到位，并发出真正的呼叫:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>something</span><span class=o>.</span><span class=n>backend</span> <span class=o>=</span> <span class=n>mock_backend</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>something</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> we can check the chained call with a single
assert. A chained call is several calls in one line of code, so there will be
several entries in <code class="docutils literal notranslate"><span class=pre>mock_calls</span></code>. We can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.call.call_list title=unittest.mock.call.call_list><code class="xref py py-meth docutils literal notranslate"><span class=pre>call.call_list()</span></code></a> to create
this list of calls for us:<p class="cyxy-trs-source cyxy-trs-target">使用 mock 调用，我们可以用一个断言检查链式调用。 链式调用是一行代码中的多个调用，因此在模拟调用中会有多个条目。 我们可以使用 call.call list ()为我们创建这个调用列表:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>chained</span> <span class=o>=</span> <span class=n>call</span><span class=o>.</span><span class=n>get_endpoint</span><span class=p>(</span><span class=s1>'foobar'</span><span class=p>)</span><span class=o>.</span><span class=n>create_call</span><span class=p>(</span><span class=s1>'spam'</span><span class=p>,</span> <span class=s1>'eggs'</span><span class=p>)</span><span class=o>.</span><span class=n>start_call</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>call_list</span> <span class=o>=</span> <span class=n>chained</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>mock_backend</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>call_list</span>
</pre></div>
</div>
</div>
<div class=section id=partial-mocking>
<h3 class=cyxy-trs-source>Partial mocking<font class=cyxy-trs-target> 部分嘲笑</font><a class=headerlink href=#partial-mocking title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">In some tests I wanted to mock out a call to <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/datetime.html#datetime.date.today title=datetime.date.today><code class="xref py py-meth docutils literal notranslate"><span class=pre>datetime.date.today()</span></code></a>
to return a known date, but I didn't want to prevent the code under test from
creating new date objects. Unfortunately <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/datetime.html#datetime.date title=datetime.date><code class="xref py py-class docutils literal notranslate"><span class=pre>datetime.date</span></code></a> is written in C, and
so I couldn't just monkey-patch out the static <code class="xref py py-meth docutils literal notranslate"><span class=pre>date.today()</span></code> method.<p class="cyxy-trs-source cyxy-trs-target">在一些测试中，我想模拟一个调用 datetime.date.today ()来返回一个已知的日期，但是我不想阻止测试中的代码创建新的日期对象。 不幸的是，datetime.date 是用 c 编写的，所以我不能仅仅使用 monkey-patch 方法来补丁 static date.today ()方法。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">I found a simple way of doing this that involved effectively wrapping the date
class with a mock, but passing through calls to the constructor to the real
class (and returning real instances).<p class="cyxy-trs-source cyxy-trs-target">我找到了一种简单的方法来实现这一点，这种方法包括用 mock 有效地包装日期类，同时通过对构造函数的调用传递到真正的类(并返回真实的实例)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch</span> <span class=pre>decorator</span></code></a> is used here to
mock out the <code class="docutils literal notranslate"><span class=pre>date</span></code> class in the module under test. The <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code>
attribute on the mock date class is then set to a lambda function that returns
a real date. When the mock date class is called a real date will be
constructed and returned by <code class="docutils literal notranslate"><span class=pre>side_effect</span></code>.<p class="cyxy-trs-source cyxy-trs-target">这里使用修补程序装饰器模拟测试模块中的日期类。 然后将 mock date 类的 side effect 属性设置为一个 lambda 函数，该函数返回一个真实的日期。 当调用模拟日期类时，将构造一个真实的日期，并由副作用返回。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>datetime</span> <span class=kn>import</span> <span class=n>date</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.date'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_date</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>mock_date</span><span class=o>.</span><span class=n>today</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=n>date</span><span class=p>(</span><span class=mi>2010</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>mock_date</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=k>lambda</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>:</span> <span class=n>date</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kw</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>date</span><span class=o>.</span><span class=n>today</span><span class=p>()</span> <span class=o>==</span> <span class=n>date</span><span class=p>(</span><span class=mi>2010</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>date</span><span class=p>(</span><span class=mi>2009</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span> <span class=o>==</span> <span class=n>date</span><span class=p>(</span><span class=mi>2009</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Note that we don't patch <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/datetime.html#datetime.date title=datetime.date><code class="xref py py-class docutils literal notranslate"><span class=pre>datetime.date</span></code></a> globally, we patch <code class="docutils literal notranslate"><span class=pre>date</span></code> in the
module that <em>uses</em> it. See <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#where-to-patch><span class="std std-ref">where to patch</span></a>.<p class="cyxy-trs-source cyxy-trs-target">注意，我们没有全局地对 datetime.date 进行补丁，而是在使用它的模块中对 date 进行补丁。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">When <code class="docutils literal notranslate"><span class=pre>date.today()</span></code> is called a known date is returned, but calls to the
<code class="docutils literal notranslate"><span class=pre>date(...)</span></code> constructor still return normal dates. Without this you can find
yourself having to calculate an expected result using exactly the same
algorithm as the code under test, which is a classic testing anti-pattern.<p class="cyxy-trs-source cyxy-trs-target">当 date.today ()被调用时，返回一个已知的日期，但是调用 date (...)构造函数仍然返回正常的日期。 如果不这样做，您就会发现自己必须使用与被测试代码完全相同的算法来计算预期的结果，这是一个典型的测试反模式。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Calls to the date constructor are recorded in the <code class="docutils literal notranslate"><span class=pre>mock_date</span></code> attributes
(<code class="docutils literal notranslate"><span class=pre>call_count</span></code> and friends) which may also be useful for your tests.<p class="cyxy-trs-source cyxy-trs-target">对日期构造函数的调用记录在模拟日期属性(调用计数和朋友)中，这对您的测试也很有用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">An alternative way of dealing with mocking dates, or other builtin classes,
is discussed in <a class="reference external" href=https://williambert.online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/>this blog entry</a>.<p class="cyxy-trs-source cyxy-trs-target">另一种处理 mocking date 或其他内建类的方法将在本博客中讨论。</p>
</div>
<div class=section id=mocking-a-generator-method>
<h3 class=cyxy-trs-source>Mocking a Generator Method<font class=cyxy-trs-target> 模仿生成器方法</font><a class=headerlink href=#mocking-a-generator-method title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">A Python generator is a function or method that uses the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/simple_stmts.html#yield><code class="xref std std-keyword docutils literal notranslate"><span class=pre>yield</span></code></a> statement
to return a series of values when iterated over <a class="footnote-reference brackets" href=#id3 id=id2>1</a>.<p class="cyxy-trs-source cyxy-trs-target">Python 生成器是一个函数或方法，它使用 yield 语句在遍历1时返回一系列值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">A generator method / function is called to return the generator object. It is
the generator object that is then iterated over. The protocol method for
iteration is <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/stdtypes.html#container.__iter__ title=container.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a>, so we can
mock this using a <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">调用生成器方法 / 函数返回生成器对象。 然后迭代的是生成器对象。 迭代的协议方法是 iter () ，所以我们可以使用 MagicMock 来模拟它。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Here's an example class with an "iter" method implemented as a generator:<p class="cyxy-trs-source cyxy-trs-target">下面是一个用“ iter”方法实现生成器的例子:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>iter</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]:</span>
<span class=gp>... </span>            <span class=k>yield</span> <span class=n>i</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>foo</span><span class=o>.</span><span class=n>iter</span><span class=p>())</span>
<span class=go>[1, 2, 3]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">How would we mock this class, and in particular its "iter" method?<p class="cyxy-trs-source cyxy-trs-target">我们将如何嘲笑这个类，特别是它的“ iter”方法？</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">To configure the values returned from the iteration (implicit in the call to
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/stdtypes.html#list title=list><code class="xref py py-class docutils literal notranslate"><span class=pre>list</span></code></a>), we need to configure the object returned by the call to <code class="docutils literal notranslate"><span class=pre>foo.iter()</span></code>.<p class="cyxy-trs-source cyxy-trs-target">要配置迭代返回的值(在对 list 的调用中隐含) ，我们需要配置对 foo.iter ()的调用返回的对象。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span><span class=o>.</span><span class=n>iter</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=nb>iter</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock_foo</span><span class=o>.</span><span class=n>iter</span><span class=p>())</span>
<span class=go>[1, 2, 3]</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class=label id=id3><span class=brackets><a class=fn-backref href=#id2>1</a></span></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">There are also generator expressions and more <a class="reference external" href=http://www.dabeaz.com/coroutines/index.html>advanced uses</a> of generators, but we aren't
concerned about them here. A very good introduction to generators and how
powerful they are is: <a class="reference external" href=http://www.dabeaz.com/generators/>Generator Tricks for Systems Programmers</a>.<p class="cyxy-trs-source cyxy-trs-target">还有生成器表达式和生成器的更高级用法，但我们在这里不关心它们。 关于生成器及其功能的一个很好的介绍是: 系统程序员的生成器技巧。</p>
</dd>
</dl>
</div>
<div class=section id=applying-the-same-patch-to-every-test-method>
<h3 class=cyxy-trs-source>Applying the same patch to every test method<font class=cyxy-trs-target> 对每个测试方法应用相同的补丁</font><a class=headerlink href=#applying-the-same-patch-to-every-test-method title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want several patches in place for multiple test methods the obvious way
is to apply the patch decorators to every method. This can feel like unnecessary
repetition. For Python 2.6 or more recent you can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> (in all its
various forms) as a class decorator. This applies the patches to all test
methods on the class. A test method is identified by methods whose names start
with <code class="docutils literal notranslate"><span class=pre>test</span></code>:<p class="cyxy-trs-source cyxy-trs-target">如果您希望为多个测试方法安装多个补丁，显而易见的方法是将补丁修饰符应用于每个方法。 这感觉像是不必要的重复。 对于 Python 2.6或更新的版本，您可以使用 patch ()(以各种形式)作为类装饰器。 这将补丁应用于类上的所有测试方法。 一个测试方法是通过以 test 开头的方法来识别的:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'mymodule.SomeClass'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_one</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>MockSomeClass</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertIs</span><span class=p>(</span><span class=n>mymodule</span><span class=o>.</span><span class=n>SomeClass</span><span class=p>,</span> <span class=n>MockSomeClass</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_two</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>MockSomeClass</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertIs</span><span class=p>(</span><span class=n>mymodule</span><span class=o>.</span><span class=n>SomeClass</span><span class=p>,</span> <span class=n>MockSomeClass</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>not_a_test</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=s1>'something'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_one'</span><span class=p>)</span><span class=o>.</span><span class=n>test_one</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_two'</span><span class=p>)</span><span class=o>.</span><span class=n>test_two</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_two'</span><span class=p>)</span><span class=o>.</span><span class=n>not_a_test</span><span class=p>()</span>
<span class=go>'something'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">An alternative way of managing patches is to use the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#start-and-stop><span class="std std-ref">patch methods: start and stop</span></a>.
These allow you to move the patching into your <code class="docutils literal notranslate"><span class=pre>setUp</span></code> and <code class="docutils literal notranslate"><span class=pre>tearDown</span></code> methods.<p class="cyxy-trs-source cyxy-trs-target">管理补丁的另一种方法是使用补丁方法: 启动和停止。 这些允许您将修补程序移动到您的 setUp 和 tearDown 方法中。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.foo'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>mock_foo</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertIs</span><span class=p>(</span><span class=n>mymodule</span><span class=o>.</span><span class=n>foo</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>mock_foo</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>tearDown</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_foo'</span><span class=p>)</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you use this technique you must ensure that the patching is "undone" by
calling <code class="docutils literal notranslate"><span class=pre>stop</span></code>. This can be fiddlier than you might think, because if an
exception is raised in the setUp then tearDown is not called.
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.html#unittest.TestCase.addCleanup title=unittest.TestCase.addCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>unittest.TestCase.addCleanup()</span></code></a> makes this easier:<p class="cyxy-trs-source cyxy-trs-target">如果使用此技术，则必须通过调用 stop 来确保补丁是“撤消”的。 这可能比您想象的要难，因为如果在安装中引发了异常，那么就不会调用 tearDown。 单位试验。 Addcleanup ()让这个变得更简单:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.foo'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>addCleanup</span><span class=p>(</span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>mock_foo</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertIs</span><span class=p>(</span><span class=n>mymodule</span><span class=o>.</span><span class=n>foo</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>mock_foo</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_foo'</span><span class=p>)</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</pre></div>
</div>
</div>
<div class=section id=mocking-unbound-methods>
<h3 class=cyxy-trs-source>Mocking Unbound Methods<font class=cyxy-trs-target> 嘲笑未绑定方法</font><a class=headerlink href=#mocking-unbound-methods title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Whilst writing tests today I needed to patch an <em>unbound method</em> (patching the
method on the class rather than on the instance). I needed self to be passed
in as the first argument because I want to make asserts about which objects
were calling this particular method. The issue is that you can't patch with a
mock for this, because if you replace an unbound method with a mock it doesn't
become a bound method when fetched from the instance, and so it doesn't get
self passed in. The workaround is to patch the unbound method with a real
function instead. The <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorator makes it so simple to
patch out methods with a mock that having to create a real function becomes a
nuisance.<p class="cyxy-trs-source cyxy-trs-target">在今天编写测试时，我需要修补一个未绑定的方法(在类上而不是在实例上修补该方法)。 我需要把 self 作为第一个参数传入，因为我想断言哪个对象调用了这个特定的方法。 问题在于你不能为此修补 mock，因为如果你用 mock 替换一个未绑定的方法，它在从实例中获取时不会成为绑定的方法，所以它不会被 self 传入。 解决方法是用一个真正的函数来修补未绑定方法。 Patch () decorator 使用 mock 修补方法变得非常简单，以至于不得不创建一个真正的函数变得很麻烦。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you pass <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> to patch then it does the patching with a
<em>real</em> function object. This function object has the same signature as the one
it is replacing, but delegates to a mock under the hood. You still get your
mock auto-created in exactly the same way as before. What it means though, is
that if you use it to patch out an unbound method on a class the mocked
function will be turned into a bound method if it is fetched from an instance.
It will have <code class="docutils literal notranslate"><span class=pre>self</span></code> passed in as the first argument, which is exactly what I
wanted:<p class="cyxy-trs-source cyxy-trs-target">如果你传递 autospec True 到 patch，那么它会用一个真正的函数对象进行修补。 这个函数对象具有与它正在替换的函数对象相同的签名，但是委托给引擎盖下的 mock。 您仍然可以使用与以前完全相同的方式自动创建 mock。 但是，它的意思是，如果您使用它来修补类上的未绑定方法，那么如果从实例中获取了嘲讽函数，那么它将转换为绑定方法。 它会自动作为第一个参数传入，这正是我想要的:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>:</span>
<span class=gp>... </span>  <span class=k>def</span> <span class=nf>foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>Foo</span><span class=p>,</span> <span class=s1>'foo'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_foo</span><span class=p>:</span>
<span class=gp>... </span>  <span class=n>mock_foo</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'foo'</span>
<span class=gp>... </span>  <span class=n>foo</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>foo</span><span class=o>.</span><span class=n>foo</span><span class=p>()</span>
<span class=gp>...</span>
<span class=go>'foo'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=n>foo</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If we don't use <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> then the unbound method is patched out
with a Mock instance instead, and isn't called with <code class="docutils literal notranslate"><span class=pre>self</span></code>.<p class="cyxy-trs-source cyxy-trs-target">如果我们不使用 autospec True，那么未绑定的方法将被一个 Mock 实例替代，而不是用 self 调用。</p>
</div>
<div class=section id=checking-multiple-calls-with-mock>
<h3 class=cyxy-trs-source>Checking multiple calls with mock<font class=cyxy-trs-target> 使用 mock 检查多个调用</font><a class=headerlink href=#checking-multiple-calls-with-mock title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">mock has a nice API for making assertions about how your mock objects are used.<p class="cyxy-trs-source cyxy-trs-target">Mock 提供了一个很好的 API，可以断言使用模拟对象的方式。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>foo_bar</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>foo_bar</span><span class=p>(</span><span class=s1>'baz'</span><span class=p>,</span> <span class=n>spam</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>foo_bar</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=s1>'baz'</span><span class=p>,</span> <span class=n>spam</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If your mock is only being called once you can use the
<code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code> method that also asserts that the
<code class="xref py py-attr docutils literal notranslate"><span class=pre>call_count</span></code> is one.<p class="cyxy-trs-source cyxy-trs-target">如果只调用 mock 一次，则可以使用 assert 与()方法一起调用一次，该方法也断言调用计数为1。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>foo_bar</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'baz'</span><span class=p>,</span> <span class=n>spam</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>foo_bar</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>foo_bar</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'baz'</span><span class=p>,</span> <span class=n>spam</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected to be called once. Called 2 times.</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Both <code class="docutils literal notranslate"><span class=pre>assert_called_with</span></code> and <code class="docutils literal notranslate"><span class=pre>assert_called_once_with</span></code> make assertions about
the <em>most recent</em> call. If your mock is going to be called several times, and
you want to make assertions about <em>all</em> those calls you can use
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">Assert 调用 with，assert 调用 once，并对最近的调用进行断言。 如果 mock 将被调用多次，并且希望对所有这些调用做出断言，那么可以使用 call args list:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args_list</span>
<span class=go>[call(1, 2, 3), call(4, 5, 6), call()]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> helper makes it easy to make assertions about these calls. You
can build up a list of expected calls and compare it to <code class="docutils literal notranslate"><span class=pre>call_args_list</span></code>. This
looks remarkably similar to the repr of the <code class="docutils literal notranslate"><span class=pre>call_args_list</span></code>:<p class="cyxy-trs-source cyxy-trs-target">调用助手使得对这些调用进行断言变得很容易。 您可以建立一个预期调用的列表，并将其与调用 args 列表进行比较。 这看起来与调用 args 列表的 repr 非常相似:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>),</span> <span class=n>call</span><span class=p>()]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args_list</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
<div class=section id=coping-with-mutable-arguments>
<h3 class=cyxy-trs-source>Coping with mutable arguments<font class=cyxy-trs-target> 处理易变的争论</font><a class=headerlink href=#coping-with-mutable-arguments title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Another situation is rare, but can bite you, is when your mock is called with
mutable arguments. <code class="docutils literal notranslate"><span class=pre>call_args</span></code> and <code class="docutils literal notranslate"><span class=pre>call_args_list</span></code> store <em>references</em> to the
arguments. If the arguments are mutated by the code under test then you can no
longer make assertions about what the values were when the mock was called.<p class="cyxy-trs-source cyxy-trs-target">另一种情况是，当您的 mock 被可变参数调用时，这种情况很少发生，但可能会对您不利。 调用 args 并调用 args list store 对参数的引用。 如果参数被测试代码变异，那么您就不能再断言 mock 被调用时值是什么。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Here's some example code that shows the problem. Imagine the following functions
defined in 'mymodule':<p class="cyxy-trs-source cyxy-trs-target">这里有一些示例代码来说明这个问题，想象一下在 mymodule 中定义的如下函数:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>frob</span><span class=p>(</span><span class=n>val</span><span class=p>):</span>
    <span class=k>pass</span>

<span class=k>def</span> <span class=nf>grob</span><span class=p>(</span><span class=n>val</span><span class=p>):</span>
    <span class=s2>"First frob and then clear val"</span>
    <span class=n>frob</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
    <span class=n>val</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">When we try to test that <code class="docutils literal notranslate"><span class=pre>grob</span></code> calls <code class="docutils literal notranslate"><span class=pre>frob</span></code> with the correct argument look
what happens:<p class="cyxy-trs-source cyxy-trs-target">当我们尝试用正确的参数来测试 grob 调用 frob 时，看看会发生什么:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.frob'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_frob</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>val</span> <span class=o>=</span> <span class=p>{</span><span class=mi>6</span><span class=p>}</span>
<span class=gp>... </span>    <span class=n>mymodule</span><span class=o>.</span><span class=n>grob</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>val</span>
<span class=go>set()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_frob</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>({</span><span class=mi>6</span><span class=p>})</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected: (({6},), {})</span>
<span class=go>Called with: ((set(),), {})</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">One possibility would be for mock to copy the arguments you pass in. This
could then cause problems if you do assertions that rely on object identity
for equality.<p class="cyxy-trs-source cyxy-trs-target">一种可能性是 mock 复制您传入的参数。 如果您使用依赖于对象标识的相等性的断言，那么这可能会导致问题。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Here's one solution that uses the <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code>
functionality. If you provide a <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> function for a mock then
<code class="docutils literal notranslate"><span class=pre>side_effect</span></code> will be called with the same args as the mock. This gives us an
opportunity to copy the arguments and store them for later assertions. In this
example I'm using <em>another</em> mock to store the arguments so that I can use the
mock methods for doing the assertion. Again a helper function sets this up for
me.<p class="cyxy-trs-source cyxy-trs-target">这里有一个使用副作用功能的解决方案。 如果您为 mock 提供了一个副作用函数，那么将使用与 mock 相同的 args 调用副作用。 这使我们有机会复制这些参数，并将它们存储在以后的断言中。 在这个示例中，我使用另一个 mock 来存储参数，这样我就可以使用 mock 方法来执行断言。 同样，一个辅助函数为我设置了这个。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>copy</span> <span class=kn>import</span> <span class=n>deepcopy</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>Mock</span><span class=p>,</span> <span class=n>patch</span><span class=p>,</span> <span class=n>DEFAULT</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>copy_call_args</span><span class=p>(</span><span class=n>mock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>new_mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>args</span> <span class=o>=</span> <span class=n>deepcopy</span><span class=p>(</span><span class=n>args</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>kwargs</span> <span class=o>=</span> <span class=n>deepcopy</span><span class=p>(</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>new_mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=n>DEFAULT</span>
<span class=gp>... </span>    <span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>new_mock</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.frob'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_frob</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>new_mock</span> <span class=o>=</span> <span class=n>copy_call_args</span><span class=p>(</span><span class=n>mock_frob</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>val</span> <span class=o>=</span> <span class=p>{</span><span class=mi>6</span><span class=p>}</span>
<span class=gp>... </span>    <span class=n>mymodule</span><span class=o>.</span><span class=n>grob</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>new_mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>({</span><span class=mi>6</span><span class=p>})</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>new_mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call({6})</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>copy_call_args</span></code> is called with the mock that will be called. It returns a new
mock that we do the assertion on. The <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> function makes a copy of
the args and calls our <code class="docutils literal notranslate"><span class=pre>new_mock</span></code> with the copy.<p class="cyxy-trs-source cyxy-trs-target">拷贝调用 args 被调用，使用将被调用的 mock。 它返回一个新的 mock，我们在其上执行断言。 副作用函数创建 args 的副本，并用副本调用我们的新 mock。</p>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If your mock is only going to be used once there is an easier way of
checking arguments at the point they are called. You can simply do the
checking inside a <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> function.<p class="cyxy-trs-source cyxy-trs-target">如果 mock 只用一次，那么有一种更简单的方法可以在调用它们的时候检查参数。 您可以简单地在副作用函数内部进行检查。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=n>arg</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>arg</span> <span class=o>==</span> <span class=p>{</span><span class=mi>6</span><span class=p>}</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>side_effect</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>({</span><span class=mi>6</span><span class=p>})</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=nb>set</span><span class=p>())</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AssertionError</span>
</pre></div>
</div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">An alternative approach is to create a subclass of <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> or
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> that copies (using <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/copy.html#copy.deepcopy title=copy.deepcopy><code class="xref py py-func docutils literal notranslate"><span class=pre>copy.deepcopy()</span></code></a>) the arguments.
Here's an example implementation:<p class="cyxy-trs-source cyxy-trs-target">另一种方法是创建 Mock 或 MagicMock 的子类，用于复制(使用 copy.deepcopy ())参数。 下面是一个实现的例子:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>copy</span> <span class=kn>import</span> <span class=n>deepcopy</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>CopyingMock</span><span class=p>(</span><span class=n>MagicMock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__call__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>/</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>args</span> <span class=o>=</span> <span class=n>deepcopy</span><span class=p>(</span><span class=n>args</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>kwargs</span> <span class=o>=</span> <span class=n>deepcopy</span><span class=p>(</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>super</span><span class=p>(</span><span class=n>CopyingMock</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__call__</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>c</span> <span class=o>=</span> <span class=n>CopyingMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>arg</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>c</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>arg</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>c</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=nb>set</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>c</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected call: mock({1})</span>
<span class=go>Actual call: mock(set())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>c</span><span class=o>.</span><span class=n>foo</span>
<span class=go>&lt;CopyingMock name='mock.foo' id='...'&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">When you subclass <code class="docutils literal notranslate"><span class=pre>Mock</span></code> or <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> all dynamically created attributes,
and the <code class="docutils literal notranslate"><span class=pre>return_value</span></code> will use your subclass automatically. That means all
children of a <code class="docutils literal notranslate"><span class=pre>CopyingMock</span></code> will also have the type <code class="docutils literal notranslate"><span class=pre>CopyingMock</span></code>.<p class="cyxy-trs-source cyxy-trs-target">当您子类 Mock 或 MagicMock 所有动态创建的属性时，返回值将自动使用您的子类。 这意味着 CopyingMock 的所有子类型也将具有 CopyingMock 类型。</p>
</div>
<div class=section id=nesting-patches>
<h3 class=cyxy-trs-source>Nesting Patches<font class=cyxy-trs-target> 嵌套斑块</font><a class=headerlink href=#nesting-patches title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using patch as a context manager is nice, but if you do multiple patches you
can end up with nested with statements indenting further and further to the
right:<p class="cyxy-trs-source cyxy-trs-target">使用 patch 作为上下文管理器是很好的，但是如果你使用多个补丁，你可能会得到嵌套的语句缩进的越来越远的右边:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.Foo'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_foo</span><span class=p>:</span>
<span class=gp>... </span>            <span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.Bar'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_bar</span><span class=p>:</span>
<span class=gp>... </span>                <span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.Spam'</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_spam</span><span class=p>:</span>
<span class=gp>... </span>                    <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Foo</span> <span class=ow>is</span> <span class=n>mock_foo</span>
<span class=gp>... </span>                    <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Bar</span> <span class=ow>is</span> <span class=n>mock_bar</span>
<span class=gp>... </span>                    <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Spam</span> <span class=ow>is</span> <span class=n>mock_spam</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Foo</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_foo'</span><span class=p>)</span><span class=o>.</span><span class=n>test_foo</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Foo</span> <span class=ow>is</span> <span class=n>original</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">With unittest <code class="docutils literal notranslate"><span class=pre>cleanup</span></code> functions and the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#start-and-stop><span class="std std-ref">patch methods: start and stop</span></a> we can
achieve the same effect without the nested indentation. A simple helper
method, <code class="docutils literal notranslate"><span class=pre>create_patch</span></code>, puts the patch in place and returns the created mock
for us:<p class="cyxy-trs-source cyxy-trs-target">使用 unittest 清除函数和补丁方法: start 和 stop，我们可以在没有嵌套缩进的情况下达到同样的效果。 一个简单的帮助方法---- create patch---- 将补丁放在适当的位置，并返回已创建的 mock:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>create_patch</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>thing</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>addCleanup</span><span class=p>(</span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=n>thing</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>mock_foo</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>create_patch</span><span class=p>(</span><span class=s1>'mymodule.Foo'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>mock_bar</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>create_patch</span><span class=p>(</span><span class=s1>'mymodule.Bar'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>mock_spam</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>create_patch</span><span class=p>(</span><span class=s1>'mymodule.Spam'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Foo</span> <span class=ow>is</span> <span class=n>mock_foo</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Bar</span> <span class=ow>is</span> <span class=n>mock_bar</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Spam</span> <span class=ow>is</span> <span class=n>mock_spam</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Foo</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_foo'</span><span class=p>)</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>mymodule</span><span class=o>.</span><span class=n>Foo</span> <span class=ow>is</span> <span class=n>original</span>
</pre></div>
</div>
</div>
<div class=section id=mocking-a-dictionary-with-magicmock>
<h3 class=cyxy-trs-source>Mocking a dictionary with MagicMock<font class=cyxy-trs-target> 用 MagicMock 嘲笑一本字典</font><a class=headerlink href=#mocking-a-dictionary-with-magicmock title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">You may want to mock a dictionary, or other container object, recording all
access to it whilst having it still behave like a dictionary.<p class="cyxy-trs-source cyxy-trs-target">您可能希望模拟一个字典或其他容器对象，记录对它的所有访问，同时让它仍然像一个字典那样工作。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">We can do this with <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>, which will behave like a dictionary,
and using <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-data docutils literal notranslate"><span class=pre>side_effect</span></code></a> to delegate dictionary access to a real
underlying dictionary that is under our control.<p class="cyxy-trs-source cyxy-trs-target">我们可以使用 MagicMock 实现这一点，它的行为类似于字典，并使用副作用将字典访问权委托给我们控制下的真正的底层字典。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">When the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__getitem__ title=object.__getitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__getitem__()</span></code></a> and <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__setitem__ title=object.__setitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__setitem__()</span></code></a> methods of our <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> are called
(normal dictionary access) then <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> is called with the key (and in
the case of <code class="docutils literal notranslate"><span class=pre>__setitem__</span></code> the value too). We can also control what is returned.<p class="cyxy-trs-source cyxy-trs-target">当我们的 MagicMock 的 getitem ()和 setitem ()方法被调用时(普通的字典访问) ，那么使用键调用副作用(在 setitem 的情况下也调用值)。 我们还可以控制返回的内容。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">After the <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> has been used we can use attributes like
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-data docutils literal notranslate"><span class=pre>call_args_list</span></code></a> to assert about how the dictionary was used:<p class="cyxy-trs-source cyxy-trs-target">使用 MagicMock 之后，我们可以使用诸如 call args list 之类的属性来断言 dictionary 是如何使用的:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>my_dict</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'a'</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>getitem</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>     <span class=k>return</span> <span class=n>my_dict</span><span class=p>[</span><span class=n>name</span><span class=p>]</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>setitem</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>my_dict</span><span class=p>[</span><span class=n>name</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__getitem__</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>getitem</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__setitem__</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>setitem</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">An alternative to using <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> is to use <code class="docutils literal notranslate"><span class=pre>Mock</span></code> and <em>only</em> provide
the magic methods you specifically want:<p class="cyxy-trs-source cyxy-trs-target">使用 MagicMock 的另一个选择是使用 Mock，并且只提供您特别需要的魔法方法:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__getitem__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>getitem</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__setitem__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>setitem</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A <em>third</em> option is to use <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> but passing in <code class="docutils literal notranslate"><span class=pre>dict</span></code> as the <em>spec</em>
(or <em>spec_set</em>) argument so that the <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> created only has
dictionary magic methods available:<p class="cyxy-trs-source cyxy-trs-target">第三种选择是使用 MagicMock，但传入 dict 作为 spec (或 spec set)参数，这样创建的 MagicMock 只有 dictionary magic 方法可用:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>spec_set</span><span class=o>=</span><span class=nb>dict</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__getitem__</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>getitem</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__setitem__</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>setitem</span>
</pre></div>
</div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">With these side effect functions in place, the <code class="docutils literal notranslate"><span class=pre>mock</span></code> will behave like a normal
dictionary but recording the access. It even raises a <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#KeyError title=KeyError><code class="xref py py-exc docutils literal notranslate"><span class=pre>KeyError</span></code></a> if you try
to access a key that doesn't exist.<p class="cyxy-trs-source cyxy-trs-target">有了这些副作用函数，mock 的行为就像一个普通的字典，但是会记录访问。 如果您尝试访问不存在的密钥，甚至会引发 KeyError 错误。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'a'</span><span class=p>]</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'c'</span><span class=p>]</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'d'</span><span class=p>]</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>KeyError</span><span>: </span><span class=n>'d'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'b'</span><span class=p>]</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'d'</span><span class=p>]</span> <span class=o>=</span> <span class=s1>'eggs'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'b'</span><span class=p>]</span>
<span class=go>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=s1>'d'</span><span class=p>]</span>
<span class=go>'eggs'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">After it has been used you can make assertions about the access using the normal
mock methods and attributes:<p class="cyxy-trs-source cyxy-trs-target">在它被使用之后，你可以使用正常的 mock 方法和属性来做关于访问的断言:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__getitem__</span><span class=o>.</span><span class=n>call_args_list</span>
<span class=go>[call('a'), call('c'), call('d'), call('b'), call('d')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__setitem__</span><span class=o>.</span><span class=n>call_args_list</span>
<span class=go>[call('b', 'fish'), call('d', 'eggs')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>my_dict</span>
<span class=go>{'a': 1, 'b': 'fish', 'c': 3, 'd': 'eggs'}</span>
</pre></div>
</div>
</div>
<div class=section id=mock-subclasses-and-their-attributes>
<h3 class=cyxy-trs-source>Mock subclasses and their attributes<font class=cyxy-trs-target> 模拟子类及其属性</font><a class=headerlink href=#mock-subclasses-and-their-attributes title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">There are various reasons why you might want to subclass <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>. One
reason might be to add helper methods. Here's a silly example:<p class="cyxy-trs-source cyxy-trs-target">您可能希望子类 Mock 的原因有很多。 原因之一可能是添加助手方法。 这里有一个愚蠢的例子:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyMock</span><span class=p>(</span><span class=n>MagicMock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>has_been_called</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>called</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span> <span class=o>=</span> <span class=n>MyMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span>
<span class=go>&lt;MyMock id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>has_been_called</span><span class=p>()</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>has_been_called</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The standard behaviour for <code class="docutils literal notranslate"><span class=pre>Mock</span></code> instances is that attributes and the return
value mocks are of the same type as the mock they are accessed on. This ensures
that <code class="docutils literal notranslate"><span class=pre>Mock</span></code> attributes are <code class="docutils literal notranslate"><span class=pre>Mocks</span></code> and <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> attributes are <code class="docutils literal notranslate"><span class=pre>MagicMocks</span></code>
<a class="footnote-reference brackets" href=#id5 id=id4>2</a>. So if you're subclassing to add helper methods then they'll also be
available on the attributes and return value mock of instances of your
subclass.<p class="cyxy-trs-source cyxy-trs-target">Mock 实例的标准行为是，属性和返回值 Mock 与在其上访问的 Mock 具有相同的类型。 这确保了 Mock 属性是 Mocks，而 MagicMock 属性是 MagicMocks 2。 因此，如果您要子类化添加 helper 方法，那么它们也可用于子类的属性和实例的返回值 mock。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>foo</span>
<span class=go>&lt;MyMock name='mock.foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>foo</span><span class=o>.</span><span class=n>has_been_called</span><span class=p>()</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>foo</span><span class=p>()</span>
<span class=go>&lt;MyMock name='mock.foo()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>foo</span><span class=o>.</span><span class=n>has_been_called</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes this is inconvenient. For example, <a class="reference external" href=https://code.google.com/archive/p/mock/issues/105>one user</a> is subclassing mock to
created a <a class="reference external" href=https://twistedmatrix.com/documents/11.0.0/api/twisted.python.components.html>Twisted adaptor</a>.
Having this applied to attributes too actually causes errors.<p class="cyxy-trs-source cyxy-trs-target">有时候这是不方便的。 例如，一个用户将 mock 子类化以创建 Twisted 适配器。 将其应用于属性实际上会导致错误。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>Mock</span></code> (in all its flavours) uses a method called <code class="docutils literal notranslate"><span class=pre>_get_child_mock</span></code> to create
these "sub-mocks" for attributes and return values. You can prevent your
subclass being used for attributes by overriding this method. The signature is
that it takes arbitrary keyword arguments (<code class="docutils literal notranslate"><span class=pre>**kwargs</span></code>) which are then passed
onto the mock constructor:<p class="cyxy-trs-source cyxy-trs-target">Mock (各种风格)使用一个名为 getchild Mock 的方法为属性和返回值创建这些“ sub- Mock”。 通过重写此方法，可以防止将子类用于属性。 签名是它接受任意的关键字参数(* * kwargs) ，然后这些参数被传递到模拟构造函数:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Subclass</span><span class=p>(</span><span class=n>MagicMock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>_get_child_mock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>/</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=n>MagicMock</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span> <span class=o>=</span> <span class=n>Subclass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymock</span><span class=o>.</span><span class=n>foo</span>
<span class=go>&lt;MagicMock name='mock.foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>mymock</span><span class=p>,</span> <span class=n>Subclass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>mymock</span><span class=o>.</span><span class=n>foo</span><span class=p>,</span> <span class=n>Subclass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>mymock</span><span class=p>(),</span> <span class=n>Subclass</span><span class=p>)</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class=label id=id5><span class=brackets><a class=fn-backref href=#id4>2</a></span></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">An exception to this rule are the non-callable mocks. Attributes use the
callable variant because otherwise non-callable mocks couldn't have callable
methods.<p class="cyxy-trs-source cyxy-trs-target">此规则的一个例外是不可调用的模拟。 属性使用可调用变量，因为否则非可调用的模拟不能具有可调用方法。</p>
</dd>
</dl>
</div>
<div class=section id=mocking-imports-with-patch-dict>
<h3>Mocking imports with patch.dict<a class=headerlink href=#mocking-imports-with-patch-dict title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">One situation where mocking can be hard is where you have a local import inside
a function. These are harder to mock because they aren't using an object from
the module namespace that we can patch out.<p class="cyxy-trs-source cyxy-trs-target">其中一种情况就是在函数中有一个本地导入。 它们很难被模仿，因为它们没有使用我们可以修补的模块名称空间中的对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Generally local imports are to be avoided. They are sometimes done to prevent
circular dependencies, for which there is <em>usually</em> a much better way to solve
the problem (refactor the code) or to prevent "up front costs" by delaying the
import. This can also be solved in better ways than an unconditional local
import (store the module as a class or module attribute and only do the import
on first use).<p class="cyxy-trs-source cyxy-trs-target">一般来说，要避免本地进口。 它们有时是为了防止循环依赖，对于循环依赖，通常有一个更好的方法来解决问题(重构代码) ，或者通过延迟导入来防止“预先成本”。 这也可以通过比无条件本地导入更好的方式来解决(将模块存储为类或模块属性，并且只在第一次使用时进行导入)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">That aside there is a way to use <code class="docutils literal notranslate"><span class=pre>mock</span></code> to affect the results of an import.
Importing fetches an <em>object</em> from the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/sys.html#sys.modules title=sys.modules><code class="xref py py-data docutils literal notranslate"><span class=pre>sys.modules</span></code></a> dictionary. Note that it
fetches an <em>object</em>, which need not be a module. Importing a module for the
first time results in a module object being put in <cite>sys.modules</cite>, so usually
when you import something you get a module back. This need not be the case
however.<p class="cyxy-trs-source cyxy-trs-target">除此之外，还有一种使用 mock 来影响导入结果的方法。 导入从 sys.modules 字典获取一个对象。 注意，它获取一个对象，这个对象不需要是模块。 第一次导入模块会导致将模块对象放入 sys.modules 中，因此通常在导入某些内容时会返回一个模块。 然而，事实并非如此。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This means you can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> to <em>temporarily</em> put a mock in place
in <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/sys.html#sys.modules title=sys.modules><code class="xref py py-data docutils literal notranslate"><span class=pre>sys.modules</span></code></a>. Any imports whilst this patch is active will fetch the mock.
When the patch is complete (the decorated function exits, the with statement
body is complete or <code class="docutils literal notranslate"><span class=pre>patcher.stop()</span></code> is called) then whatever was there
previously will be restored safely.<p class="cyxy-trs-source cyxy-trs-target">这意味着可以使用 patch.dict ()临时在 sys.modules 中放置 mock。 当此补丁处于活动状态时，任何导入都将获取模拟。 当补丁完成时(修饰函数退出，with 语句主体完成或者调用 patcher.stop ()) ，那么之前存在的任何内容都将安全地恢复。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Here's an example that mocks out the 'fooble' module.<p class="cyxy-trs-source cyxy-trs-target">下面是一个模拟“ fooble”模块的示例。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>sys</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'sys.modules'</span><span class=p>,</span> <span class=p>{</span><span class=s1>'fooble'</span><span class=p>:</span> <span class=n>mock</span><span class=p>}):</span>
<span class=gp>... </span>   <span class=kn>import</span> <span class=nn>fooble</span>
<span class=gp>... </span>   <span class=n>fooble</span><span class=o>.</span><span class=n>blob</span><span class=p>()</span>
<span class=gp>...</span>
<span class=go>&lt;Mock name='mock.blob()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=s1>'fooble'</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>sys</span><span class=o>.</span><span class=n>modules</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>blob</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">As you can see the <code class="docutils literal notranslate"><span class=pre>import</span> <span class=pre>fooble</span></code> succeeds, but on exit there is no 'fooble'
left in <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/sys.html#sys.modules title=sys.modules><code class="xref py py-data docutils literal notranslate"><span class=pre>sys.modules</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">正如您所看到的，import fooble 成功，但是在退出时，sys.modules 中没有“ fooble”。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This also works for the <code class="docutils literal notranslate"><span class=pre>from</span> <span class=pre>module</span> <span class=pre>import</span> <span class=pre>name</span></code> form:<p class="cyxy-trs-source cyxy-trs-target">这也适用于 from 模块导入名称表单:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'sys.modules'</span><span class=p>,</span> <span class=p>{</span><span class=s1>'fooble'</span><span class=p>:</span> <span class=n>mock</span><span class=p>}):</span>
<span class=gp>... </span>   <span class=kn>from</span> <span class=nn>fooble</span> <span class=kn>import</span> <span class=n>blob</span>
<span class=gp>... </span>   <span class=n>blob</span><span class=o>.</span><span class=n>blip</span><span class=p>()</span>
<span class=gp>...</span>
<span class=go>&lt;Mock name='mock.blob.blip()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>blob</span><span class=o>.</span><span class=n>blip</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">With slightly more work you can also mock package imports:<p class="cyxy-trs-source cyxy-trs-target">通过稍微多做一些工作，您还可以使用 mock 包导入:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>modules</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'package'</span><span class=p>:</span> <span class=n>mock</span><span class=p>,</span> <span class=s1>'package.module'</span><span class=p>:</span> <span class=n>mock</span><span class=o>.</span><span class=n>module</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'sys.modules'</span><span class=p>,</span> <span class=n>modules</span><span class=p>):</span>
<span class=gp>... </span>   <span class=kn>from</span> <span class=nn>package.module</span> <span class=kn>import</span> <span class=n>fooble</span>
<span class=gp>... </span>   <span class=n>fooble</span><span class=p>()</span>
<span class=gp>...</span>
<span class=go>&lt;Mock name='mock.module.fooble()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>fooble</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>()</span>
</pre></div>
</div>
</div>
<div class=section id=tracking-order-of-calls-and-less-verbose-call-assertions>
<h3 class=cyxy-trs-source>Tracking order of calls and less verbose call assertions<font class=cyxy-trs-target> 跟踪调用顺序，减少冗长的调用断言</font><a class=headerlink href=#tracking-order-of-calls-and-less-verbose-call-assertions title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> class allows you to track the <em>order</em> of method calls on
your mock objects through the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> attribute. This
doesn't allow you to track the order of calls between separate mock objects,
however we can use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> to achieve the same effect.<p class="cyxy-trs-source cyxy-trs-target">Mock 类允许您通过方法调用属性跟踪对模拟对象的方法调用的顺序。 这不允许您跟踪单独的模拟对象之间的调用顺序，但是我们可以使用模拟调用来实现相同的效果。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Because mocks track calls to child mocks in <code class="docutils literal notranslate"><span class=pre>mock_calls</span></code>, and accessing an
arbitrary attribute of a mock creates a child mock, we can create our separate
mocks from a parent one. Calls to those child mock will then all be recorded,
in order, in the <code class="docutils literal notranslate"><span class=pre>mock_calls</span></code> of the parent:<p class="cyxy-trs-source cyxy-trs-target">由于 mock 在 mock 调用中跟踪对子模拟的调用，并访问 mock 的任意属性创建子模拟，因此我们可以从父模拟创建单独的模拟。 对这些孩子的模拟呼叫将被记录下来，按照父母的模拟呼叫顺序:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>manager</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span> <span class=o>=</span> <span class=n>manager</span><span class=o>.</span><span class=n>foo</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_bar</span> <span class=o>=</span> <span class=n>manager</span><span class=o>.</span><span class=n>bar</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span><span class=o>.</span><span class=n>something</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.foo.something()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_bar</span><span class=o>.</span><span class=n>other</span><span class=o>.</span><span class=n>thing</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.bar.other.thing()' id='...'&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>manager</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.foo.something(), call.bar.other.thing()]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">We can then assert about the calls, including the order, by comparing with
the <code class="docutils literal notranslate"><span class=pre>mock_calls</span></code> attribute on the manager mock:<p class="cyxy-trs-source cyxy-trs-target">然后，我们可以通过比较 manager mock 上的 mock call 属性来断言这些调用，包括顺序:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>expected_calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=o>.</span><span class=n>foo</span><span class=o>.</span><span class=n>something</span><span class=p>(),</span> <span class=n>call</span><span class=o>.</span><span class=n>bar</span><span class=o>.</span><span class=n>other</span><span class=o>.</span><span class=n>thing</span><span class=p>()]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>manager</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>expected_calls</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <code class="docutils literal notranslate"><span class=pre>patch</span></code> is creating, and putting in place, your mocks then you can attach
them to a manager mock using the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.attach_mock title=unittest.mock.Mock.attach_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>attach_mock()</span></code></a> method. After
attaching calls will be recorded in <code class="docutils literal notranslate"><span class=pre>mock_calls</span></code> of the manager.<p class="cyxy-trs-source cyxy-trs-target">如果正在创建并安装补丁，那么可以使用 attach mock ()方法将模拟附加到管理器模拟上。 附加呼叫后，经理的模拟呼叫将被记录下来。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>manager</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.Class1'</span><span class=p>)</span> <span class=k>as</span> <span class=n>MockClass1</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'mymodule.Class2'</span><span class=p>)</span> <span class=k>as</span> <span class=n>MockClass2</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>manager</span><span class=o>.</span><span class=n>attach_mock</span><span class=p>(</span><span class=n>MockClass1</span><span class=p>,</span> <span class=s1>'MockClass1'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>manager</span><span class=o>.</span><span class=n>attach_mock</span><span class=p>(</span><span class=n>MockClass2</span><span class=p>,</span> <span class=s1>'MockClass2'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>MockClass1</span><span class=p>()</span><span class=o>.</span><span class=n>foo</span><span class=p>()</span>
<span class=gp>... </span>        <span class=n>MockClass2</span><span class=p>()</span><span class=o>.</span><span class=n>bar</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.MockClass1().foo()' id='...'&gt;</span>
<span class=go>&lt;MagicMock name='mock.MockClass2().bar()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>manager</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.MockClass1(),</span>
<span class=go>call.MockClass1().foo(),</span>
<span class=go>call.MockClass2(),</span>
<span class=go>call.MockClass2().bar()]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If many calls have been made, but you're only interested in a particular
sequence of them then an alternative is to use the
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_has_calls title=unittest.mock.Mock.assert_has_calls><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_has_calls()</span></code></a> method. This takes a list of calls (constructed
with the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> object). If that sequence of calls are in
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> then the assert succeeds.<p class="cyxy-trs-source cyxy-trs-target">如果已经进行了许多调用，但是您只对它们的特定序列感兴趣，那么还有一种方法是使用 assert has calls ()方法。 这需要一个调用列表(由调用对象构造)。 如果这个调用序列出现在 mock 调用中，那么 assert 就会成功。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span><span class=o>.</span><span class=n>foo</span><span class=p>()</span><span class=o>.</span><span class=n>bar</span><span class=p>()</span><span class=o>.</span><span class=n>baz</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock().foo().bar().baz()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>one</span><span class=p>()</span><span class=o>.</span><span class=n>two</span><span class=p>()</span><span class=o>.</span><span class=n>three</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.one().two().three()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=n>call</span><span class=o>.</span><span class=n>one</span><span class=p>()</span><span class=o>.</span><span class=n>two</span><span class=p>()</span><span class=o>.</span><span class=n>three</span><span class=p>()</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>assert_has_calls</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Even though the chained call <code class="docutils literal notranslate"><span class=pre>m.one().two().three()</span></code> aren't the only calls that
have been made to the mock, the assert still succeeds.<p class="cyxy-trs-source cyxy-trs-target">即使链式呼叫 m.one ()。 二()。 3()并不是对 mock 进行的唯一调用，assert 仍然成功。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes a mock may have several calls made to it, and you are only interested
in asserting about <em>some</em> of those calls. You may not even care about the
order. In this case you can pass <code class="docutils literal notranslate"><span class=pre>any_order=True</span></code> to <code class="docutils literal notranslate"><span class=pre>assert_has_calls</span></code>:<p class="cyxy-trs-source cyxy-trs-target">有时候，一个 mock 可能会有几个调用，而您只对其中的一些调用进行断言。 你甚至可能根本不在乎这个顺序。 在这种情况下，你可以传递任何命令 True 来断言有调用:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>m</span><span class=o>.</span><span class=n>two</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>m</span><span class=o>.</span><span class=n>seven</span><span class=p>(</span><span class=mi>7</span><span class=p>),</span> <span class=n>m</span><span class=o>.</span><span class=n>fifty</span><span class=p>(</span><span class=s1>'50'</span><span class=p>)</span>
<span class=go>(...)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=o>.</span><span class=n>fifty</span><span class=p>(</span><span class=s1>'50'</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>call</span><span class=o>.</span><span class=n>seven</span><span class=p>(</span><span class=mi>7</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>assert_has_calls</span><span class=p>(</span><span class=n>calls</span><span class=p>,</span> <span class=n>any_order</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</pre></div>
</div>
</div>
<div class=section id=more-complex-argument-matching>
<h3 class=cyxy-trs-source>More complex argument matching<font class=cyxy-trs-target> 更复杂的参数匹配</font><a class=headerlink href=#more-complex-argument-matching title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using the same basic concept as <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.ANY title=unittest.mock.ANY><code class="xref py py-data docutils literal notranslate"><span class=pre>ANY</span></code></a> we can implement matchers to do more
complex assertions on objects used as arguments to mocks.<p class="cyxy-trs-source cyxy-trs-target">使用与 ANY 相同的基本概念，我们可以实现匹配器，对用作模拟参数的对象执行更复杂的断言。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Suppose we expect some object to be passed to a mock that by default
compares equal based on object identity (which is the Python default for user
defined classes). To use <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> we would need to pass
in the exact same object. If we are only interested in some of the attributes
of this object then we can create a matcher that will check these attributes
for us.<p class="cyxy-trs-source cyxy-trs-target">假设我们期望将某个对象传递给一个模拟，该模拟在默认情况下基于对象标识比较 equal (用户定义类的 Python 默认值)。 要使用用()调用的 assert，我们需要传入完全相同的对象。 如果我们只对这个对象的某些属性感兴趣，那么我们可以创建一个 matcher 来为我们检查这些属性。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can see in this example how a 'standard' call to <code class="docutils literal notranslate"><span class=pre>assert_called_with</span></code> isn't
sufficient:<p class="cyxy-trs-source cyxy-trs-target">在这个例子中，你可以看到一个标准的 assert 调用是如何不够的:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>a</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected: call(&lt;__main__.Foo object at 0x...&gt;)</span>
<span class=go>Actual call: call(&lt;__main__.Foo object at 0x...&gt;)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A comparison function for our <code class="docutils literal notranslate"><span class=pre>Foo</span></code> class might look something like this:<p class="cyxy-trs-source cyxy-trs-target">我们的 Foo 类的一个比较函数可能看起来像这样:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>compare</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>if</span> <span class=ow>not</span> <span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>==</span> <span class=nb>type</span><span class=p>(</span><span class=n>other</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=kc>False</span>
<span class=gp>... </span>    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>a</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>a</span><span class=p>:</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=kc>False</span>
<span class=gp>... </span>    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>b</span> <span class=o>!=</span> <span class=n>other</span><span class=o>.</span><span class=n>b</span><span class=p>:</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=kc>False</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=kc>True</span>
<span class=gp>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">And a matcher object that can use comparison functions like this for its
equality operation would look something like this:<p class="cyxy-trs-source cyxy-trs-target">一个 matcher 对象可以使用类似这样的比较函数来进行相等操作，它看起来像这样:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Matcher</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>compare</span><span class=p>,</span> <span class=n>some_obj</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>compare</span> <span class=o>=</span> <span class=n>compare</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>some_obj</span> <span class=o>=</span> <span class=n>some_obj</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__eq__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>compare</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>some_obj</span><span class=p>,</span> <span class=n>other</span><span class=p>)</span>
<span class=gp>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Putting all this together:<p class="cyxy-trs-source cyxy-trs-target">综上所述:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>match_foo</span> <span class=o>=</span> <span class=n>Matcher</span><span class=p>(</span><span class=n>compare</span><span class=p>,</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>match_foo</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <code class="docutils literal notranslate"><span class=pre>Matcher</span></code> is instantiated with our compare function and the <code class="docutils literal notranslate"><span class=pre>Foo</span></code> object
we want to compare against. In <code class="docutils literal notranslate"><span class=pre>assert_called_with</span></code> the <code class="docutils literal notranslate"><span class=pre>Matcher</span></code> equality
method will be called, which compares the object the mock was called with
against the one we created our matcher with. If they match then
<code class="docutils literal notranslate"><span class=pre>assert_called_with</span></code> passes, and if they don't an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> is raised:<p class="cyxy-trs-source cyxy-trs-target">Matcher 用我们的 compare 函数和我们要比较的 Foo 对象实例化。 使用 Matcher 相等性方法调用的 assert 将被调用，它将模拟调用的对象与我们创建匹配器的对象进行比较。 如果它们匹配，那么用 passes 调用 assert，如果它们不匹配，则引发 AssertionError:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>match_wrong</span> <span class=o>=</span> <span class=n>Matcher</span><span class=p>(</span><span class=n>compare</span><span class=p>,</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>match_wrong</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected: ((&lt;Matcher object at 0x...&gt;,), {})</span>
<span class=go>Called with: ((&lt;Foo object at 0x...&gt;,), {})</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">With a bit of tweaking you could have the comparison function raise the
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> directly and provide a more useful failure message.<p class="cyxy-trs-source cyxy-trs-target">稍微调整一下，就可以让比较函数直接引发 AssertionError，并提供更有用的失败消息。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">As of version 1.5, the Python testing library <a class="reference external" href=https://pyhamcrest.readthedocs.io/>PyHamcrest</a> provides similar functionality,
that may be useful here, in the form of its equality matcher
(<a class="reference external" href=https://pyhamcrest.readthedocs.io/en/release-1.8/integration/#module-hamcrest.library.integration.match_equality>hamcrest.library.integration.match_equality</a>).<p class="cyxy-trs-source cyxy-trs-target">在版本1.5中，Python 测试库 PyHamcrest 提供了类似的功能，这些功能在这里可能很有用，其形式是相等匹配器(hamcrest.library.integration.match equality)。</p>
</div>
</div>
</div>
 </div>
 </div>
 </div>
 <div class=sphinxsidebar role=navigation aria-label="main navigation">
 <div class=sphinxsidebarwrapper style=float:left;margin-right:0px;width:202px;top:27920.7px>
 <h3><a href=https://docs.python.org/zh-cn/3.9/contents.html class="cyxy-trs-source cyxy-trs-source-ted">目录<font class=cyxy-trs-target> Table of contents</font></a></h3>
 <ul>
<li><a class="reference internal cyxy-trs-source" href=#><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code> 上手指南<font class=cyxy-trs-target> How to get started</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#using-mock>使用 mock<font class=cyxy-trs-target> Using mocks</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mock-patching-methods>模拟方法调用<font class=cyxy-trs-target> Simulating a method call</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mock-for-method-calls-on-an-object>对象上的方法调用的 mock<font class=cyxy-trs-target> A mock for a method call on an</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-classes>Mocking Classes<font class=cyxy-trs-target> 嘲笑课程</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#naming-your-mocks>Naming your mocks<font class=cyxy-trs-target> 给你的模拟命名</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#tracking-all-calls>Tracking all Calls<font class=cyxy-trs-target> 追踪所有电话</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#setting-return-values-and-attributes>Setting Return Values and Attributes<font class=cyxy-trs-target> 设置返回值和属性</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#raising-exceptions-with-mocks>Raising exceptions with mocks<font class=cyxy-trs-target> 使用模拟引发异常</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#side-effect-functions-and-iterables>Side effect functions and iterables<font class=cyxy-trs-target> 副作用函数和迭代</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-asynchronous-iterators>Mocking asynchronous iterators<font class=cyxy-trs-target> 模仿异步迭代器</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-asynchronous-context-manager>Mocking asynchronous context manager<font class=cyxy-trs-target> 模仿异步上下文管理器</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#creating-a-mock-from-an-existing-object>Creating a Mock from an Existing Object<font class=cyxy-trs-target> 从现有对象创建模拟</font></a></li>
</ul>
</li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patch-decorators>Patch Decorators<font class=cyxy-trs-target> 修补装饰者</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#further-examples>Further Examples<font class=cyxy-trs-target> 进一步的例子</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-chained-calls>Mocking chained calls<font class=cyxy-trs-target> 嘲笑连锁呼叫</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#partial-mocking>Partial mocking<font class=cyxy-trs-target> 部分嘲笑</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-a-generator-method>Mocking a Generator Method<font class=cyxy-trs-target> 模仿生成器方法</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#applying-the-same-patch-to-every-test-method>Applying the same patch to every test method<font class=cyxy-trs-target> 对每个测试方法应用相同的补丁</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-unbound-methods>Mocking Unbound Methods<font class=cyxy-trs-target> 嘲笑未绑定方法</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#checking-multiple-calls-with-mock>Checking multiple calls with mock<font class=cyxy-trs-target> 使用 mock 检查多个调用</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#coping-with-mutable-arguments>Coping with mutable arguments<font class=cyxy-trs-target> 处理易变的争论</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#nesting-patches>Nesting Patches<font class=cyxy-trs-target> 嵌套斑块</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-a-dictionary-with-magicmock>Mocking a dictionary with MagicMock<font class=cyxy-trs-target> 用 MagicMock 嘲笑一本字典</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mock-subclasses-and-their-attributes>Mock subclasses and their attributes<font class=cyxy-trs-target> 模拟子类及其属性</font></a></li>
<li><a class="reference internal" href=#mocking-imports-with-patch-dict>Mocking imports with patch.dict</a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#tracking-order-of-calls-and-less-verbose-call-assertions>Tracking order of calls and less verbose call assertions<font class=cyxy-trs-target> 跟踪调用顺序，减少冗长的调用断言</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#more-complex-argument-matching>More complex argument matching<font class=cyxy-trs-target> 更复杂的参数匹配</font></a></li>
</ul>
</li>
</ul>
</li>
</ul>
 <h4 class="cyxy-trs-source cyxy-trs-source-ted">上一个主题</h4><h4 class="cyxy-trs-source cyxy-trs-target">The last subject</h4>
 <p class="topless cyxy-trs-source cyxy-trs-source-ted"><a href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html title=上一章><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code> --- mock对象库</a><p class="topless cyxy-trs-source cyxy-trs-target">And it's going to be. MOCK ---Mock Object Library</p>
 <h4 class="cyxy-trs-source cyxy-trs-source-ted">下一个主题</h4><h4 class="cyxy-trs-source cyxy-trs-target">Next topic</h4>
 <p class="topless cyxy-trs-source cyxy-trs-source-ted"><a href=https://docs.python.org/zh-cn/3.9/library/2to3.html title=下一章>2to3 - 自动将 Python 2 代码转为 Python 3 代码</a><p class="topless cyxy-trs-source cyxy-trs-target">2to3-automatically converts Python 2 Code to Python 3 code</p>
 <div role=note aria-label="source link">
 <h3 class="cyxy-trs-source cyxy-trs-source-ted">本页</h3><h3 class="cyxy-trs-source cyxy-trs-target">This page</h3>
 <ul class=this-page-menu>
 <li><a href=https://docs.python.org/zh-cn/3.9/bugs.html class="cyxy-trs-source cyxy-trs-source-ted">提交 Bug<font class=cyxy-trs-target> Commit the Bug</font></a></li>
 <li>
 <a href=https://github.com/python/cpython/blob/master/Doc/library/unittest.mock-examples.rst rel=nofollow class="cyxy-trs-source cyxy-trs-source-ted">显示源代码
 <font class=cyxy-trs-target> Display source code</font></a>
 </li>
 </ul>
 </div>
 </div>
 <div id=sidebarbutton title=折叠边栏 style="border-radius:0px 5px 5px 0px;color:#444444;background-color:#cccccc;font-size:1.2em;cursor:pointer;height:22600.4px;padding-top:1px;padding-left:1px;margin-left:218px"><span style=display:block;position:fixed;top:351px>«</span></div></div>
 <div class=clearer></div>
 </div> 
 <div class=related role=navigation aria-label="related navigation">
 <h3 class="cyxy-trs-source cyxy-trs-source-ted sf-hidden">导航</h3><h3 class="cyxy-trs-source cyxy-trs-target sf-hidden">Navigation</h3>
 <ul>
 <li class=right style=margin-right:10px>
 <a href=https://docs.python.org/zh-cn/3.9/genindex.html title=总目录 class="cyxy-trs-source cyxy-trs-source-ted">索引<font class=cyxy-trs-target> Index</font></a></li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/py-modindex.html title="Python 模块索引" class="cyxy-trs-source cyxy-trs-source-ted">模块<font class=cyxy-trs-target> Module</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/2to3.html title="2to3 - 自动将 Python 2 代码转为 Python 3 代码" class="cyxy-trs-source cyxy-trs-source-ted">下一页<font class=cyxy-trs-target> Next page</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/unittest.mock.html title="unittest.mock --- mock对象库" class="cyxy-trs-source cyxy-trs-source-ted">上一页<font class=cyxy-trs-target> Previous</font></a> |</li>
 <li><img src='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><rect fill-opacity="0"/></svg>' alt style="vertical-align:middle;margin-top:-1px;background-blend-mode:normal!important;background-clip:content-box!important;background-position:50% 50%!important;background-color:rgba(0,0,0,0)!important;background-image:var(--sf-img-1)!important;background-size:100% 100%!important;background-origin:content-box!important;background-repeat:no-repeat!important"></li>
 <li><a href=https://www.python.org/ class="cyxy-trs-source cyxy-trs-source-ted">Python<font class=cyxy-trs-target> 巨蟒</font></a> »</li>
 
 <li>
 <span class=language_switcher_placeholder><select><option value=en>English<option value=fr>French<option value=ja>Japanese<option value=ko>Korean<option value=pt-br>Brazilian Portuguese<option value=zh-cn selected>Simplified Chinese</select></span>
 <span class=version_switcher_placeholder><select><option value=3.10>dev (3.10)<option value=3.9 selected>3.9.0b3<option value=3.8>3.8<option value=3.7>3.7<option value=3.6>3.6<option value=3.5>3.5<option value=2.7>2.7</select></span>
 <a href=https://docs.python.org/zh-cn/3.9/index.html class="cyxy-trs-source cyxy-trs-source-ted">文档<font class=cyxy-trs-target> Documents</font></a> »
 </li>
 <li class="nav-item nav-item-1"><a href=https://docs.python.org/zh-cn/3.9/library/index.html class="cyxy-trs-source cyxy-trs-source-ted">Python 标准库<font class=cyxy-trs-target> Python Standard Library</font></a> »</li>
 <li class="nav-item nav-item-2"><a href=https://docs.python.org/zh-cn/3.9/library/development.html class="cyxy-trs-source cyxy-trs-source-ted">开发工具<font class=cyxy-trs-target> Development Tools</font></a> »</li>
 <li class=right>
 
 <div class=inline-search role=search>
 <form class=inline-search action=../search.html>
 <input placeholder=快速搜索 type=text name=q value>
 <input type=submit value=转向>
 
 
 </form>
 </div>
 
 |
 </li>
 </ul>
 </div> 
 <div class="footer cyxy-trs-source">
 © <a href=https://docs.python.org/zh-cn/3.9/copyright.html class="cyxy-trs-source cyxy-trs-source-ted">版权所有<font class=cyxy-trs-target> All rights reserved</font></a> 2001-2020, Python Software Foundation.
 <font class=cyxy-trs-target> 2001-2020年，Python软体基金会</font><br>
 The Python Software Foundation is a non-profit corporation.
<font class=cyxy-trs-target> Python软体基金会是一家非营利性公司</font><a href=https://www.python.org/psf/donations/ class="cyxy-trs-source cyxy-trs-source-ted">Please donate.<font class=cyxy-trs-target> 请捐款</font></a>
<br>
 <br>
 最后更新于 6月 16, 2020.
 <font class=cyxy-trs-target> Last updated on 16 June 2020</font><a href=https://docs.python.org/3/bugs.html class="cyxy-trs-source cyxy-trs-source-ted">Found a bug<font class=cyxy-trs-target> 发现了一个漏洞</font></a>?
 <br>
 Created using <font class=cyxy-trs-target> 创建使用</font><a href=https://www.sphinx-doc.org/ class="cyxy-trs-source cyxy-trs-source-ted">Sphinx<font class=cyxy-trs-target> 狮身人面像</font></a> 2.3.1.
 </div>
 
 <div class=cyxy-ctrl-wrapper>
 <div class=cyxy-ctrl-btn>
 <img class=cyxy-ctrl-img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=chrome-extension://jmpepeebcbihafjjadogphmbgiffiajh/images/control.png>
 </div>
 <div class=cyxy-personal style=display:none>
 <a href=https://fanyi.caiyunapp.com/user/center/ target=_blank>
 
 </a>
 </div>
 <div class=cyxy-function style=display:none>
 <img class=cyxy-favorite-btn src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=https://caiyunapp.com/imgs/webtrs/fanyi-btn-hover.png>
 </div>
 <div class=cyxy-favorite style=display:none>
 <img id=cyxyFavoriteBtn class=cyxy-favorite-btn src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=https://caiyunapp.com/imgs/webtrs/favorite-btn.png>
 </div>
 <div class=cyxy-video-trans style=display:none>
 <img class=cyxy-video-trans-btn src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=chrome-extension://jmpepeebcbihafjjadogphmbgiffiajh/images/fanyi-btn-subtitle.png>
 </div>
 <div class=cyxy-options-link style=display:none>
 <div class=cyxy-options-btn>
 
 </div>
 </div>
 </div> 
 <div class="cyxy-target-popup cyxy-trs-source" style=display:none><div style=margin:auto> </div></div><div class="cyxy-footer cyxy-trs-source" style=opacity:.88;display:none><div class=cyxy-footer-p>本网页由彩云小译翻译</div></div>