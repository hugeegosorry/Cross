<!DOCTYPE html> <html xmlns=http://www.w3.org/1999/xhtml lang=zh><!--
 Page saved with SingleFile 
 url: https://www.osgeo.cn/cpython/library/unittest.html 
 saved date: Sun May 17 2020 20:47:19 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<title>unittest ——单元测试框架 — Python 3.9.0a3 文档</title>
<style>div.body{min-width:450px;max-width:800px}div.body p,div.body dd,div.body li,div.body blockquote{-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto}a.headerlink{visibility:hidden}h1:hover>a.headerlink,h2:hover>a.headerlink,h3:hover>a.headerlink,h4:hover>a.headerlink,h5:hover>a.headerlink,h6:hover>a.headerlink,dt:hover>a.headerlink,caption:hover>a.headerlink,p.caption:hover>a.headerlink,div.code-block-caption:hover>a.headerlink{visibility:visible}div.body td{text-align:left}.align-default{text-align:center}div.admonition{margin-top:10px;margin-bottom:10px;padding:7px}div.admonition dt{font-weight:bold}div.admonition dl{margin-bottom:0}p.admonition-title{margin:0px 10px 5px 0px;font-weight:bold}table.docutils{border-collapse:collapse}table.align-default{margin-left:auto;margin-right:auto}table.docutils td,table.docutils th{border-top:0;border-left:0;border-right:0;border-bottom:1px solid #aaa}th{text-align:left;padding-right:5px}th>p:first-child,td>p:first-child{margin-top:0px}th>p:last-child,td>p:last-child{margin-bottom:0px}li>p:first-child{margin-top:0px}li>p:last-child{margin-bottom:0px}dl{margin-bottom:15px}dd>p:first-child{margin-top:0px}dd{margin-top:3px;margin-bottom:10px;margin-left:30px}dt:target,span.highlighted{background-color:#fbe54e}.sig-paren{font-size:larger}.versionmodified{font-style:italic}abbr{border-bottom:dotted 1px;cursor:help}pre{overflow:auto;overflow-y:hidden}span.pre{-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;hyphens:none}code.descname{background-color:transparent;font-weight:bold}code.descclassname{background-color:transparent}code.xref{background-color:transparent}html{background-color:#fff}body{font-family:'Lucida Grande',Arial,sans-serif;font-size:100%;color:#000;margin:0;padding:0}div.document{background-color:white}div.documentwrapper{float:left;width:100%}div.bodywrapper{margin:0 0 0 230px}div.body{background-color:white;color:#222}a{text-decoration:none}a:visited{color:#00608f;text-decoration:none}a:hover{text-decoration:underline}div.body h1,div.body h2,div.body h3,div.body h4{font-family:'Lucida Grande',Arial,sans-serif;background-color:white;font-weight:normal;color:#1a1a1a;border-bottom:1px solid #ccc}div.body h1{margin-top:0;font-size:200%}div.body h2{font-size:160%}div.body h3{font-size:140%}div.body h4{font-size:120%}a.headerlink{font-size:.8em;padding:0 4px 0 4px;text-decoration:none}a.headerlink:hover{background-color:#aaa;color:white}div.body p,div.body dd,div.body li,div.body blockquote{text-align:justify;line-height:130%}div.admonition p.admonition-title+p{display:inline}div.admonition p{margin-bottom:5px}div.note{background-color:#eee;border:1px solid #ccc}div.seealso{background-color:#ffc}p.admonition-title{display:inline}p.admonition-title:after{content:":"}pre{padding:5px;background-color:#efc;color:#333;line-height:120%;border-left:0;border-right:0}code{background-color:#ecf0f3;padding:0 1px 0 1px}.note code{background:#d6d6d6}body{background-color:white;margin-left:1em;margin-right:1em}div.body{padding:0 0 0 1.2em}div.body p{line-height:140%}div.body h1,div.body h2,div.body h3,div.body h4{margin:0;border:0;padding:.3em 0}div.body hr{border:0;background-color:#ccc;height:1px}div.body pre{border-radius:3px;border:1px solid #ac9}div.body div.admonition{border-radius:3px}div.body div.seealso{border:1px solid #dd6}div.body a{color:#0072aa}div.body a:visited{color:#6363bb}div.body a:hover{color:#00b0e4}code,pre{font-family:monospace,sans-serif;font-size:96.5%}div.body code{border-radius:3px}div.body code.descname{font-size:120%}div.body code.xref{font-weight:normal}table.docutils{border:1px solid #ddd;min-width:20%;border-radius:3px;margin-top:10px;margin-bottom:10px}table.docutils td,table.docutils th{border:1px solid #ddd!important;border-radius:3px}table p{text-align:left!important}table.docutils th{background-color:#eee;padding:.3em .5em}table.docutils td{background-color:white;padding:.3em .5em}.highlight{background:none!important}dl>dt span~em{font-family:monospace,sans-serif}.highlight{background:#efc}.highlight .k{color:#007020;font-weight:bold}.highlight .o{color:#666}.highlight .c1{color:#408090;font-style:italic}.highlight .go{color:#333}.highlight .gp{color:#c65d09;font-weight:bold}.highlight .kc{color:#007020;font-weight:bold}.highlight .kn{color:#007020;font-weight:bold}.highlight .nb{color:#007020}.highlight .nc{color:#0e84b5;font-weight:bold}.highlight .nd{color:#555;font-weight:bold}.highlight .ne{color:#007020}.highlight .nf{color:#06287e}.highlight .nn{color:#0e84b5;font-weight:bold}.highlight .ow{color:#007020;font-weight:bold}.highlight .mf{color:#208050}.highlight .mi{color:#208050}.highlight .sa{color:#4070a0}.highlight .sd{color:#4070a0;font-style:italic}.highlight .s2{color:#4070a0}.highlight .si{color:#70a0d0;font-style:italic}.highlight .s1{color:#4070a0}.highlight .bp{color:#007020}.highlight .vm{color:#bb60d5}</style>
<link rel=search type=application/opensearchdescription+xml title="在 Python 3.9.0a3 文档 中搜索" href=https://www.osgeo.cn/cpython/_static/opensearch.xml>
<link rel=author title=关于这些文档 href=https://www.osgeo.cn/cpython/about.html>
<link rel=index title=索引 href=https://www.osgeo.cn/cpython/genindex.html>
<link rel=search title=搜索 href=https://www.osgeo.cn/cpython/search.html>
<link rel=copyright title=版权所有 href=https://www.osgeo.cn/cpython/copyright.html>
<link rel=next title="unittest.mock ---模拟对象库" href=https://www.osgeo.cn/cpython/library/unittest.mock.html>
<link rel=prev title="doctest ---测试交互式python示例" href=https://www.osgeo.cn/cpython/library/doctest.html>
<link rel=canonical href=https://docs.python.org/3/library/unittest.html>
<style>@media (pointer:coarse){@media only screen and (max-device-width:1024px){html{font-size:80%!important}}@media only screen and (max-device-width:414px){html{font-size:70%!important}}@media only screen and (max-device-width:320px){html{font-size:90%!important}}}@-webkit-keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@-webkit-keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gEGxE4IQYzJ14AAAI3SURBVDjLZZNPSFVBFIe/e9+zd3silBCl0SZoU4s2rVq0EB5tQip4UNvATVGu3QRBiyAi2iltWkgbF5EgRhFFRpiWtrWIzDIV1Pzz7p15M2fmtvDevOqBw8DM9zvnN8ycgF3R/eDtM2mac96ZdrFNxBikqbRV+vHH/ut9gAZczoe7C3gnF0f6au1OLM5avFi8d1Ea+JvAMSAq8nsKOGs5f2cYJ3Y7rc2PO4BqkS8DdD98f9tbe1ysCoxOBo1qlEXHJWcM4b5KPU19zleA0o4Clx99eO3EdqVewHsCoFRugUoVghJO7A6H6Vx9wdtYi27cr5x6dy/03nVtWTU7bWeZh6jNUcAiCaFTURl9A+gs56AviHzh3mnqtdPxm6knfQPLU7UaokASQq/agY7yDrG16Mba6Pz48NP56VdrgAApYObGaicPtkovToFLQBKA/WUxTe3FRk4san15aGKgd3Dj560rrdGJS6FT0X9YYvLuiMKL1kAQOpHZ3PqfyZfP41+9PW1VfzX0RXFSECfgNEmSTgImdDruF2O0E8vvqZG1auQubAsKooIYYHpGvwA2g+xndQBHgWa6cG0ih5cW/w6VvEq3nChwCoBvs+bL2Z7VceBHGTDAIrABpMVuhw+4OiLgLIglOLPYBTQAlfErIeCzjRVg1dtEb1kt5Omv+DTV2YssAN+zNdkzC42N9brV8WdvYp07seOdM2Of1F3AAknW0AJpwN6IgEPAEaANaMlcbmZdl7KRBuAfAb+v//yMAJoAAAAASUVORK5CYII="><style>.sf-hidden{display:none!important}</style><body>
 
 <div class=related role=navigation aria-label="related navigation" style=display:none!important>
 
 
 </div> 
 <div class=document>
 <div class=documentwrapper>
 <div class=bodywrapper>
 <div class=body role=main>
 
 <div class=section id=module-unittest>
<span id=unittest-unit-testing-framework style=display:none!important></span><h1><a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> ——单元测试框架<a class=headerlink href=#module-unittest title=永久链接至标题>¶</a></h1>
<p><strong>源代码：</strong> <a class="reference external" href=https://github.com/python/cpython/tree/master/Lib/unittest/__init__.py>Lib/unittest/__init__.py</a></p>
<hr class=docutils>
<p>（如果您已经熟悉测试的基本概念，您可能希望跳到 <a class="reference internal" href=#assert-methods><span class="std std-ref">the list of assert methods</span></a> ）</p>
<ins class="adsbygoogle sf-hidden" style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-1466963416408457 data-ad-slot=8850786025></ins>
<p>这个 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 单元测试框架最初是受JUnit的启发，与其他语言中的主要单元测试框架具有相似的风格。它支持测试自动化、共享测试的设置和关闭代码、将测试聚合到集合中以及独立于报告框架的测试。</p>
<p>为了实现这一目标， <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 以面向对象的方式支持一些重要概念：</p>
<dl class=simple>
<dt>测试夹具<dd><p>A <em class=dfn>test fixture</em> 表示执行一个或多个测试所需的准备，以及任何相关的清理操作。例如，这可能涉及创建临时或代理数据库、目录或启动服务器进程。</p>
</dd>
<dt>测试用例<dd><p>A <em class=dfn>test case</em> 是单独的测试单元。它检查对特定输入集的特定响应。 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 提供基类， <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> ，可用于创建新的测试用例。</p>
</dd>
<dt>测试套件<dd><p>A <em class=dfn>test suite</em> 是测试用例、测试套件或两者的集合。它用于聚合应该一起执行的测试。</p>
</dd>
<dt>试验转轮<dd><p>A <em class=dfn>test runner</em> 是协调测试执行并向用户提供结果的组件。运行程序可以使用图形界面、文本界面，或者返回一个特殊值来指示执行测试的结果。</p>
</dd>
</dl>
<div class="admonition seealso">
<p class=admonition-title>参见</p>
<dl class=simple>
<dt>模块 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/doctest.html#module-doctest title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class=pre>doctest</span></code></a><dd><p>另一个风格迥异的测试支持模块。</p>
</dd>
<dt><a class="reference external" href=https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>Simple Smalltalk Testing: With Patterns</a><dd><p>KentBeck关于使用共享模式测试框架的原始论文 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> .</p>
</dd>
<dt><a class="reference external" href=https://docs.pytest.org/>pytest</a><dd><p>第三方unittest框架，具有较轻的语法，用于编写测试。例如， <code class="docutils literal notranslate"><span class=pre>assert</span> <span class=pre>func(10)</span> <span class=pre>==</span> <span class=pre>42</span></code> .</p>
</dd>
<dt><a class="reference external" href=https://wiki.python.org/moin/PythonTestingToolsTaxonomy>The Python Testing Tools Taxonomy</a><dd><p>大量的Python测试工具列表，包括功能测试框架和模拟对象库。</p>
</dd>
<dt><a class="reference external" href=http://lists.idyll.org/listinfo/testing-in-python>Testing in Python Mailing List</a><dd><p>在Python中讨论测试和测试工具的特殊兴趣小组。</p>
</dd>
</dl>
<p>剧本 <code class="file docutils literal notranslate"><span class=pre>Tools/unittestgui/unittestgui.py</span></code> 在Python中，源代码分发是用于测试发现和执行的GUI工具。这在很大程度上是为了便于新到单元测试的使用。对于生产环境，建议由连续集成系统驱动测试，例如 <a class="reference external" href=https://buildbot.net/>Buildbot</a> ， <a class="reference external" href=https://jenkins.io/>Jenkins</a> 或 <a class="reference external" href=http://hudson-ci.org/>Hudson</a> .</p>
</div>
<div class=section id=basic-example>
<span id=unittest-minimal-example></span><h2>基本实例<a class=headerlink href=#basic-example title=永久链接至标题>¶</a></h2>
<p>这个 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 模块为构建和运行测试提供了一套丰富的工具。本节演示了工具的一小部分足以满足大多数用户的需求。</p>
<p>下面是一个测试三个字符串方法的简短脚本：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>unittest</span>

<span class=k>class</span> <span class=nc>TestStringMethods</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>

    <span class=k>def</span> <span class=nf>test_upper</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=s1>'foo'</span><span class=o>.</span><span class=n>upper</span><span class=p>(),</span> <span class=s1>'FOO'</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>test_isupper</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertTrue</span><span class=p>(</span><span class=s1>'FOO'</span><span class=o>.</span><span class=n>isupper</span><span class=p>())</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertFalse</span><span class=p>(</span><span class=s1>'Foo'</span><span class=o>.</span><span class=n>isupper</span><span class=p>())</span>

    <span class=k>def</span> <span class=nf>test_split</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>s</span> <span class=o>=</span> <span class=s1>'hello world'</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>s</span><span class=o>.</span><span class=n>split</span><span class=p>(),</span> <span class=p>[</span><span class=s1>'hello'</span><span class=p>,</span> <span class=s1>'world'</span><span class=p>])</span>
        <span class=c1># check that s.split fails when the separator is not a string</span>
        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertRaises</span><span class=p>(</span><span class=ne>TypeError</span><span class=p>):</span>
            <span class=n>s</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>'__main__'</span><span class=p>:</span>
    <span class=n>unittest</span><span class=o>.</span><span class=n>main</span><span class=p>()</span>
</pre></div>
</div>
<p>通过子类化创建测试用例 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>unittest.TestCase</span></code></a> . 三个单独的测试是用名称以字母开头的方法定义的。 <code class="docutils literal notranslate"><span class=pre>test</span></code> .此命名约定通知测试运行程序哪些方法表示测试。</p>
<p>每个测试的关键是调用 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> 检查预期结果； <a class="reference internal" href=#unittest.TestCase.assertTrue title=unittest.TestCase.assertTrue><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertTrue()</span></code></a> 或 <a class="reference internal" href=#unittest.TestCase.assertFalse title=unittest.TestCase.assertFalse><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertFalse()</span></code></a> 核实某一条件；或 <a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a> 以验证是否引发了特定的异常。使用这些方法而不是 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/simple_stmts.html#assert><code class="xref std std-keyword docutils literal notranslate"><span class=pre>assert</span></code></a> 语句，以便测试运行程序可以累积所有测试结果并生成报告。</p>
<p>这个 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 和 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 方法允许您定义将在每个测试方法之前和之后执行的指令。本节将更详细地介绍它们。 <a class="reference internal" href=#organizing-tests><span class="std std-ref">组织测试代码</span></a> .</p>
<p>最后一个块显示了一种运行测试的简单方法。 <a class="reference internal" href=#unittest.main title=unittest.main><code class="xref py py-func docutils literal notranslate"><span class=pre>unittest.main()</span></code></a> 为测试脚本提供命令行接口。从命令行运行时，上面的脚本生成的输出如下所示：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=o>...</span>
<span class=o>----------------------------------------------------------------------</span>
<span class=n>Ran</span> <span class=mi>3</span> <span class=n>tests</span> <span class=ow>in</span> <span class=mf>0.000</span><span class=n>s</span>

<span class=n>OK</span>
</pre></div>
</div>
<p>路过 <code class="docutils literal notranslate"><span class=pre>-v</span></code> 测试脚本的选项将指示 <a class="reference internal" href=#unittest.main title=unittest.main><code class="xref py py-func docutils literal notranslate"><span class=pre>unittest.main()</span></code></a> 要启用更高级别的详细信息，并生成以下输出：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>test_isupper</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>TestStringMethods</span><span class=p>)</span> <span class=o>...</span> <span class=n>ok</span>
<span class=n>test_split</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>TestStringMethods</span><span class=p>)</span> <span class=o>...</span> <span class=n>ok</span>
<span class=n>test_upper</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>TestStringMethods</span><span class=p>)</span> <span class=o>...</span> <span class=n>ok</span>

<span class=o>----------------------------------------------------------------------</span>
<span class=n>Ran</span> <span class=mi>3</span> <span class=n>tests</span> <span class=ow>in</span> <span class=mf>0.001</span><span class=n>s</span>

<span class=n>OK</span>
</pre></div>
</div>
<p>上面的例子显示了最常用的 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 足以满足许多日常测试需求的功能。文档的其余部分从第一个原则探索完整的特性集。</p>
</div>
<div class=section id=command-line-interface>
<span id=unittest-command-line-interface></span><h2>命令行界面<a class=headerlink href=#command-line-interface title=永久链接至标题>¶</a></h2>
<p>可以从命令行使用UnitTest模块从模块、类甚至单个测试方法运行测试：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>test_module1</span> <span class=n>test_module2</span>
<span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>test_module</span><span class=o>.</span><span class=n>TestClass</span>
<span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>test_module</span><span class=o>.</span><span class=n>TestClass</span><span class=o>.</span><span class=n>test_method</span>
</pre></div>
</div>
<p>您可以通过模块名和完全限定的类或方法名的任意组合传入一个列表。</p>
<p>测试模块也可以通过文件路径指定：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>tests</span><span class=o>/</span><span class=n>test_something</span><span class=o>.</span><span class=n>py</span>
</pre></div>
</div>
<p>这允许您使用shell文件名完成来指定测试模块。指定的文件必须仍然可以作为模块导入。通过删除“.py”并将路径分隔符转换为“.”将路径转换为模块名。如果要执行不可作为模块导入的测试文件，则应直接执行该文件。</p>
<p>您可以通过传递-v标志来运行更详细（更详细）的测试：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=o>-</span><span class=n>v</span> <span class=n>test_module</span>
</pre></div>
</div>
<p>在没有参数的情况下执行时 <a class="reference internal" href=#unittest-test-discovery><span class="std std-ref">测试发现</span></a> 已启动：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span>
</pre></div>
</div>
<p>有关所有命令行选项的列表：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=o>-</span><span class=n>h</span>
</pre></div>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>在早期版本中，只能运行单个测试方法，而不能运行模块或类。</p>
</div>
<div class=section id=command-line-options>
<h3>命令行选项<a class=headerlink href=#command-line-options title=永久链接至标题>¶</a></h3>
<p><strong class=program>unittest</strong> 支持以下命令行选项：</p>
<dl class=cmdoption>
<dt id=cmdoption-unittest-b>
<code class="sig-name descname">-b</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--buffer</code><code class="sig-prename descclassname"></code><a class=headerlink href=#cmdoption-unittest-b title=永久链接至目标>¶</a></dt>
<dd><p>在测试运行期间缓冲标准输出和标准错误流。通过测试期间的输出被丢弃。在测试失败或错误时，输出会正常回送，并添加到故障消息中。</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-c>
<code class="sig-name descname">-c</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--catch</code><code class="sig-prename descclassname"></code><a class=headerlink href=#cmdoption-unittest-c title=永久链接至目标>¶</a></dt>
<dd><p><kbd class="kbd docutils literal notranslate">Control-C</kbd> 在测试运行期间，等待当前测试结束，然后报告到目前为止的所有结果。第二 <kbd class="kbd docutils literal notranslate">Control-C</kbd> 提高正常值 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#KeyboardInterrupt title=KeyboardInterrupt><code class="xref py py-exc docutils literal notranslate"><span class=pre>KeyboardInterrupt</span></code></a> 例外。</p>
<p>见 <a class="reference internal" href=#signal-handling>Signal Handling</a> 用于提供此功能的函数。</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-f>
<code class="sig-name descname">-f</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--failfast</code><code class="sig-prename descclassname"></code><a class=headerlink href=#cmdoption-unittest-f title=永久链接至目标>¶</a></dt>
<dd><p>在第一个错误或失败时停止测试运行。</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-k>
<code class="sig-name descname">-k</code><code class="sig-prename descclassname"></code><a class=headerlink href=#cmdoption-unittest-k title=永久链接至目标>¶</a></dt>
<dd><p>只运行与模式或子字符串匹配的测试方法和类。此选项可以多次使用，在这种情况下，所有与给定模式匹配的测试用例都包含在内。</p>
<p>包含通配符的模式 (<code class="docutils literal notranslate"><span class=pre>*</span></code> ）与测试名称匹配，使用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/fnmatch.html#fnmatch.fnmatchcase title=fnmatch.fnmatchcase><code class="xref py py-meth docutils literal notranslate"><span class=pre>fnmatch.fnmatchcase()</span></code></a> 否则，将使用简单的区分大小写的子字符串匹配。</p>
<p>模式与测试加载程序导入的完全限定的测试方法名称相匹配。</p>
<p>例如， <code class="docutils literal notranslate"><span class=pre>-k</span> <span class=pre>foo</span></code> 比赛 <code class="docutils literal notranslate"><span class=pre>foo_tests.SomeTest.test_something</span></code> ， <code class="docutils literal notranslate"><span class=pre>bar_tests.SomeTest.test_foo</span></code> ，但不是 <code class="docutils literal notranslate"><span class=pre>bar_tests.FooTest.test_something</span></code> .</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-locals>
<code class="sig-name descname">--locals</code><code class="sig-prename descclassname"></code><a class=headerlink href=#cmdoption-unittest-locals title=永久链接至目标>¶</a></dt>
<dd><p>在回溯中显示局部变量。</p>
</dl>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能: </span>命令行选项 <code class="docutils literal notranslate"><span class=pre>-b</span></code> ， <code class="docutils literal notranslate"><span class=pre>-c</span></code> 和 <code class="docutils literal notranslate"><span class=pre>-f</span></code> 加入。</p>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.5 新版功能: </span>命令行选项 <code class="docutils literal notranslate"><span class=pre>--locals</span></code> .</p>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.7 新版功能: </span>命令行选项 <code class="docutils literal notranslate"><span class=pre>-k</span></code> .</p>
</div>
<p>命令行还可以用于测试发现、运行项目中的所有测试或仅运行一个子集。</p>
</div>
</div>
<div class=section id=test-discovery>
<span id=unittest-test-discovery></span><h2>测试发现<a class=headerlink href=#test-discovery title=永久链接至标题>¶</a></h2>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>UnitTest支持简单的测试发现。为了与测试发现兼容，所有测试文件都必须 <a class="reference internal" href=https://www.osgeo.cn/cpython/tutorial/modules.html#tut-modules><span class="std std-ref">modules</span></a> 或 <a class="reference internal" href=https://www.osgeo.cn/cpython/tutorial/modules.html#tut-packages><span class="std std-ref">packages</span></a> （包括 <a class="reference internal" href=https://www.osgeo.cn/cpython/glossary.html#term-namespace-package><span class="xref std std-term">namespace packages</span></a> ）可从项目的顶级目录导入（这意味着它们的文件名必须有效 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/lexical_analysis.html#identifiers><span class="std std-ref">identifiers</span></a> ）</p>
<p>测试发现在 <a class="reference internal" href=#unittest.TestLoader.discover title=unittest.TestLoader.discover><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestLoader.discover()</span></code></a> ，但也可以从命令行使用。基本命令行用法是：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>cd</span> <span class=n>project_directory</span>
<span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>discover</span>
</pre></div>
</div>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>作为捷径， <code class="docutils literal notranslate"><span class=pre>python</span> <span class=pre>-m</span> <span class=pre>unittest</span></code> 相当于 <code class="docutils literal notranslate"><span class=pre>python</span> <span class=pre>-m</span> <span class=pre>unittest</span> <span class=pre>discover</span></code> . 如果要传递参数以测试发现 <code class="docutils literal notranslate"><span class=pre>discover</span></code> 必须显式使用子命令。</p>
</div>
<p>这个 <code class="docutils literal notranslate"><span class=pre>discover</span></code> 子命令具有以下选项：</p>
<dl class=cmdoption>
<dt id=cmdoption-unittest-discover-v>
<code class="sig-name descname">-v</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--verbose</code><code class="sig-prename descclassname"></code><a class=headerlink href=#cmdoption-unittest-discover-v title=永久链接至目标>¶</a></dt>
<dd><p>冗长输出</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-discover-s>
<code class="sig-name descname">-s</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--start-directory</code><code class="sig-prename descclassname"> directory</code><a class=headerlink href=#cmdoption-unittest-discover-s title=永久链接至目标>¶</a></dt>
<dd><p>要启动发现的目录 (<code class="docutils literal notranslate"><span class=pre>.</span></code> 默认值）</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-discover-p>
<code class="sig-name descname">-p</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--pattern</code><code class="sig-prename descclassname"> pattern</code><a class=headerlink href=#cmdoption-unittest-discover-p title=永久链接至目标>¶</a></dt>
<dd><p>匹配测试文件的模式 (<code class="docutils literal notranslate"><span class=pre>test*.py</span></code> 默认值）</p>
</dl>
<dl class=cmdoption>
<dt id=cmdoption-unittest-discover-t>
<code class="sig-name descname">-t</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--top-level-directory</code><code class="sig-prename descclassname"> directory</code><a class=headerlink href=#cmdoption-unittest-discover-t title=永久链接至目标>¶</a></dt>
<dd><p>项目的顶级目录（默认为开始目录）</p>
</dl>
<p>这个 <a class="reference internal" href=#cmdoption-unittest-discover-s><code class="xref std std-option docutils literal notranslate"><span class=pre>-s</span></code></a> ， <a class="reference internal" href=#cmdoption-unittest-discover-p><code class="xref std std-option docutils literal notranslate"><span class=pre>-p</span></code></a> 和 <a class="reference internal" href=#cmdoption-unittest-discover-t><code class="xref std std-option docutils literal notranslate"><span class=pre>-t</span></code></a> 选项可以按顺序作为位置参数传入。以下两个命令行等效：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>discover</span> <span class=o>-</span><span class=n>s</span> <span class=n>project_directory</span> <span class=o>-</span><span class=n>p</span> <span class=s2>"*_test.py"</span>
<span class=n>python</span> <span class=o>-</span><span class=n>m</span> <span class=n>unittest</span> <span class=n>discover</span> <span class=n>project_directory</span> <span class=s2>"*_test.py"</span>
</pre></div>
</div>
<p>例如，除了作为路径，还可以传递包名称 <code class="docutils literal notranslate"><span class=pre>myproject.subpackage.test</span></code> ，作为开始目录。然后将导入您提供的包名称，并将其在文件系统上的位置用作开始目录。</p>
<div class="admonition caution">
<p class=admonition-title>警告</p>
<p>测试发现通过导入来加载测试。一旦测试发现找到了起始目录中的所有测试文件，您就指定它将路径转换为要导入的包名称。例如 <code class="file docutils literal notranslate"><span class=pre>foo/bar/baz.py</span></code> 将作为导入 <code class="docutils literal notranslate"><span class=pre>foo.bar.baz</span></code> .</p>
<p>如果在全局安装了一个包，并尝试在该包的其他副本上进行测试发现，则导入 <em>能够</em> 从错误的地方发生。如果发生这种情况，测试发现将警告您并退出。</p>
<p>如果您以包名称而不是目录路径的形式提供起始目录，那么discover会假定从中导入的任何位置都是您想要的位置，因此不会收到警告。</p>
</div>
<p>测试模块和包可以通过 <a class="reference internal" href=#load-tests-protocol>load_tests protocol</a> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>测试发现支持 <a class="reference internal" href=https://www.osgeo.cn/cpython/glossary.html#term-namespace-package><span class="xref std std-term">namespace packages</span></a> .</p>
</div>
</div>
<div class=section id=organizing-test-code>
<span id=organizing-tests></span><h2>组织测试代码<a class=headerlink href=#organizing-test-code title=永久链接至标题>¶</a></h2>
<p>单元测试的基本组成部分是 <em class=dfn>test cases</em> ---必须设置和检查正确性的单一方案。在 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> ，测试用例由 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>unittest.TestCase</span></code></a> 实例。要创建自己的测试用例，必须编写 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 或使用 <a class="reference internal" href=#unittest.FunctionTestCase title=unittest.FunctionTestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>FunctionTestCase</span></code></a> .</p>
<p>A的测试代码 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 实例应该是完全独立的，这样它可以单独运行，也可以与任何数量的其他测试用例任意组合运行。</p>
<p>最简单的 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 子类只实现一个测试方法（即名称以 <code class="docutils literal notranslate"><span class=pre>test</span></code> ）为了执行特定的测试代码：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>unittest</span>

<span class=k>class</span> <span class=nc>DefaultWidgetSizeTestCase</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>test_default_widget_size</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>widget</span> <span class=o>=</span> <span class=n>Widget</span><span class=p>(</span><span class=s1>'The widget'</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>widget</span><span class=o>.</span><span class=n>size</span><span class=p>(),</span> <span class=p>(</span><span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>))</span>
</pre></div>
</div>
<p>注意，为了测试某些东西，我们使用 <code class="xref py py-meth docutils literal notranslate"><span class=pre>assert*()</span></code> 方法由 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 基类。如果测试失败，将引发异常并给出解释性消息，以及 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 将测试用例标识为 <em class=dfn>failure</em> . 任何其他例外情况将被视为 <em class=dfn>errors</em> .</p>
<p>测试可以是多个的，并且它们的设置可以是重复的。幸运的是，我们可以通过实现一个名为 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> ，测试框架将自动调用我们运行的每个测试：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>unittest</span>

<span class=k>class</span> <span class=nc>WidgetTestCase</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>widget</span> <span class=o>=</span> <span class=n>Widget</span><span class=p>(</span><span class=s1>'The widget'</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>test_default_widget_size</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>widget</span><span class=o>.</span><span class=n>size</span><span class=p>(),</span> <span class=p>(</span><span class=mi>50</span><span class=p>,</span><span class=mi>50</span><span class=p>),</span>
                         <span class=s1>'incorrect default size'</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>test_widget_resize</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>widget</span><span class=o>.</span><span class=n>resize</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span><span class=mi>150</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>widget</span><span class=o>.</span><span class=n>size</span><span class=p>(),</span> <span class=p>(</span><span class=mi>100</span><span class=p>,</span><span class=mi>150</span><span class=p>),</span>
                         <span class=s1>'wrong size after resize'</span><span class=p>)</span>
</pre></div>
</div>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>运行各种测试的顺序是通过对测试方法名称进行排序来确定的，而这些方法名称与字符串的内置顺序有关。</p>
</div>
<p>如果 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 方法在测试运行时引发异常，框架将认为测试出错，并且不会执行测试方法。</p>
<p>同样，我们可以提供 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 运行测试方法后整理的方法：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>unittest</span>

<span class=k>class</span> <span class=nc>WidgetTestCase</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>widget</span> <span class=o>=</span> <span class=n>Widget</span><span class=p>(</span><span class=s1>'The widget'</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>tearDown</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>widget</span><span class=o>.</span><span class=n>dispose</span><span class=p>()</span>
</pre></div>
</div>
<p>如果 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 成功， <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 无论测试方法是否成功，都将运行。</p>
<p>这种测试代码的工作环境称为 <em class=dfn>test fixture</em> . 一个新的测试用例实例被创建为一个独特的测试夹具，用于执行每个单独的测试方法。因此 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> ， <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code> 每次测试调用一次。</p>
<p>建议您使用测试用例实现根据测试的特性将测试分组在一起。 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 为此提供了一种机制： <em class=dfn>test suite</em> ，代表为 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 的 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 类。在大多数情况下，调用 <a class="reference internal" href=#unittest.main title=unittest.main><code class="xref py py-func docutils literal notranslate"><span class=pre>unittest.main()</span></code></a> 会做正确的事情，为您收集所有模块的测试用例并执行它们。</p>
<p>但是，如果您想要定制测试套件的构建，您可以自己进行：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>suite</span><span class=p>():</span>
    <span class=n>suite</span> <span class=o>=</span> <span class=n>unittest</span><span class=o>.</span><span class=n>TestSuite</span><span class=p>()</span>
    <span class=n>suite</span><span class=o>.</span><span class=n>addTest</span><span class=p>(</span><span class=n>WidgetTestCase</span><span class=p>(</span><span class=s1>'test_default_widget_size'</span><span class=p>))</span>
    <span class=n>suite</span><span class=o>.</span><span class=n>addTest</span><span class=p>(</span><span class=n>WidgetTestCase</span><span class=p>(</span><span class=s1>'test_widget_resize'</span><span class=p>))</span>
    <span class=k>return</span> <span class=n>suite</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>'__main__'</span><span class=p>:</span>
    <span class=n>runner</span> <span class=o>=</span> <span class=n>unittest</span><span class=o>.</span><span class=n>TextTestRunner</span><span class=p>()</span>
    <span class=n>runner</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>suite</span><span class=p>())</span>
</pre></div>
</div>
<p>您可以将测试用例和测试套件的定义与要测试的代码（例如 <code class="file docutils literal notranslate"><span class=pre>widget.py</span></code> 但是将测试代码放在单独的模块中有几个优点，例如 <code class="file docutils literal notranslate"><span class=pre>test_widget.py</span></code> ：</p>
<ul class=simple>
<li><p>测试模块可以从命令行独立运行。</p></li>
<li><p>测试代码可以更容易地与已发送的代码分离。</p></li>
<li><p>在没有充分理由的情况下，更改测试代码以适合其测试的代码的诱惑就更少了。</p></li>
<li><p>测试代码的修改频率应该比它测试的代码低得多。</p></li>
<li><p>测试代码可以更容易地重构。</p></li>
<li><p>无论如何，用C编写的模块测试必须在单独的模块中进行，那么为什么不一致呢？</p></li>
<li><p>如果测试策略改变了，就不需要改变源代码。</p></li>
</ul>
</div>
<div class=section id=re-using-old-test-code>
<span id=legacy-unit-tests></span><h2>重新使用旧测试代码<a class=headerlink href=#re-using-old-test-code title=永久链接至标题>¶</a></h2>
<p>一些用户会发现他们有要从中运行的现有测试代码 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> ，而不将每个旧的测试函数转换为 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 子类。</p>
<p>因此， <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 提供了一个 <a class="reference internal" href=#unittest.FunctionTestCase title=unittest.FunctionTestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>FunctionTestCase</span></code></a> 类。此子类 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 可用于封装现有的测试函数。还可以提供设置和拆卸功能。</p>
<p>给定以下测试函数：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>testSomething</span><span class=p>():</span>
    <span class=n>something</span> <span class=o>=</span> <span class=n>makeSomething</span><span class=p>()</span>
    <span class=k>assert</span> <span class=n>something</span><span class=o>.</span><span class=n>name</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
    <span class=c1># ...</span>
</pre></div>
</div>
<p>您可以使用可选的设置和下拉方法创建如下等效的测试用例实例：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>testcase</span> <span class=o>=</span> <span class=n>unittest</span><span class=o>.</span><span class=n>FunctionTestCase</span><span class=p>(</span><span class=n>testSomething</span><span class=p>,</span>
                                     <span class=n>setUp</span><span class=o>=</span><span class=n>makeSomethingDB</span><span class=p>,</span>
                                     <span class=n>tearDown</span><span class=o>=</span><span class=n>deleteSomethingDB</span><span class=p>)</span>
</pre></div>
</div>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>尽管 <a class="reference internal" href=#unittest.FunctionTestCase title=unittest.FunctionTestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>FunctionTestCase</span></code></a> 可用于快速将现有测试库转换为 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> -基于系统，不建议使用这种方法。花时间来设置适当的 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 子类将使未来的测试重构变得极其容易。</p>
</div>
<p>在某些情况下，现有测试可能是使用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/doctest.html#module-doctest title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class=pre>doctest</span></code></a> 模块。如果是这样， <a class="reference internal" href=https://www.osgeo.cn/cpython/library/doctest.html#module-doctest title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class=pre>doctest</span></code></a> 提供了一个 <code class="xref py py-class docutils literal notranslate"><span class=pre>DocTestSuite</span></code> 可以自动生成的类 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>unittest.TestSuite</span></code></a> 现有的实例 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/doctest.html#module-doctest title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class=pre>doctest</span></code></a> 基于测试。</p>
</div>
<div class=section id=skipping-tests-and-expected-failures>
<span id=unittest-skipping></span><h2>跳过测试和预期失败<a class=headerlink href=#skipping-tests-and-expected-failures title=永久链接至标题>¶</a></h2>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
<p>UnitTest支持跳过单个测试方法，甚至跳过整个测试类。此外，它还支持将测试标记为“预期失败”，即破坏并将失败的测试，但不应计为 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> .</p>
<p>跳过测试只是使用 <a class="reference internal" href=#unittest.skip title=unittest.skip><code class="xref py py-func docutils literal notranslate"><span class=pre>skip()</span></code></a> <a class="reference internal" href=https://www.osgeo.cn/cpython/glossary.html#term-decorator><span class="xref std std-term">decorator</span></a> 或其条件变体之一，调用 <a class="reference internal" href=#unittest.TestCase.skipTest title=unittest.TestCase.skipTest><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestCase.skipTest()</span></code></a> 在一个 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 或试验方法，或提高 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> 直接。</p>
<p>基本跳过如下所示：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>class</span> <span class=nc>MyTestCase</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>

    <span class=nd>@unittest</span><span class=o>.</span><span class=n>skip</span><span class=p>(</span><span class=s2>"demonstrating skipping"</span><span class=p>)</span>
    <span class=k>def</span> <span class=nf>test_nothing</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>fail</span><span class=p>(</span><span class=s2>"shouldn't happen"</span><span class=p>)</span>

    <span class=nd>@unittest</span><span class=o>.</span><span class=n>skipIf</span><span class=p>(</span><span class=n>mylib</span><span class=o>.</span><span class=n>__version__</span> <span class=o>&lt;</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span>
                     <span class=s2>"not supported in this library version"</span><span class=p>)</span>
    <span class=k>def</span> <span class=nf>test_format</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=c1># Tests that work for only a certain version of the library.</span>
        <span class=k>pass</span>

    <span class=nd>@unittest</span><span class=o>.</span><span class=n>skipUnless</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>platform</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>"win"</span><span class=p>),</span> <span class=s2>"requires Windows"</span><span class=p>)</span>
    <span class=k>def</span> <span class=nf>test_windows_support</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=c1># windows specific testing code</span>
        <span class=k>pass</span>

    <span class=k>def</span> <span class=nf>test_maybe_skipped</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=n>external_resource_available</span><span class=p>():</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>skipTest</span><span class=p>(</span><span class=s2>"external resource not available"</span><span class=p>)</span>
        <span class=c1># test code that depends on the external resource</span>
        <span class=k>pass</span>
</pre></div>
</div>
<p>这是在详细模式下运行上述示例的输出：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>test_format</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>MyTestCase</span><span class=p>)</span> <span class=o>...</span> <span class=n>skipped</span> <span class=s1>'not supported in this library version'</span>
<span class=n>test_nothing</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>MyTestCase</span><span class=p>)</span> <span class=o>...</span> <span class=n>skipped</span> <span class=s1>'demonstrating skipping'</span>
<span class=n>test_maybe_skipped</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>MyTestCase</span><span class=p>)</span> <span class=o>...</span> <span class=n>skipped</span> <span class=s1>'external resource not available'</span>
<span class=n>test_windows_support</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>MyTestCase</span><span class=p>)</span> <span class=o>...</span> <span class=n>skipped</span> <span class=s1>'requires Windows'</span>

<span class=o>----------------------------------------------------------------------</span>
<span class=n>Ran</span> <span class=mi>4</span> <span class=n>tests</span> <span class=ow>in</span> <span class=mf>0.005</span><span class=n>s</span>

<span class=n>OK</span> <span class=p>(</span><span class=n>skipped</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
</pre></div>
</div>
<p>类可以像方法那样跳过：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@unittest</span><span class=o>.</span><span class=n>skip</span><span class=p>(</span><span class=s2>"showing class skipping"</span><span class=p>)</span>
<span class=k>class</span> <span class=nc>MySkippedTestCase</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>test_not_run</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>pass</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestCase.setUp()</span></code></a> 也可以跳过测试。当需要设置的资源不可用时，这很有用。</p>
<p>预期失败使用 <a class="reference internal" href=#unittest.expectedFailure title=unittest.expectedFailure><code class="xref py py-func docutils literal notranslate"><span class=pre>expectedFailure()</span></code></a> decorator。：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>class</span> <span class=nc>ExpectedFailureTestCase</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
    <span class=nd>@unittest</span><span class=o>.</span><span class=n>expectedFailure</span>
    <span class=k>def</span> <span class=nf>test_fail</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>"broken"</span><span class=p>)</span>
</pre></div>
</div>
<p>通过让一个调用 <a class="reference internal" href=#unittest.skip title=unittest.skip><code class="xref py py-func docutils literal notranslate"><span class=pre>skip()</span></code></a> 在测试中，当它希望跳过它时。此装饰器跳过测试，除非传递的对象具有特定属性：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>skipUnlessHasattr</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>attr</span><span class=p>):</span>
    <span class=k>if</span> <span class=nb>hasattr</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>attr</span><span class=p>):</span>
        <span class=k>return</span> <span class=k>lambda</span> <span class=n>func</span><span class=p>:</span> <span class=n>func</span>
    <span class=k>return</span> <span class=n>unittest</span><span class=o>.</span><span class=n>skip</span><span class=p>(</span><span class=s2>"</span><span class=si>{!r}</span><span class=s2> doesn't have </span><span class=si>{!r}</span><span class=s2>"</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>attr</span><span class=p>))</span>
</pre></div>
</div>
<p>以下修饰符和异常实现测试跳过和预期的失败：</p>
<dl class=function>
<dt id=unittest.skip>
<code class="sig-prename descclassname">@</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skip</code><span class=sig-paren>(</span><em class=sig-param>reason</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.skip title=永久链接至目标>¶</a></dt>
<dd><p>无条件跳过修饰测试。 <em>原因</em> 应描述跳过测试的原因。</p>
</dl>
<dl class=function>
<dt id=unittest.skipIf>
<code class="sig-prename descclassname">@</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skipIf</code><span class=sig-paren>(</span><em class=sig-param>condition</em>, <em class=sig-param>reason</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.skipIf title=永久链接至目标>¶</a></dt>
<dd><p>如果 <em>条件</em> 是真的。</p>
</dl>
<dl class=function>
<dt id=unittest.skipUnless>
<code class="sig-prename descclassname">@</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skipUnless</code><span class=sig-paren>(</span><em class=sig-param>condition</em>, <em class=sig-param>reason</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.skipUnless title=永久链接至目标>¶</a></dt>
<dd><p>跳过装饰测试，除非 <em>条件</em> 是真的。</p>
</dl>
<dl class=function>
<dt id=unittest.expectedFailure>
<code class="sig-prename descclassname">@</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">expectedFailure</code><a class=headerlink href=#unittest.expectedFailure title=永久链接至目标>¶</a></dt>
<dd><p>将测试标记为预期失败。如果测试失败，则视为成功。如果测试通过，则视为失败。</p>
</dl>
<dl class=exception>
<dt id=unittest.SkipTest>
<em class=property>exception </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">SkipTest</code><span class=sig-paren>(</span><em class=sig-param>reason</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.SkipTest title=永久链接至目标>¶</a></dt>
<dd><p>引发此异常以跳过测试。</p>
<p>通常你可以用 <a class="reference internal" href=#unittest.TestCase.skipTest title=unittest.TestCase.skipTest><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestCase.skipTest()</span></code></a> 或者一个跳过装饰的人，而不是直接提出这个问题。</p>
</dl>
<p>跳过的测试将不会 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 或 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 绕着他们运行。跳过的类将没有 <a class="reference internal" href=#unittest.TestCase.setUpClass title=unittest.TestCase.setUpClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUpClass()</span></code></a> 或 <a class="reference internal" href=#unittest.TestCase.tearDownClass title=unittest.TestCase.tearDownClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDownClass()</span></code></a> 运行。跳过的模块将没有 <code class="xref py py-func docutils literal notranslate"><span class=pre>setUpModule()</span></code> 或 <code class="xref py py-func docutils literal notranslate"><span class=pre>tearDownModule()</span></code> 运行。</p>
</div>
<div class=section id=distinguishing-test-iterations-using-subtests>
<span id=subtests></span><h2>使用子测试区分测试迭代<a class=headerlink href=#distinguishing-test-iterations-using-subtests title=永久链接至标题>¶</a></h2>
<div class=versionadded>
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<p>当测试之间存在非常小的差异时，例如某些参数，UnitTest允许您使用 <a class="reference internal" href=#unittest.TestCase.subTest title=unittest.TestCase.subTest><code class="xref py py-meth docutils literal notranslate"><span class=pre>subTest()</span></code></a> 上下文管理器。</p>
<p>例如，以下测试：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>class</span> <span class=nc>NumbersTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>

    <span class=k>def</span> <span class=nf>test_even</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=sd>"""</span>
<span class=sd>        Test that numbers between 0 and 5 are all even.</span>
<span class=sd>        """</span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>6</span><span class=p>):</span>
            <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>subTest</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=n>i</span><span class=p>):</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</pre></div>
</div>
<p>将产生以下输出：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=o>======================================================================</span>
<span class=n>FAIL</span><span class=p>:</span> <span class=n>test_even</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>NumbersTest</span><span class=p>)</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
<span class=o>----------------------------------------------------------------------</span>
<span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
  <span class=n>File</span> <span class=s2>"subtests.py"</span><span class=p>,</span> <span class=n>line</span> <span class=mi>32</span><span class=p>,</span> <span class=ow>in</span> <span class=n>test_even</span>
    <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
<span class=ne>AssertionError</span><span class=p>:</span> <span class=mi>1</span> <span class=o>!=</span> <span class=mi>0</span>

<span class=o>======================================================================</span>
<span class=n>FAIL</span><span class=p>:</span> <span class=n>test_even</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>NumbersTest</span><span class=p>)</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=o>----------------------------------------------------------------------</span>
<span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
  <span class=n>File</span> <span class=s2>"subtests.py"</span><span class=p>,</span> <span class=n>line</span> <span class=mi>32</span><span class=p>,</span> <span class=ow>in</span> <span class=n>test_even</span>
    <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
<span class=ne>AssertionError</span><span class=p>:</span> <span class=mi>1</span> <span class=o>!=</span> <span class=mi>0</span>

<span class=o>======================================================================</span>
<span class=n>FAIL</span><span class=p>:</span> <span class=n>test_even</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>NumbersTest</span><span class=p>)</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
<span class=o>----------------------------------------------------------------------</span>
<span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
  <span class=n>File</span> <span class=s2>"subtests.py"</span><span class=p>,</span> <span class=n>line</span> <span class=mi>32</span><span class=p>,</span> <span class=ow>in</span> <span class=n>test_even</span>
    <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
<span class=ne>AssertionError</span><span class=p>:</span> <span class=mi>1</span> <span class=o>!=</span> <span class=mi>0</span>
</pre></div>
</div>
<p>如果不使用子测试，执行将在第一次失败后停止，并且错误不太容易诊断，因为 <code class="docutils literal notranslate"><span class=pre>i</span></code> 不会显示：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=o>======================================================================</span>
<span class=n>FAIL</span><span class=p>:</span> <span class=n>test_even</span> <span class=p>(</span><span class=n>__main__</span><span class=o>.</span><span class=n>NumbersTest</span><span class=p>)</span>
<span class=o>----------------------------------------------------------------------</span>
<span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
  <span class=n>File</span> <span class=s2>"subtests.py"</span><span class=p>,</span> <span class=n>line</span> <span class=mi>32</span><span class=p>,</span> <span class=ow>in</span> <span class=n>test_even</span>
    <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
<span class=ne>AssertionError</span><span class=p>:</span> <span class=mi>1</span> <span class=o>!=</span> <span class=mi>0</span>
</pre></div>
</div>
</div>
<div class=section id=classes-and-functions>
<span id=unittest-contents></span><h2>类和函数<a class=headerlink href=#classes-and-functions title=永久链接至标题>¶</a></h2>
<p>本节详细介绍了 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> .</p>
<div class=section id=test-cases>
<span id=testcase-objects></span><h3>测试用例<a class=headerlink href=#test-cases title=永久链接至标题>¶</a></h3>
<dl class=class>
<dt id=unittest.TestCase>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestCase</code><span class=sig-paren>(</span><em class=sig-param>methodName='runTest'</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase title=永久链接至目标>¶</a></dt>
<dd><p>的实例 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 类表示中的逻辑测试单元 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 宇宙。这个类被用作一个基类，具体的测试由具体的子类实现。这个类实现了测试运行程序所需的接口，以允许它驱动测试，以及测试代码可以用来检查和报告各种失败的方法。</p>
<p>的每个实例 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 将运行单个基方法：名为 <em>调用的方法名</em> . 在大多数用途中 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 你也不会改变 <em>调用的方法名</em> 也不重新履行违约 <code class="docutils literal notranslate"><span class=pre>runTest()</span></code> 方法。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span><a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 可以在不提供 <em>调用的方法名</em> . 这使得试验更容易 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 来自交互式解释器。</p>
</div>
<p><a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 实例提供三组方法：一组用于运行测试，另一组用于测试实现检查条件和报告失败，以及一些查询方法，允许收集有关测试本身的信息。</p>
<p>第一组（运行测试）中的方法是：</p>
<dl class=method>
<dt id=unittest.TestCase.setUp>
<code class="sig-name descname">setUp</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.setUp title=永久链接至目标>¶</a></dt>
<dd><p>方法来准备测试夹具。这是在调用测试方法之前立即调用的；而不是 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> 或 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> ，此方法引发的任何异常都将被视为错误而不是测试失败。默认实现什么也不做。</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.tearDown>
<code class="sig-name descname">tearDown</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.tearDown title=永久链接至目标>¶</a></dt>
<dd><p>方法在调用测试方法并记录结果后立即调用。即使测试方法引发了异常，也会调用此方法，因此子类中的实现可能需要特别注意检查内部状态。任何例外，除了 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> 或 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> ，由此方法引发的将被视为额外的错误，而不是测试失败（从而增加报告的错误总数）。只有在 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 不管测试方法的结果如何，都会成功。默认实现什么也不做。</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.setUpClass>
<code class="sig-name descname">setUpClass</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.setUpClass title=永久链接至目标>¶</a></dt>
<dd><p>在运行单个类中的测试之前调用的类方法。 <code class="docutils literal notranslate"><span class=pre>setUpClass</span></code> 以类作为唯一参数调用，并且必须作为 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#classmethod title=classmethod><code class="xref py py-func docutils literal notranslate"><span class=pre>classmethod()</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@classmethod</span>
<span class=k>def</span> <span class=nf>setUpClass</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
    <span class=o>...</span>
</pre></div>
</div>
<p>见 <a class="reference internal" href=#class-and-module-fixtures>Class and Module Fixtures</a> 了解更多详细信息。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.tearDownClass>
<code class="sig-name descname">tearDownClass</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.tearDownClass title=永久链接至目标>¶</a></dt>
<dd><p>在单个类中的测试运行后调用的类方法。 <code class="docutils literal notranslate"><span class=pre>tearDownClass</span></code> 以类作为唯一参数调用，并且必须作为 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#classmethod title=classmethod><code class="xref py py-meth docutils literal notranslate"><span class=pre>classmethod()</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@classmethod</span>
<span class=k>def</span> <span class=nf>tearDownClass</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
    <span class=o>...</span>
</pre></div>
</div>
<p>见 <a class="reference internal" href=#class-and-module-fixtures>Class and Module Fixtures</a> 了解更多详细信息。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.run>
<code class="sig-name descname">run</code><span class=sig-paren>(</span><em class=sig-param>result=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.run title=永久链接至目标>¶</a></dt>
<dd><p>运行测试，将结果收集到 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 对象传递为 <em>结果</em> . 如果 <em>结果</em> 被省略或 <code class="docutils literal notranslate"><span class=pre>None</span></code> ，将创建一个临时结果对象（通过调用 <a class="reference internal" href=#unittest.TestCase.defaultTestResult title=unittest.TestCase.defaultTestResult><code class="xref py py-meth docutils literal notranslate"><span class=pre>defaultTestResult()</span></code></a> 方法）和使用。结果对象返回到 <a class="reference internal" href=#unittest.TestCase.run title=unittest.TestCase.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>run()</span></code></a> 调用的人</p>
<p>同样的效果也可以通过简单地调用 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 实例。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.3 版更改: </span>以前版本的 <code class="docutils literal notranslate"><span class=pre>run</span></code> 没有返回结果。也没有调用实例。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.skipTest>
<code class="sig-name descname">skipTest</code><span class=sig-paren>(</span><em class=sig-param>reason</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.skipTest title=永久链接至目标>¶</a></dt>
<dd><p>在测试方法或 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 跳过当前测试。见 <a class="reference internal" href=#unittest-skipping><span class="std std-ref">跳过测试和预期失败</span></a> 更多信息。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.subTest>
<code class="sig-name descname">subTest</code><span class=sig-paren>(</span><em class=sig-param>msg=None</em>, <em class=sig-param>**params</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.subTest title=永久链接至目标>¶</a></dt>
<dd><p>返回一个上下文管理器，该管理器将封闭的代码块作为子测试执行。 <em>msg</em> 和 <em>帕拉姆</em> 是可选的、任意的值，在子测试失败时显示，允许您清楚地识别它们。</p>
<p>测试用例可以包含任意数量的子测试声明，并且可以任意嵌套。</p>
<p>见 <a class="reference internal" href=#subtests><span class="std std-ref">使用子测试区分测试迭代</span></a> 更多信息。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.debug>
<code class="sig-name descname">debug</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.debug title=永久链接至目标>¶</a></dt>
<dd><p>运行测试而不收集结果。这允许将测试引发的异常传播到调用方，并可用于支持在调试器下运行测试。</p>
</dl>
<p id=assert-methods>这个 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 类提供了几个断言方法来检查和报告失败。下表列出了最常用的方法（有关更多断言方法，请参阅下表）：</p>
<table class="docutils align-default">
<colgroup>
<col style=width:48%>
<col style=width:34%>
<col style=width:18%>
</colgroup>
<thead>
<tr class=row-odd><th class=head><p>方法</p></th>
<th class=head><p>检查一下</p></th>
<th class=head><p>新在</p></th>
</tr>
</thead>
<tbody>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>==</span> <span class=pre>b</span></code></p></td>
<td></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertNotEqual title=unittest.TestCase.assertNotEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>!=</span> <span class=pre>b</span></code></p></td>
<td></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertTrue title=unittest.TestCase.assertTrue><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertTrue(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>bool(x)</span> <span class=pre>is</span> <span class=pre>True</span></code></p></td>
<td></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertFalse title=unittest.TestCase.assertFalse><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertFalse(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>bool(x)</span> <span class=pre>is</span> <span class=pre>False</span></code></p></td>
<td></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertIs title=unittest.TestCase.assertIs><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertIs(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>is</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertIsNot title=unittest.TestCase.assertIsNot><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertIsNot(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>is</span> <span class=pre>not</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertIsNone title=unittest.TestCase.assertIsNone><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertIsNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>x</span> <span class=pre>is</span> <span class=pre>None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertIsNotNone title=unittest.TestCase.assertIsNotNone><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertIsNotNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>x</span> <span class=pre>is</span> <span class=pre>not</span> <span class=pre>None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertIn title=unittest.TestCase.assertIn><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertIn(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>in</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertNotIn title=unittest.TestCase.assertNotIn><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotIn(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>not</span> <span class=pre>in</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertIsInstance title=unittest.TestCase.assertIsInstance><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertIsInstance(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>isinstance(a,</span> <span class=pre>b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertNotIsInstance title=unittest.TestCase.assertNotIsInstance><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotIsInstance(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>not</span> <span class=pre>isinstance(a,</span> <span class=pre>b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<p>所有的断言方法都接受 <em>msg</em> 参数，如果指定，则用作失败时的错误消息（另请参见 <a class="reference internal" href=#unittest.TestCase.longMessage title=unittest.TestCase.longMessage><code class="xref py py-data docutils literal notranslate"><span class=pre>longMessage</span></code></a> ）。注意， <em>msg</em> 关键字参数不能传递给 <a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a> ， <a class="reference internal" href=#unittest.TestCase.assertRaisesRegex title=unittest.TestCase.assertRaisesRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaisesRegex()</span></code></a> ， <a class="reference internal" href=#unittest.TestCase.assertWarns title=unittest.TestCase.assertWarns><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarns()</span></code></a> ， <a class="reference internal" href=#unittest.TestCase.assertWarnsRegex title=unittest.TestCase.assertWarnsRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarnsRegex()</span></code></a> 仅当它们用作上下文管理器时。</p>
<dl class=method>
<dt id=unittest.TestCase.assertEqual>
<code class="sig-name descname">assertEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>第一</em> 和 <em>第二</em> 一律平等。如果比较值不相等，测试将失败。</p>
<p>此外，如果 <em>第一</em> 和 <em>第二</em> 与list、tuple、dict、set、frozenset或str类型完全相同，还是子类注册的任何类型 <a class="reference internal" href=#unittest.TestCase.addTypeEqualityFunc title=unittest.TestCase.addTypeEqualityFunc><code class="xref py py-meth docutils literal notranslate"><span class=pre>addTypeEqualityFunc()</span></code></a> 将调用特定于类型的相等函数，以生成更有用的默认错误消息（另请参见 <a class="reference internal" href=#type-specific-methods><span class="std std-ref">list of type-specific methods</span></a> ）</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.1 版更改: </span>添加了类型特定相等函数的自动调用。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span><a class="reference internal" href=#unittest.TestCase.assertMultiLineEqual title=unittest.TestCase.assertMultiLineEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertMultiLineEqual()</span></code></a> 添加为用于比较字符串的默认类型相等函数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertNotEqual>
<code class="sig-name descname">assertNotEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertNotEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>第一</em> 和 <em>第二</em> 不相等。如果比较值相等，测试将失败。</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertTrue>
<code class="sig-name descname">assertTrue</code><span class=sig-paren>(</span><em class=sig-param>expr</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertTrue title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertFalse>
<code class="sig-name descname">assertFalse</code><span class=sig-paren>(</span><em class=sig-param>expr</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertFalse title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>expr</em> 为真（或假）。</p>
<p>注意这相当于 <code class="docutils literal notranslate"><span class=pre>bool(expr)</span> <span class=pre>is</span> <span class=pre>True</span></code> 而不是 <code class="docutils literal notranslate"><span class=pre>expr</span> <span class=pre>is</span> <span class=pre>True</span></code> （使用） <code class="docutils literal notranslate"><span class=pre>assertIs(expr,</span> <span class=pre>True)</span></code> 对于后者）。当有更具体的方法（例如 <code class="docutils literal notranslate"><span class=pre>assertEqual(a,</span> <span class=pre>b)</span></code> 而不是 <code class="docutils literal notranslate"><span class=pre>assertTrue(a</span> <span class=pre>==</span> <span class=pre>b)</span></code> ，因为它们在发生故障时提供更好的错误消息。</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertIs>
<code class="sig-name descname">assertIs</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertIs title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertIsNot>
<code class="sig-name descname">assertIsNot</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertIsNot title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>第一</em> 和 <em>第二</em> 对同一对象进行评估（或不进行评估）。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertIsNone>
<code class="sig-name descname">assertIsNone</code><span class=sig-paren>(</span><em class=sig-param>expr</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertIsNone title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertIsNotNone>
<code class="sig-name descname">assertIsNotNone</code><span class=sig-paren>(</span><em class=sig-param>expr</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertIsNotNone title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>expr</em> 是（或不是） <code class="docutils literal notranslate"><span class=pre>None</span></code> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertIn>
<code class="sig-name descname">assertIn</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertIn title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertNotIn>
<code class="sig-name descname">assertNotIn</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertNotIn title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>第一</em> 是否在 <em>第二</em> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertIsInstance>
<code class="sig-name descname">assertIsInstance</code><span class=sig-paren>(</span><em class=sig-param>obj</em>, <em class=sig-param>cls</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertIsInstance title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertNotIsInstance>
<code class="sig-name descname">assertNotIsInstance</code><span class=sig-paren>(</span><em class=sig-param>obj</em>, <em class=sig-param>cls</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertNotIsInstance title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>obj</em> 是（或不是）的实例 <em>cls</em> （可以是类或类的元组，由 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> ）要检查确切类型，请使用 <a class="reference internal" href=#unittest.TestCase.assertIs title=unittest.TestCase.assertIs><code class="xref py py-func docutils literal notranslate"><span class=pre>assertIs(type(obj),</span> <span class=pre>cls)</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<p>还可以使用以下方法检查异常、警告和日志消息的生成：</p>
<table class="docutils align-default">
<colgroup>
<col style=width:53%>
<col style=width:36%>
<col style=width:11%>
</colgroup>
<thead>
<tr class=row-odd><th class=head><p>方法</p></th>
<th class=head><p>检查一下</p></th>
<th class=head><p>新在</p></th>
</tr>
</thead>
<tbody>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises(exc,</span> <span class=pre>fun,</span> <span class=pre>*args,</span> <span class=pre>**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>fun(*args,</span> <span class=pre>**kwds)</span></code> 引发 <em>exc</em></p></td>
<td></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertRaisesRegex title=unittest.TestCase.assertRaisesRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaisesRegex(exc,</span> <span class=pre>r,</span> <span class=pre>fun,</span> <span class=pre>*args,</span> <span class=pre>**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>fun(*args,</span> <span class=pre>**kwds)</span></code> 引发 <em>exc</em> 消息与regex匹配 <em>r</em></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertWarns title=unittest.TestCase.assertWarns><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarns(warn,</span> <span class=pre>fun,</span> <span class=pre>*args,</span> <span class=pre>**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>fun(*args,</span> <span class=pre>**kwds)</span></code> 引发 <em>warn</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertWarnsRegex title=unittest.TestCase.assertWarnsRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarnsRegex(warn,</span> <span class=pre>r,</span> <span class=pre>fun,</span> <span class=pre>*args,</span> <span class=pre>**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>fun(*args,</span> <span class=pre>**kwds)</span></code> 引发 <em>warn</em> 消息与regex匹配 <em>r</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertLogs title=unittest.TestCase.assertLogs><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertLogs(logger,</span> <span class=pre>level)</span></code></a></p></td>
<td><p>这个 <code class="docutils literal notranslate"><span class=pre>with</span></code> 块日志 <em>logger</em> 以最小 <em>level</em></p></td>
<td><p>3.4</p></td>
</tr>
</tbody>
</table>
<dl class=method>
<dt id=unittest.TestCase.assertRaises>
<code class="sig-name descname">assertRaises</code><span class=sig-paren>(</span><em class=sig-param>exception</em>, <em class=sig-param>callable</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwds</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertRaises title=永久链接至目标>¶</a></dt>
<dt>
<code class="sig-name descname">assertRaises</code><span class=sig-paren>(</span><em class=sig-param>exception</em>, <em class=sig-param>*</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span></dt>
<dd><p>测试在以下情况下引发异常： <em>可赎回的</em> 使用还传递给 <a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a> . 如果 <em>exception</em> 如果引发另一个异常，则为错误；如果未引发异常，则为失败。要捕获一组异常中的任何一个，包含异常类的元组可以作为 <em>exception</em> .</p>
<p>如果只有 <em>exception</em> 可能还有 <em>msg</em> 给出了参数，返回一个上下文管理器，以便测试中的代码可以内联写入，而不是作为函数写入：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertRaises</span><span class=p>(</span><span class=n>SomeException</span><span class=p>):</span>
    <span class=n>do_something</span><span class=p>()</span>
</pre></div>
</div>
<p>当用作上下文管理器时， <a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a> 接受附加关键字参数 <em>msg</em> .</p>
<p>上下文管理器将捕获的异常对象存储在其 <code class="xref py py-attr docutils literal notranslate"><span class=pre>exception</span></code> 属性。如果打算对引发的异常执行其他检查，这可能很有用：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertRaises</span><span class=p>(</span><span class=n>SomeException</span><span class=p>)</span> <span class=k>as</span> <span class=n>cm</span><span class=p>:</span>
    <span class=n>do_something</span><span class=p>()</span>

<span class=n>the_exception</span> <span class=o>=</span> <span class=n>cm</span><span class=o>.</span><span class=n>exception</span>
<span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>the_exception</span><span class=o>.</span><span class=n>error_code</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.1 版更改: </span>增加了使用的能力 <a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a> 作为上下文管理器。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <code class="xref py py-attr docutils literal notranslate"><span class=pre>exception</span></code> 属性。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 用作上下文管理器时的关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertRaisesRegex>
<code class="sig-name descname">assertRaisesRegex</code><span class=sig-paren>(</span><em class=sig-param>exception</em>, <em class=sig-param>regex</em>, <em class=sig-param>callable</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwds</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertRaisesRegex title=永久链接至目标>¶</a></dt>
<dt>
<code class="sig-name descname">assertRaisesRegex</code><span class=sig-paren>(</span><em class=sig-param>exception</em>, <em class=sig-param>regex</em>, <em class=sig-param>*</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span></dt>
<dd><p>类似于 <a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a> 但也要测试一下 <em>正则表达式</em> 在引发的异常的字符串表示形式上匹配。 <em>正则表达式</em> 可以是正则表达式对象，也可以是包含适合于使用的正则表达式的字符串 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/re.html#re.search title=re.search><code class="xref py py-func docutils literal notranslate"><span class=pre>re.search()</span></code></a> . 实例：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=bp>self</span><span class=o>.</span><span class=n>assertRaisesRegex</span><span class=p>(</span><span class=ne>ValueError</span><span class=p>,</span> <span class=s2>"invalid literal for.*XYZ'$"</span><span class=p>,</span>
                       <span class=nb>int</span><span class=p>,</span> <span class=s1>'XYZ'</span><span class=p>)</span>
</pre></div>
</div>
<p>或：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertRaisesRegex</span><span class=p>(</span><span class=ne>ValueError</span><span class=p>,</span> <span class=s1>'literal'</span><span class=p>):</span>
   <span class=nb>int</span><span class=p>(</span><span class=s1>'XYZ'</span><span class=p>)</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能: </span>在名称下添加 <code class="docutils literal notranslate"><span class=pre>assertRaisesRegexp</span></code> .</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>命名至 <a class="reference internal" href=#unittest.TestCase.assertRaisesRegex title=unittest.TestCase.assertRaisesRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaisesRegex()</span></code></a> .</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 用作上下文管理器时的关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertWarns>
<code class="sig-name descname">assertWarns</code><span class=sig-paren>(</span><em class=sig-param>warning</em>, <em class=sig-param>callable</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwds</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertWarns title=永久链接至目标>¶</a></dt>
<dt>
<code class="sig-name descname">assertWarns</code><span class=sig-paren>(</span><em class=sig-param>warning</em>, <em class=sig-param>*</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span></dt>
<dd><p>测试在以下情况下是否触发警告： <em>可赎回的</em> 使用还传递给 <a class="reference internal" href=#unittest.TestCase.assertWarns title=unittest.TestCase.assertWarns><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarns()</span></code></a> . 如果 <em>警告</em> 如果不是，则触发并失败。任何异常都是错误。要捕获任何一组警告，可以将包含警告类的元组作为 <em>警告</em> .</p>
<p>如果只有 <em>警告</em> 可能还有 <em>msg</em> 给出了参数，返回一个上下文管理器，以便测试中的代码可以内联写入，而不是作为函数写入：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertWarns</span><span class=p>(</span><span class=n>SomeWarning</span><span class=p>):</span>
    <span class=n>do_something</span><span class=p>()</span>
</pre></div>
</div>
<p>当用作上下文管理器时， <a class="reference internal" href=#unittest.TestCase.assertWarns title=unittest.TestCase.assertWarns><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarns()</span></code></a> 接受附加关键字参数 <em>msg</em> .</p>
<p>上下文管理器将在其 <code class="xref py py-attr docutils literal notranslate"><span class=pre>warning</span></code> 属性，以及在中触发警告的源行 <code class="xref py py-attr docutils literal notranslate"><span class=pre>filename</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class=pre>lineno</span></code> 属性。如果打算对捕获的警告执行附加检查，这可能很有用：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertWarns</span><span class=p>(</span><span class=n>SomeWarning</span><span class=p>)</span> <span class=k>as</span> <span class=n>cm</span><span class=p>:</span>
    <span class=n>do_something</span><span class=p>()</span>

<span class=bp>self</span><span class=o>.</span><span class=n>assertIn</span><span class=p>(</span><span class=s1>'myfile.py'</span><span class=p>,</span> <span class=n>cm</span><span class=o>.</span><span class=n>filename</span><span class=p>)</span>
<span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=mi>320</span><span class=p>,</span> <span class=n>cm</span><span class=o>.</span><span class=n>lineno</span><span class=p>)</span>
</pre></div>
</div>
<p>此方法在调用时，不管是否存在警告筛选器，都可以工作。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 用作上下文管理器时的关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertWarnsRegex>
<code class="sig-name descname">assertWarnsRegex</code><span class=sig-paren>(</span><em class=sig-param>warning</em>, <em class=sig-param>regex</em>, <em class=sig-param>callable</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwds</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertWarnsRegex title=永久链接至目标>¶</a></dt>
<dt>
<code class="sig-name descname">assertWarnsRegex</code><span class=sig-paren>(</span><em class=sig-param>warning</em>, <em class=sig-param>regex</em>, <em class=sig-param>*</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span></dt>
<dd><p>类似于 <a class="reference internal" href=#unittest.TestCase.assertWarns title=unittest.TestCase.assertWarns><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertWarns()</span></code></a> 但也要测试一下 <em>正则表达式</em> 匹配已触发警告的消息。 <em>正则表达式</em> 可以是正则表达式对象，也可以是包含适合于使用的正则表达式的字符串 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/re.html#re.search title=re.search><code class="xref py py-func docutils literal notranslate"><span class=pre>re.search()</span></code></a> .例子：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=bp>self</span><span class=o>.</span><span class=n>assertWarnsRegex</span><span class=p>(</span><span class=ne>DeprecationWarning</span><span class=p>,</span>
                      <span class=sa>r</span><span class=s1>'legacy_function\(\) is deprecated'</span><span class=p>,</span>
                      <span class=n>legacy_function</span><span class=p>,</span> <span class=s1>'XYZ'</span><span class=p>)</span>
</pre></div>
</div>
<p>或：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertWarnsRegex</span><span class=p>(</span><span class=ne>RuntimeWarning</span><span class=p>,</span> <span class=s1>'unsafe frobnicating'</span><span class=p>):</span>
    <span class=n>frobnicate</span><span class=p>(</span><span class=s1>'/etc/passwd'</span><span class=p>)</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.3 版更改: </span>增加了 <em>msg</em> 用作上下文管理器时的关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertLogs>
<code class="sig-name descname">assertLogs</code><span class=sig-paren>(</span><em class=sig-param>logger=None</em>, <em class=sig-param>level=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertLogs title=永久链接至目标>¶</a></dt>
<dd><p>一个上下文管理器，用于测试是否至少有一条消息登录到 <em>logger</em> 或者它的一个子项，至少 <em>level</em> .</p>
<p>如果给出的话， <em>logger</em> 应该是 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/logging.html#logging.Logger title=logging.Logger><code class="xref py py-class docutils literal notranslate"><span class=pre>logging.Logger</span></code></a> 对象或 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/stdtypes.html#str title=str><code class="xref py py-class docutils literal notranslate"><span class=pre>str</span></code></a> 给出记录器的名称。默认值是根记录器，它将捕获所有消息。</p>
<p>如果给出的话， <em>level</em> 应为数字日志记录级别或其等效字符串（例如 <code class="docutils literal notranslate"><span class=pre>"ERROR"</span></code> 或 <code class="xref py py-attr docutils literal notranslate"><span class=pre>logging.ERROR</span></code> ）默认值为 <code class="xref py py-attr docutils literal notranslate"><span class=pre>logging.INFO</span></code> .</p>
<p>如果至少有一条消息在 <code class="docutils literal notranslate"><span class=pre>with</span></code> 块匹配 <em>logger</em> 和 <em>level</em> 条件，否则失败。</p>
<p>上下文管理器返回的对象是一个记录助手，用于跟踪匹配的日志消息。它有两个属性：</p>
<dl class=attribute>
<dt id=unittest.TestCase.records>
<code class="sig-name descname">records</code><a class=headerlink href=#unittest.TestCase.records title=永久链接至目标>¶</a></dt>
<dd><p>列表 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/logging.html#logging.LogRecord title=logging.LogRecord><code class="xref py py-class docutils literal notranslate"><span class=pre>logging.LogRecord</span></code></a> 匹配日志消息的对象。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestCase.output>
<code class="sig-name descname">output</code><a class=headerlink href=#unittest.TestCase.output title=永久链接至目标>¶</a></dt>
<dd><p>列表 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/stdtypes.html#str title=str><code class="xref py py-class docutils literal notranslate"><span class=pre>str</span></code></a> 具有匹配消息的格式化输出的对象。</p>
</dl>
<p>例子：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>assertLogs</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>level</span><span class=o>=</span><span class=s1>'INFO'</span><span class=p>)</span> <span class=k>as</span> <span class=n>cm</span><span class=p>:</span>
   <span class=n>logging</span><span class=o>.</span><span class=n>getLogger</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=s1>'first message'</span><span class=p>)</span>
   <span class=n>logging</span><span class=o>.</span><span class=n>getLogger</span><span class=p>(</span><span class=s1>'foo.bar'</span><span class=p>)</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=s1>'second message'</span><span class=p>)</span>
<span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>cm</span><span class=o>.</span><span class=n>output</span><span class=p>,</span> <span class=p>[</span><span class=s1>'INFO:foo:first message'</span><span class=p>,</span>
                             <span class=s1>'ERROR:foo.bar:second message'</span><span class=p>])</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dl>
<p>还可以使用其他方法执行更具体的检查，例如：</p>
<table class="docutils align-default">
<colgroup>
<col style=width:46%>
<col style=width:38%>
<col style=width:16%>
</colgroup>
<thead>
<tr class=row-odd><th class=head><p>方法</p></th>
<th class=head><p>检查一下</p></th>
<th class=head><p>新在</p></th>
</tr>
</thead>
<tbody>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertAlmostEqual title=unittest.TestCase.assertAlmostEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertAlmostEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>round(a-b,</span> <span class=pre>7)</span> <span class=pre>==</span> <span class=pre>0</span></code></p></td>
<td></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertNotAlmostEqual title=unittest.TestCase.assertNotAlmostEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotAlmostEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>round(a-b,</span> <span class=pre>7)</span> <span class=pre>!=</span> <span class=pre>0</span></code></p></td>
<td></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertGreater title=unittest.TestCase.assertGreater><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertGreater(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>&gt;</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertGreaterEqual title=unittest.TestCase.assertGreaterEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertGreaterEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>&gt;=</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertLess title=unittest.TestCase.assertLess><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertLess(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>&lt;</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertLessEqual title=unittest.TestCase.assertLessEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertLessEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>a</span> <span class=pre>&lt;=</span> <span class=pre>b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertRegex title=unittest.TestCase.assertRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRegex(s,</span> <span class=pre>r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>r.search(s)</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertNotRegex title=unittest.TestCase.assertNotRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotRegex(s,</span> <span class=pre>r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class=pre>not</span> <span class=pre>r.search(s)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertCountEqual title=unittest.TestCase.assertCountEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertCountEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p><em>a</em> 和 <em>b</em> 不管元素的顺序如何，在同一个数字中具有相同的元素。</p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<dl class=method>
<dt id=unittest.TestCase.assertAlmostEqual>
<code class="sig-name descname">assertAlmostEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>places=7</em>, <em class=sig-param>msg=None</em>, <em class=sig-param>delta=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertAlmostEqual title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertNotAlmostEqual>
<code class="sig-name descname">assertNotAlmostEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>places=7</em>, <em class=sig-param>msg=None</em>, <em class=sig-param>delta=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertNotAlmostEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>第一</em> 和 <em>第二</em> 通过计算差，四舍五入到给定的十进制数，近似（或不近似）相等 <em>地方</em> （默认为7），并与零进行比较。注意，这些方法将值四舍五入到给定的 <em>小数位数</em> （如 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#round title=round><code class="xref py py-func docutils literal notranslate"><span class=pre>round()</span></code></a> 功能）而非 <em>有效数字</em> .</p>
<p>如果 <em>三角洲</em> 提供而不是 <em>地方</em> 那么两者之间的区别 <em>第一</em> 和 <em>第二</em> 必须小于或等于（或大于） <em>三角洲</em> .</p>
<p>二者兼备 <em>三角洲</em> 和 <em>地方</em> 提高 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#TypeError title=TypeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>TypeError</span></code></a> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span><a class="reference internal" href=#unittest.TestCase.assertAlmostEqual title=unittest.TestCase.assertAlmostEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertAlmostEqual()</span></code></a> 自动考虑比较相等的几乎相等的对象。 <a class="reference internal" href=#unittest.TestCase.assertNotAlmostEqual title=unittest.TestCase.assertNotAlmostEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotAlmostEqual()</span></code></a> 如果对象比较相等，则自动失败。增加了 <em>三角洲</em> 关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertGreater>
<code class="sig-name descname">assertGreater</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertGreater title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertGreaterEqual>
<code class="sig-name descname">assertGreaterEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertGreaterEqual title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertLess>
<code class="sig-name descname">assertLess</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertLess title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertLessEqual>
<code class="sig-name descname">assertLessEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertLessEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试那个 <em>第一</em> 分别为&gt;、&gt;=、&lt;或&lt;=than <em>第二</em> 取决于方法名称。否则，测试将失败：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=bp>self</span><span class=o>.</span><span class=n>assertGreaterEqual</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=go>AssertionError: "3" unexpectedly not greater than or equal to "4"</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertRegex>
<code class="sig-name descname">assertRegex</code><span class=sig-paren>(</span><em class=sig-param>text</em>, <em class=sig-param>regex</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertRegex title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertNotRegex>
<code class="sig-name descname">assertNotRegex</code><span class=sig-paren>(</span><em class=sig-param>text</em>, <em class=sig-param>regex</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertNotRegex title=永久链接至目标>¶</a></dt>
<dd><p>测试A <em>正则表达式</em> 搜索匹配项（或不匹配） <em>text</em> . 如果失败，错误消息将包括模式和 <em>text</em> （或模式和 <em>text</em> 出乎意料的匹配）。 <em>正则表达式</em> 可以是正则表达式对象，也可以是包含适合于使用的正则表达式的字符串 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/re.html#re.search title=re.search><code class="xref py py-func docutils literal notranslate"><span class=pre>re.search()</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能: </span>在名称下添加 <code class="docutils literal notranslate"><span class=pre>assertRegexpMatches</span></code> .</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>方法 <code class="docutils literal notranslate"><span class=pre>assertRegexpMatches()</span></code> 已重命名为 <a class="reference internal" href=#unittest.TestCase.assertRegex title=unittest.TestCase.assertRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRegex()</span></code></a> .</p>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能: </span><a class="reference internal" href=#unittest.TestCase.assertNotRegex title=unittest.TestCase.assertNotRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotRegex()</span></code></a> .</p>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.5 新版功能: </span>名字 <code class="docutils literal notranslate"><span class=pre>assertNotRegexpMatches</span></code> 是的不推荐使用的别名 <a class="reference internal" href=#unittest.TestCase.assertNotRegex title=unittest.TestCase.assertNotRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotRegex()</span></code></a> .</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertCountEqual>
<code class="sig-name descname">assertCountEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertCountEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试那个序列 <em>第一</em> 包含的元素与 <em>第二</em> 不管他们的顺序如何。否则，将生成一条错误消息，列出序列之间的差异。</p>
<p>重复元素是 <em>not</em> 比较时忽略 <em>第一</em> 和 <em>第二</em> . 它验证两个序列中每个元素的计数是否相同。相当于： <code class="docutils literal notranslate"><span class=pre>assertEqual(Counter(list(first)),</span> <span class=pre>Counter(list(second)))</span></code> 但也适用于一系列不可清洗的物体。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<p id=type-specific-methods>这个 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> 方法将同一类型的对象的相等性检查分派给不同类型的特定方法。这些方法已经为大多数内置类型实现，但也可以使用 <a class="reference internal" href=#unittest.TestCase.addTypeEqualityFunc title=unittest.TestCase.addTypeEqualityFunc><code class="xref py py-meth docutils literal notranslate"><span class=pre>addTypeEqualityFunc()</span></code></a> ：</p>
<dl class=method>
<dt id=unittest.TestCase.addTypeEqualityFunc>
<code class="sig-name descname">addTypeEqualityFunc</code><span class=sig-paren>(</span><em class=sig-param>typeobj</em>, <em class=sig-param>function</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.addTypeEqualityFunc title=永久链接至目标>¶</a></dt>
<dd><p>注册由调用的特定于类型的方法 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> 检查两个对象是否完全相同 <em>Type Objo</em> （不是子类）比较相等。 <em>function</em> 必须采用两个位置参数和第三个msg=none关键字参数，就像 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> 做。必须提高 <a class="reference internal" href=#unittest.TestCase.failureException title=unittest.TestCase.failureException><code class="xref py py-data docutils literal notranslate"><span class=pre>self.failureException(msg)</span></code></a> 当检测到前两个参数之间的不等式时——可能会提供有用的信息，并在错误消息中详细解释这些不等式。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<p>自动使用的类型特定方法的列表 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> 总结如下表。注意，通常不需要直接调用这些方法。</p>
<table class="docutils align-default">
<colgroup>
<col style=width:49%>
<col style=width:35%>
<col style=width:17%>
</colgroup>
<thead>
<tr class=row-odd><th class=head><p>方法</p></th>
<th class=head><p>用于比较</p></th>
<th class=head><p>新在</p></th>
</tr>
</thead>
<tbody>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertMultiLineEqual title=unittest.TestCase.assertMultiLineEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertMultiLineEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p>字符串</p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertSequenceEqual title=unittest.TestCase.assertSequenceEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertSequenceEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p>序列</p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertListEqual title=unittest.TestCase.assertListEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertListEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p>列表</p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertTupleEqual title=unittest.TestCase.assertTupleEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertTupleEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p>元组</p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertSetEqual title=unittest.TestCase.assertSetEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertSetEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p>集合或冻结集合</p></td>
<td><p>3.1</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertDictEqual title=unittest.TestCase.assertDictEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertDictEqual(a,</span> <span class=pre>b)</span></code></a></p></td>
<td><p>迪茨</p></td>
<td><p>3.1</p></td>
</tr>
</tbody>
</table>
<dl class=method>
<dt id=unittest.TestCase.assertMultiLineEqual>
<code class="sig-name descname">assertMultiLineEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertMultiLineEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试多行字符串 <em>第一</em> 等于字符串 <em>第二</em> . 当不等于突出显示差异的两个字符串的diff时，错误消息中将包含差异。在将字符串与 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertSequenceEqual>
<code class="sig-name descname">assertSequenceEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em>, <em class=sig-param>seq_type=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertSequenceEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试两个序列是否相等。如果A <em>seq_type</em> 两者都提供 <em>第一</em> 和 <em>第二</em> 必须是的实例 <em>seq_type</em> 否则会引发故障。如果序列不同，则会构造一条错误消息，显示两者之间的差异。</p>
<p>此方法不是由直接调用的 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> 但是它被用来实现 <a class="reference internal" href=#unittest.TestCase.assertListEqual title=unittest.TestCase.assertListEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertListEqual()</span></code></a> 和 <a class="reference internal" href=#unittest.TestCase.assertTupleEqual title=unittest.TestCase.assertTupleEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertTupleEqual()</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertListEqual>
<code class="sig-name descname">assertListEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertListEqual title=永久链接至目标>¶</a></dt>
<dt id=unittest.TestCase.assertTupleEqual>
<code class="sig-name descname">assertTupleEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertTupleEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试两个列表或元组是否相等。如果不是，则构造一条错误消息，只显示两者之间的差异。如果其中一个参数的类型错误，也会引发错误。在将列表或元组与 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertSetEqual>
<code class="sig-name descname">assertSetEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertSetEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试两组是否相等。如果不是，则会构造一条错误消息，列出集合之间的差异。在比较集合或冻结集合与 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> .</p>
<p>如果其中一个 <em>第一</em> 或 <em>第二</em> 没有一个 <code class="xref py py-meth docutils literal notranslate"><span class=pre>set.difference()</span></code> 方法。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.assertDictEqual>
<code class="sig-name descname">assertDictEqual</code><span class=sig-paren>(</span><em class=sig-param>first</em>, <em class=sig-param>second</em>, <em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.assertDictEqual title=永久链接至目标>¶</a></dt>
<dd><p>测试两个词典是否相等。如果没有，则会构造一条错误消息，显示字典中的差异。默认情况下，此方法将用于比较调用中的字典 <a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<p id=other-methods-and-attrs>最后 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 提供以下方法和属性：</p>
<dl class=method>
<dt id=unittest.TestCase.fail>
<code class="sig-name descname">fail</code><span class=sig-paren>(</span><em class=sig-param>msg=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.fail title=永久链接至目标>¶</a></dt>
<dd><p>无条件地发出测试失败信号， <em>msg</em> 或 <code class="docutils literal notranslate"><span class=pre>None</span></code> 对于错误消息。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestCase.failureException>
<code class="sig-name descname">failureException</code><a class=headerlink href=#unittest.TestCase.failureException title=永久链接至目标>¶</a></dt>
<dd><p>此类属性提供测试方法引发的异常。如果一个测试框架需要使用一个专门的异常（可能是为了携带额外的信息），那么它必须将这个异常子类化，以便“公平地”使用这个框架。此属性的初始值为 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> .</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestCase.longMessage>
<code class="sig-name descname">longMessage</code><a class=headerlink href=#unittest.TestCase.longMessage title=永久链接至目标>¶</a></dt>
<dd><p>这个类属性决定当一个自定义失败消息作为msg参数传递给一个失败的assertxy调用时会发生什么。 <code class="docutils literal notranslate"><span class=pre>True</span></code> 是默认值。在这种情况下，自定义消息将附加到标准故障消息的末尾。当设置为 <code class="docutils literal notranslate"><span class=pre>False</span></code> ，自定义消息将替换标准消息。</p>
<p>通过将实例属性self.longmessage分配给，可以在单个测试方法中重写类设置。 <code class="docutils literal notranslate"><span class=pre>True</span></code> 或 <code class="docutils literal notranslate"><span class=pre>False</span></code> 在调用断言方法之前。</p>
<p>在每次测试调用之前，类设置都会被重置。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.TestCase.maxDiff>
<code class="sig-name descname">maxDiff</code><a class=headerlink href=#unittest.TestCase.maxDiff title=永久链接至目标>¶</a></dt>
<dd><p>此属性通过在失败时报告差异的断言方法控制差异输出的最大长度。默认为80*8个字符。受此属性影响的断言方法为 <a class="reference internal" href=#unittest.TestCase.assertSequenceEqual title=unittest.TestCase.assertSequenceEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertSequenceEqual()</span></code></a> （包括委托给它的所有序列比较方法） <a class="reference internal" href=#unittest.TestCase.assertDictEqual title=unittest.TestCase.assertDictEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertDictEqual()</span></code></a> 和 <a class="reference internal" href=#unittest.TestCase.assertMultiLineEqual title=unittest.TestCase.assertMultiLineEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertMultiLineEqual()</span></code></a> .</p>
<p>设置 <code class="docutils literal notranslate"><span class=pre>maxDiff</span></code> 到 <code class="docutils literal notranslate"><span class=pre>None</span></code> 意味着没有差异的最大长度。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<p>测试框架可以使用以下方法收集有关测试的信息：</p>
<dl class=method>
<dt id=unittest.TestCase.countTestCases>
<code class="sig-name descname">countTestCases</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.countTestCases title=永久链接至目标>¶</a></dt>
<dd><p>返回此测试对象表示的测试数。为了 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 实例，这将始终是 <code class="docutils literal notranslate"><span class=pre>1</span></code> .</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.defaultTestResult>
<code class="sig-name descname">defaultTestResult</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.defaultTestResult title=永久链接至目标>¶</a></dt>
<dd><p>返回应用于此测试用例类的测试结果类的实例（如果没有向 <a class="reference internal" href=#unittest.TestCase.run title=unittest.TestCase.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>run()</span></code></a> 方法）。</p>
<p>为了 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 实例，这将始终是 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 子类 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 必要时应覆盖此项。</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.id>
<code class="sig-name descname">id</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.id title=永久链接至目标>¶</a></dt>
<dd><p>返回一个标识特定测试用例的字符串。这通常是测试方法的全名，包括模块和类名。</p>
</dl>
<dl class=method>
<dt id=unittest.TestCase.shortDescription>
<code class="sig-name descname">shortDescription</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.shortDescription title=永久链接至目标>¶</a></dt>
<dd><p>返回测试说明，或 <code class="docutils literal notranslate"><span class=pre>None</span></code> 如果没有提供说明。此方法的默认实现返回测试方法的docstring的第一行（如果可用），或者 <code class="docutils literal notranslate"><span class=pre>None</span></code> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.1 版更改: </span>在3.1中，这被更改为将测试名称添加到简短描述中，即使存在docstring。这导致了与UnitTest扩展的兼容性问题，并将添加测试名称移动到 <a class="reference internal" href=#unittest.TextTestResult title=unittest.TextTestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TextTestResult</span></code></a> 在Python 3.2中。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.addCleanup>
<code class="sig-name descname">addCleanup</code><span class=sig-paren>(</span><em class=sig-param>function</em>, <em class=sig-param>/</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.addCleanup title=永久链接至目标>¶</a></dt>
<dd><p>添加要在其之后调用的函数 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 清除测试期间使用的资源。函数将按与添加顺序相反的顺序调用 (<abbr title="last-in, first-out">LIFO</abbr> ）调用它们时，会将任何参数和关键字参数传递到 <a class="reference internal" href=#unittest.TestCase.addCleanup title=unittest.TestCase.addCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>addCleanup()</span></code></a> 当它们被添加时。</p>
<p>如果 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 失败，意味着 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 未调用，则仍将调用添加的任何清理函数。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.doCleanups>
<code class="sig-name descname">doCleanups</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.doCleanups title=永久链接至目标>¶</a></dt>
<dd><p>在以下时间之后无条件调用此方法 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> ，或之后 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 如果 <a class="reference internal" href=#unittest.TestCase.setUp title=unittest.TestCase.setUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code></a> 引发异常。</p>
<p>它负责调用由 <a class="reference internal" href=#unittest.TestCase.addCleanup title=unittest.TestCase.addCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>addCleanup()</span></code></a> .如果需要调用清理函数 <em>先前的</em> 到 <a class="reference internal" href=#unittest.TestCase.tearDown title=unittest.TestCase.tearDown><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code></a> 然后你可以调用 <a class="reference internal" href=#unittest.TestCase.doCleanups title=unittest.TestCase.doCleanups><code class="xref py py-meth docutils literal notranslate"><span class=pre>doCleanups()</span></code></a> 你自己。</p>
<p><a class="reference internal" href=#unittest.TestCase.doCleanups title=unittest.TestCase.doCleanups><code class="xref py py-meth docutils literal notranslate"><span class=pre>doCleanups()</span></code></a> 一次从清理函数堆栈中弹出一个方法，以便随时调用它。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.addClassCleanup>
<em class=property>classmethod </em><code class="sig-name descname">addClassCleanup</code><span class=sig-paren>(</span><em class=sig-param>function</em>, <em class=sig-param>/</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.addClassCleanup title=永久链接至目标>¶</a></dt>
<dd><p>添加要在其之后调用的函数 <a class="reference internal" href=#unittest.TestCase.tearDownClass title=unittest.TestCase.tearDownClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDownClass()</span></code></a> 清理测试类期间使用的资源。函数将按与添加顺序相反的顺序调用 (<abbr title="last-in, first-out">LIFO</abbr> ）调用它们时，会将任何参数和关键字参数传递到 <a class="reference internal" href=#unittest.TestCase.addClassCleanup title=unittest.TestCase.addClassCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>addClassCleanup()</span></code></a> 当它们被添加时。</p>
<p>如果 <a class="reference internal" href=#unittest.TestCase.setUpClass title=unittest.TestCase.setUpClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUpClass()</span></code></a> 失败，意味着 <a class="reference internal" href=#unittest.TestCase.tearDownClass title=unittest.TestCase.tearDownClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDownClass()</span></code></a> 未调用，则仍将调用添加的任何清理函数。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestCase.doClassCleanups>
<em class=property>classmethod </em><code class="sig-name descname">doClassCleanups</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestCase.doClassCleanups title=永久链接至目标>¶</a></dt>
<dd><p>在以下时间之后无条件调用此方法 <a class="reference internal" href=#unittest.TestCase.tearDownClass title=unittest.TestCase.tearDownClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDownClass()</span></code></a> ，或之后 <a class="reference internal" href=#unittest.TestCase.setUpClass title=unittest.TestCase.setUpClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUpClass()</span></code></a> 如果 <a class="reference internal" href=#unittest.TestCase.setUpClass title=unittest.TestCase.setUpClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>setUpClass()</span></code></a> 引发异常。</p>
<p>它负责调用由 <code class="xref py py-meth docutils literal notranslate"><span class=pre>addCleanupClass()</span></code> .如果需要调用清理函数 <em>先前的</em> 到 <a class="reference internal" href=#unittest.TestCase.tearDownClass title=unittest.TestCase.tearDownClass><code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDownClass()</span></code></a> 然后你可以调用 <code class="xref py py-meth docutils literal notranslate"><span class=pre>doCleanupsClass()</span></code> 你自己。</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class=pre>doCleanupsClass()</span></code> 一次从清理函数堆栈中弹出一个方法，以便随时调用它。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dl>
</dl>
<dl class=class>
<dt id=unittest.IsolatedAsyncioTestCase>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">IsolatedAsyncioTestCase</code><span class=sig-paren>(</span><em class=sig-param>methodName='runTest'</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.IsolatedAsyncioTestCase title=永久链接至目标>¶</a></dt>
<dd><p>此类提供类似于 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 并且还接受协程作为测试函数。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
<dl class=method>
<dt id=unittest.IsolatedAsyncioTestCase.asyncSetUp>
<em class=property>coroutine </em><code class="sig-name descname">asyncSetUp</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.IsolatedAsyncioTestCase.asyncSetUp title=永久链接至目标>¶</a></dt>
<dd><p>方法来准备测试设备。这是在 <code class="xref py py-meth docutils literal notranslate"><span class=pre>setUp()</span></code> . 在调用测试方法之前立即调用；而不是 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> 或 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> ，此方法引发的任何异常都将被视为错误而不是测试失败。默认实现什么也不做。</p>
</dl>
<dl class=method>
<dt id=unittest.IsolatedAsyncioTestCase.asyncTearDown>
<em class=property>coroutine </em><code class="sig-name descname">asyncTearDown</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.IsolatedAsyncioTestCase.asyncTearDown title=永久链接至目标>¶</a></dt>
<dd><p>方法在调用测试方法并记录结果后立即调用。这是以前叫的 <code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDown()</span></code> . 即使测试方法引发异常，也会调用此函数，因此子类中的实现在检查内部状态时可能需要特别小心。任何例外，除了 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AssertionError title=AssertionError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AssertionError</span></code></a> 或 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> ，由此方法引发的将被视为额外的错误，而不是测试失败（从而增加报告的错误总数）。只有在 <a class="reference internal" href=#unittest.IsolatedAsyncioTestCase.asyncSetUp title=unittest.IsolatedAsyncioTestCase.asyncSetUp><code class="xref py py-meth docutils literal notranslate"><span class=pre>asyncSetUp()</span></code></a> 不管测试方法的结果如何，都会成功。默认实现什么也不做。</p>
</dl>
<dl class=method>
<dt id=unittest.IsolatedAsyncioTestCase.addAsyncCleanup>
<code class="sig-name descname">addAsyncCleanup</code><span class=sig-paren>(</span><em class=sig-param>function</em>, <em class=sig-param>/</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.IsolatedAsyncioTestCase.addAsyncCleanup title=永久链接至目标>¶</a></dt>
<dd><p>此方法接受可以用作清理函数的协同程序。</p>
</dl>
<dl class=method>
<dt id=unittest.IsolatedAsyncioTestCase.run>
<code class="sig-name descname">run</code><span class=sig-paren>(</span><em class=sig-param>result=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.IsolatedAsyncioTestCase.run title=永久链接至目标>¶</a></dt>
<dd><p>设置新的事件循环以运行测试，并将结果收集到 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 对象传递为 <em>结果</em> . 如果 <em>结果</em> 被省略或 <code class="docutils literal notranslate"><span class=pre>None</span></code> ，将创建一个临时结果对象（通过调用 <code class="xref py py-meth docutils literal notranslate"><span class=pre>defaultTestResult()</span></code> 方法）和使用。结果对象返回到 <a class="reference internal" href=#unittest.IsolatedAsyncioTestCase.run title=unittest.IsolatedAsyncioTestCase.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>run()</span></code></a> 的来电者。测试结束时，将取消事件循环中的所有任务。</p>
</dl>
<p>说明顺序的示例：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=kn>from</span> <span class=nn>unittest</span> <span class=kn>import</span> <span class=n>IsolatedAsyncioTestCase</span>

<span class=n>events</span> <span class=o>=</span> <span class=p>[]</span>


<span class=k>class</span> <span class=nc>Test</span><span class=p>(</span><span class=n>IsolatedAsyncioTestCase</span><span class=p>):</span>


    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>events</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>"setUp"</span><span class=p>)</span>

    <span class=k>async</span> <span class=k>def</span> <span class=nf>asyncSetUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_async_connection</span> <span class=o>=</span> <span class=k>await</span> <span class=n>AsyncConnection</span><span class=p>()</span>
        <span class=n>events</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>"asyncSetUp"</span><span class=p>)</span>

    <span class=k>async</span> <span class=k>def</span> <span class=nf>test_response</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>events</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>"test_response"</span><span class=p>)</span>
        <span class=n>response</span> <span class=o>=</span> <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_async_connection</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>"https://example.com"</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>response</span><span class=o>.</span><span class=n>status_code</span><span class=p>,</span> <span class=mi>200</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>addAsyncCleanup</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>on_cleanup</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>tearDown</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>events</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>"tearDown"</span><span class=p>)</span>

    <span class=k>async</span> <span class=k>def</span> <span class=nf>asyncTearDown</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_async_connection</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
        <span class=n>events</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>"asyncTearDown"</span><span class=p>)</span>

    <span class=k>async</span> <span class=k>def</span> <span class=nf>on_cleanup</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>events</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>"cleanup"</span><span class=p>)</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>"__main__"</span><span class=p>:</span>
    <span class=n>unittest</span><span class=o>.</span><span class=n>main</span><span class=p>()</span>
</pre></div>
</div>
<p>运行测试之后， <code class="docutils literal notranslate"><span class=pre>events</span></code> 会包含 <code class="docutils literal notranslate"><span class=pre>["setUp",</span> <span class=pre>"asyncSetUp",</span> <span class=pre>"test_response",</span> <span class=pre>"asyncTearDown",</span> <span class=pre>"tearDown",</span> <span class=pre>"cleanup"]</span></code> .</p>
</dl>
<dl class=class>
<dt id=unittest.FunctionTestCase>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">FunctionTestCase</code><span class=sig-paren>(</span><em class=sig-param>testFunc</em>, <em class=sig-param>setUp=None</em>, <em class=sig-param>tearDown=None</em>, <em class=sig-param>description=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.FunctionTestCase title=永久链接至目标>¶</a></dt>
<dd><p>此类实现 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 接口，它允许测试运行程序驱动测试，但不提供测试代码可以用来检查和报告错误的方法。这用于使用遗留测试代码创建测试用例，允许将其集成到 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> -基于测试框架。</p>
</dl>
<div class=section id=deprecated-aliases>
<span id=id1></span><h4>不推荐使用的别名<a class=headerlink href=#deprecated-aliases title=永久链接至标题>¶</a></h4>
<p>出于历史原因， <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 方法有一个或多个别名，现在已弃用。下表列出了正确的名称及其不推荐使用的别名：</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style=width:40%>
<col style=width:29%>
<col style=width:31%>
</colgroup>
<thead>
<tr class=row-odd><th class=head><p>方法名称</p></th>
<th class=head><p>不推荐使用的别名</p></th>
<th class=head><p>不推荐使用的别名</p></th>
</tr>
</thead>
<tbody>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertEqual title=unittest.TestCase.assertEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertEqual()</span></code></a></p></td>
<td><p>故障排除</p></td>
<td><p>断言</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertNotEqual title=unittest.TestCase.assertNotEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotEqual()</span></code></a></p></td>
<td><p>失效相等</p></td>
<td><p>断言笔记</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertTrue title=unittest.TestCase.assertTrue><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertTrue()</span></code></a></p></td>
<td><p>故障除非</p></td>
<td><p>assert_</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertFalse title=unittest.TestCase.assertFalse><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertFalse()</span></code></a></p></td>
<td><p>故障排除</p></td>
<td></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertRaises title=unittest.TestCase.assertRaises><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaises()</span></code></a></p></td>
<td><p>故障解除引发</p></td>
<td></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertAlmostEqual title=unittest.TestCase.assertAlmostEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertAlmostEqual()</span></code></a></p></td>
<td><p>失败，除非是最重要的</p></td>
<td><p>断言最高级</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertNotAlmostEqual title=unittest.TestCase.assertNotAlmostEqual><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotAlmostEqual()</span></code></a></p></td>
<td><p>失败</p></td>
<td><p>断言不等于</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertRegex title=unittest.TestCase.assertRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRegex()</span></code></a></p></td>
<td></td>
<td><p>断言regexpmatches</p></td>
</tr>
<tr class=row-even><td><p><a class="reference internal" href=#unittest.TestCase.assertNotRegex title=unittest.TestCase.assertNotRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotRegex()</span></code></a></p></td>
<td></td>
<td><p>断言NotRegExpMatches</p></td>
</tr>
<tr class=row-odd><td><p><a class="reference internal" href=#unittest.TestCase.assertRaisesRegex title=unittest.TestCase.assertRaisesRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaisesRegex()</span></code></a></p></td>
<td></td>
<td><p>断言RaisesRegExp</p></td>
</tr>
</tbody>
</table>
<div class=deprecated>
<p><span class="versionmodified deprecated">3.1 版后已移除: </span>第二列中列出的fail*别名已被弃用。</p>
</div>
<div class=deprecated>
<p><span class="versionmodified deprecated">3.2 版后已移除: </span>第三列中列出的assert*别名已被弃用。</p>
</div>
<div class=deprecated>
<p><span class="versionmodified deprecated">3.2 版后已移除: </span><code class="docutils literal notranslate"><span class=pre>assertRegexpMatches</span></code> 和 <code class="docutils literal notranslate"><span class=pre>assertRaisesRegexp</span></code> 已重命名为 <a class="reference internal" href=#unittest.TestCase.assertRegex title=unittest.TestCase.assertRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRegex()</span></code></a> 和 <a class="reference internal" href=#unittest.TestCase.assertRaisesRegex title=unittest.TestCase.assertRaisesRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertRaisesRegex()</span></code></a> .</p>
</div>
<div class=deprecated>
<p><span class="versionmodified deprecated">3.5 版后已移除: </span>这个 <code class="docutils literal notranslate"><span class=pre>assertNotRegexpMatches</span></code> 名称已弃用，取而代之的是 <a class="reference internal" href=#unittest.TestCase.assertNotRegex title=unittest.TestCase.assertNotRegex><code class="xref py py-meth docutils literal notranslate"><span class=pre>assertNotRegex()</span></code></a> .</p>
</div>
</div></blockquote>
</div>
</div>
<div class=section id=grouping-tests>
<span id=testsuite-objects></span><h3>分组测试<a class=headerlink href=#grouping-tests title=永久链接至标题>¶</a></h3>
<dl class=class>
<dt id=unittest.TestSuite>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestSuite</code><span class=sig-paren>(</span><em class=sig-param>tests=()</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite title=永久链接至目标>¶</a></dt>
<dd><p>此类表示单个测试用例和测试套件的聚合。类提供测试运行程序所需的接口，以允许它像其他测试用例一样运行。运行一个 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 实例与在套件上迭代相同，分别运行每个测试。</p>
<p>如果 <em>测验</em> 如果给定，它必须是单个测试用例或其他将用于最初构建该套件的测试套件的不可重复项。稍后将提供其他方法向集合中添加测试用例和套件。</p>
<p><a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 对象的行为很像 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 对象，但它们实际上不实现测试。相反，它们被用来将测试聚合到应该一起运行的测试组中。可以使用一些附加方法将测试添加到 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 实例：</p>
<dl class=method>
<dt id=unittest.TestSuite.addTest>
<code class="sig-name descname">addTest</code><span class=sig-paren>(</span><em class=sig-param>test</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite.addTest title=永久链接至目标>¶</a></dt>
<dd><p>添加 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 或 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 到套房。</p>
</dl>
<dl class=method>
<dt id=unittest.TestSuite.addTests>
<code class="sig-name descname">addTests</code><span class=sig-paren>(</span><em class=sig-param>tests</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite.addTests title=永久链接至目标>¶</a></dt>
<dd><p>添加来自ITerable的所有测试 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 和 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 此测试套件的实例。</p>
<p>这相当于迭代 <em>测验</em> 呼唤 <a class="reference internal" href=#unittest.TestSuite.addTest title=unittest.TestSuite.addTest><code class="xref py py-meth docutils literal notranslate"><span class=pre>addTest()</span></code></a> 对于每个元素。</p>
</dl>
<p><a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 与共享以下方法 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> ：</p>
<dl class=method>
<dt id=unittest.TestSuite.run>
<code class="sig-name descname">run</code><span class=sig-paren>(</span><em class=sig-param>result</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite.run title=永久链接至目标>¶</a></dt>
<dd><p>运行与此套件关联的测试，将结果收集到作为 <em>结果</em> . 注意，与 <a class="reference internal" href=#unittest.TestCase.run title=unittest.TestCase.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestCase.run()</span></code></a> ， <a class="reference internal" href=#unittest.TestSuite.run title=unittest.TestSuite.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestSuite.run()</span></code></a> 要求传入结果对象。</p>
</dl>
<dl class=method>
<dt id=unittest.TestSuite.debug>
<code class="sig-name descname">debug</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite.debug title=永久链接至目标>¶</a></dt>
<dd><p>运行与此套件关联的测试，而不收集结果。这允许将测试引发的异常传播到调用方，并可用于支持在调试器下运行测试。</p>
</dl>
<dl class=method>
<dt id=unittest.TestSuite.countTestCases>
<code class="sig-name descname">countTestCases</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite.countTestCases title=永久链接至目标>¶</a></dt>
<dd><p>返回此测试对象表示的测试数，包括所有单个测试和子套件。</p>
</dl>
<dl class=method>
<dt id=unittest.TestSuite.__iter__>
<code class="sig-name descname">__iter__</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestSuite.__iter__ title=永久链接至目标>¶</a></dt>
<dd><p>按a分组的测试 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 总是通过迭代访问。子类可以通过覆盖 <a class="reference internal" href=#unittest.TestSuite.__iter__ title=unittest.TestSuite.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a> . 请注意，此方法可以在单个套件上多次调用（例如，当计算测试或比较是否相等时），因此之前通过重复迭代返回的测试 <a class="reference internal" href=#unittest.TestSuite.run title=unittest.TestSuite.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestSuite.run()</span></code></a> 每个调用迭代必须相同。后 <a class="reference internal" href=#unittest.TestSuite.run title=unittest.TestSuite.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestSuite.run()</span></code></a> ，除非调用方使用重写的子类，否则调用方不应依赖此方法返回的测试。 <code class="xref py py-meth docutils literal notranslate"><span class=pre>TestSuite._removeTestAtIndex()</span></code> 保留测试引用。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>在早期版本中， <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 直接访问测试，而不是通过迭代，因此重写 <a class="reference internal" href=#unittest.TestSuite.__iter__ title=unittest.TestSuite.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a> 不足以提供测试。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>在早期版本中， <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 保留对每个的引用 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 之后 <a class="reference internal" href=#unittest.TestSuite.run title=unittest.TestSuite.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestSuite.run()</span></code></a> . 子类可以通过重写 <code class="xref py py-meth docutils literal notranslate"><span class=pre>TestSuite._removeTestAtIndex()</span></code> .</p>
</div>
</dl>
<p>在A的典型用法中 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 对象 <a class="reference internal" href=#unittest.TestSuite.run title=unittest.TestSuite.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>run()</span></code></a> 方法由 <code class="xref py py-class docutils literal notranslate"><span class=pre>TestRunner</span></code> 而不是由最终用户测试。</p>
</dl>
</div>
<div class=section id=loading-and-running-tests>
<h3>加载和运行测试<a class=headerlink href=#loading-and-running-tests title=永久链接至标题>¶</a></h3>
<dl class=class>
<dt id=unittest.TestLoader>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestLoader</code><a class=headerlink href=#unittest.TestLoader title=永久链接至目标>¶</a></dt>
<dd><p>这个 <a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 类用于从类和模块创建测试套件。通常，不需要创建此类的实例； <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 模块提供了一个可以共享为 <a class="reference internal" href=#unittest.defaultTestLoader title=unittest.defaultTestLoader><code class="xref py py-data docutils literal notranslate"><span class=pre>unittest.defaultTestLoader</span></code></a> . 但是，使用子类或实例可以自定义某些可配置属性。</p>
<p><a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 对象具有以下属性：</p>
<dl class=attribute>
<dt id=unittest.TestLoader.errors>
<code class="sig-name descname">errors</code><a class=headerlink href=#unittest.TestLoader.errors title=永久链接至目标>¶</a></dt>
<dd><p>加载测试时遇到的非致命错误的列表。加载器在任何时候都不能复位。致命错误由向调用方引发异常的相关方法发出信号。非致命错误也由运行时会引发原始错误的合成测试指示。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dl>
<p><a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 对象具有以下方法：</p>
<dl class=method>
<dt id=unittest.TestLoader.loadTestsFromTestCase>
<code class="sig-name descname">loadTestsFromTestCase</code><span class=sig-paren>(</span><em class=sig-param>testCaseClass</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestLoader.loadTestsFromTestCase title=永久链接至目标>¶</a></dt>
<dd><p>返回包含在 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 衍生的 <code class="xref py py-class docutils literal notranslate"><span class=pre>testCaseClass</span></code> .</p>
<p>为每个方法创建一个测试用例实例 <a class="reference internal" href=#unittest.TestLoader.getTestCaseNames title=unittest.TestLoader.getTestCaseNames><code class="xref py py-meth docutils literal notranslate"><span class=pre>getTestCaseNames()</span></code></a> . 默认情况下，这些是以 <code class="docutils literal notranslate"><span class=pre>test</span></code> .如果 <a class="reference internal" href=#unittest.TestLoader.getTestCaseNames title=unittest.TestLoader.getTestCaseNames><code class="xref py py-meth docutils literal notranslate"><span class=pre>getTestCaseNames()</span></code></a> 不返回任何方法，但返回 <code class="xref py py-meth docutils literal notranslate"><span class=pre>runTest()</span></code> 方法实现后，将为该方法创建一个单独的测试用例。</p>
</dl>
<dl class=method>
<dt id=unittest.TestLoader.loadTestsFromModule>
<code class="sig-name descname">loadTestsFromModule</code><span class=sig-paren>(</span><em class=sig-param>module</em>, <em class=sig-param>pattern=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestLoader.loadTestsFromModule title=永久链接至目标>¶</a></dt>
<dd><p>返回包含在给定模块中的所有测试用例的套件。此方法搜索 <em>模块</em> 对于派生自 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 并为为为类定义的每个测试方法创建类的实例。</p>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>当使用的层次结构 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> -派生类在共享fixture和helper函数时很方便，在不打算直接实例化的基类上定义测试方法不能很好地使用此方法。然而，当固定装置不同并且在子类中定义时，这样做是有用的。</p>
</div>
<p>如果模块提供 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 函数将调用它来加载测试。这允许模块自定义测试加载。这就是 <a class="reference internal" href=#load-tests-protocol>load_tests protocol</a> . 这个 <em>模式</em> 参数作为第三个参数传递给 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>支持 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 补充。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span>无证和非官方的 <em>use_load_tests</em> 默认参数已弃用并被忽略，但由于向后兼容性，它仍然被接受。该方法现在还接受只包含关键字的参数 <em>模式</em> 传递给 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 作为第三个参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestLoader.loadTestsFromName>
<code class="sig-name descname">loadTestsFromName</code><span class=sig-paren>(</span><em class=sig-param>name</em>, <em class=sig-param>module=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestLoader.loadTestsFromName title=永久链接至目标>¶</a></dt>
<dd><p>返回一组给定字符串说明符的所有测试用例。</p>
<p>说明符 <em>name</em> 是一个“点式名称”，可以解析为模块、测试用例类、测试用例类内的测试方法，或者 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 实例，或返回 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 或 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 实例。这些检查按这里列出的顺序应用；也就是说，可能的测试用例类上的方法将被选为“测试用例类中的测试方法”，而不是“可调用对象”。</p>
<p>例如，如果您有一个模块 <code class="xref py py-mod docutils literal notranslate"><span class=pre>SampleTests</span></code> 包含一个 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> -派生类 <code class="xref py py-class docutils literal notranslate"><span class=pre>SampleTestCase</span></code> 用三种测试方法 (<code class="xref py py-meth docutils literal notranslate"><span class=pre>test_one()</span></code> ， <code class="xref py py-meth docutils literal notranslate"><span class=pre>test_two()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class=pre>test_three()</span></code> ）说明符 <code class="docutils literal notranslate"><span class=pre>'SampleTests.SampleTestCase'</span></code> 将导致此方法返回一个将运行所有三个测试方法的套件。使用说明符 <code class="docutils literal notranslate"><span class=pre>'SampleTests.SampleTestCase.test_two'</span></code> 会导致它返回一个只运行 <code class="xref py py-meth docutils literal notranslate"><span class=pre>test_two()</span></code> 试验方法。说明符可以引用尚未导入的模块和包；它们将作为副作用导入。</p>
<p>该方法可选地解决 <em>name</em> 相对于给定的 <em>模块</em> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span>如果一个 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#ImportError title=ImportError><code class="xref py py-exc docutils literal notranslate"><span class=pre>ImportError</span></code></a> 或 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> 遍历时发生 <em>name</em> 然后将返回一个在运行时引发该错误的合成测试。这些错误包括在self.errors累积的错误中。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestLoader.loadTestsFromNames>
<code class="sig-name descname">loadTestsFromNames</code><span class=sig-paren>(</span><em class=sig-param>names</em>, <em class=sig-param>module=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestLoader.loadTestsFromNames title=永久链接至目标>¶</a></dt>
<dd><p>类似 <a class="reference internal" href=#unittest.TestLoader.loadTestsFromName title=unittest.TestLoader.loadTestsFromName><code class="xref py py-meth docutils literal notranslate"><span class=pre>loadTestsFromName()</span></code></a> ，但采用的是一系列名称而不是单个名称。返回值是一个测试套件，它支持为每个名称定义的所有测试。</p>
</dl>
<dl class=method>
<dt id=unittest.TestLoader.getTestCaseNames>
<code class="sig-name descname">getTestCaseNames</code><span class=sig-paren>(</span><em class=sig-param>testCaseClass</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestLoader.getTestCaseNames title=永久链接至目标>¶</a></dt>
<dd><p>返回在中找到的方法名的排序序列 <em>试验箱</em> ；这应该是 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> .</p>
</dl>
<dl class=method>
<dt id=unittest.TestLoader.discover>
<code class="sig-name descname">discover</code><span class=sig-paren>(</span><em class=sig-param>start_dir</em>, <em class=sig-param>pattern='test*.py'</em>, <em class=sig-param>top_level_dir=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestLoader.discover title=永久链接至目标>¶</a></dt>
<dd><p>通过从指定的开始目录递归到子目录中查找所有测试模块，并返回包含这些模块的testsuite对象。仅匹配的测试文件 <em>模式</em> 将加载。（使用shell样式模式匹配。）将只加载可导入的模块名（即有效的python标识符）。</p>
<p>所有测试模块必须可以从项目的顶层导入。如果开始目录不是顶级目录，则必须单独指定顶级目录。</p>
<p>如果导入模块失败（例如，由于语法错误），则这将被记录为单个错误，并将继续查找。如果导入失败是由于 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> 如果被引发，它将被记录为跳过而不是错误。</p>
<p>如果一个包（包含名为 <code class="file docutils literal notranslate"><span class=pre>__init__.py</span></code> ）如果找到，将检查包的 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 功能。如果存在，则将调用 <code class="docutils literal notranslate"><span class=pre>package.load_tests(loader,</span> <span class=pre>tests,</span> <span class=pre>pattern)</span></code> . 测试发现会注意确保在调用期间仅检查一次包的测试，即使加载测试函数本身调用 <code class="docutils literal notranslate"><span class=pre>loader.discover</span></code> .</p>
<p>如果 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 存在，则发现存在 <em>not</em> 再回到包中， <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 负责加载包中的所有测试。</p>
<p>故意不将模式存储为加载器属性，以便包可以继续发现自己。 <em>top_level_dir</em> 存储如此 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 不需要将此参数传递给 <code class="docutils literal notranslate"><span class=pre>loader.discover()</span></code> .</p>
<p><em>start_dir</em> 可以是点式模块名，也可以是目录。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发的模块 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> 导入时记录为跳过，而不是错误。Discovery适用于 <a class="reference internal" href=https://www.osgeo.cn/cpython/glossary.html#term-namespace-package><span class="xref std std-term">namespace packages</span></a> . 路径在导入之前进行排序，以便执行顺序相同，即使基础文件系统的顺序不依赖于文件名。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span>现在检查找到的包 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 不管他们的路径是否匹配 <em>模式</em> ，因为包名称不可能与默认模式匹配。</p>
</div>
</dl>
<p>的以下属性 <a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 可以通过对实例进行子类化或赋值来配置：</p>
<dl class=attribute>
<dt id=unittest.TestLoader.testMethodPrefix>
<code class="sig-name descname">testMethodPrefix</code><a class=headerlink href=#unittest.TestLoader.testMethodPrefix title=永久链接至目标>¶</a></dt>
<dd><p>提供方法名称前缀的字符串，该前缀将被解释为测试方法。默认值为 <code class="docutils literal notranslate"><span class=pre>'test'</span></code> .</p>
<p>这种影响 <a class="reference internal" href=#unittest.TestLoader.getTestCaseNames title=unittest.TestLoader.getTestCaseNames><code class="xref py py-meth docutils literal notranslate"><span class=pre>getTestCaseNames()</span></code></a> 以及所有 <code class="xref py py-meth docutils literal notranslate"><span class=pre>loadTestsFrom*()</span></code> 方法。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestLoader.sortTestMethodsUsing>
<code class="sig-name descname">sortTestMethodsUsing</code><a class=headerlink href=#unittest.TestLoader.sortTestMethodsUsing title=永久链接至目标>¶</a></dt>
<dd><p>在对方法名进行排序时用于比较的函数 <a class="reference internal" href=#unittest.TestLoader.getTestCaseNames title=unittest.TestLoader.getTestCaseNames><code class="xref py py-meth docutils literal notranslate"><span class=pre>getTestCaseNames()</span></code></a> 以及所有 <code class="xref py py-meth docutils literal notranslate"><span class=pre>loadTestsFrom*()</span></code> 方法。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestLoader.suiteClass>
<code class="sig-name descname">suiteClass</code><a class=headerlink href=#unittest.TestLoader.suiteClass title=永久链接至目标>¶</a></dt>
<dd><p>从测试列表构造测试套件的可调用对象。结果对象上不需要任何方法。默认值是 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 类。</p>
<p>这影响到所有 <code class="xref py py-meth docutils literal notranslate"><span class=pre>loadTestsFrom*()</span></code> 方法。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestLoader.testNamePatterns>
<code class="sig-name descname">testNamePatterns</code><a class=headerlink href=#unittest.TestLoader.testNamePatterns title=永久链接至目标>¶</a></dt>
<dd><p>测试方法必须匹配才能包含在测试套件中的unix shell样式通配符测试名称模式列表（请参见 <code class="docutils literal notranslate"><span class=pre>-v</span></code> 选择权。</p>
<p>如果该属性不是 <code class="docutils literal notranslate"><span class=pre>None</span></code> （默认值），要包含在测试套件中的所有测试方法必须与此列表中的一个模式匹配。请注意，始终使用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/fnmatch.html#fnmatch.fnmatchcase title=fnmatch.fnmatchcase><code class="xref py py-meth docutils literal notranslate"><span class=pre>fnmatch.fnmatchcase()</span></code></a> ，因此不同于传递给 <code class="docutils literal notranslate"><span class=pre>-v</span></code> 选项，必须使用 <code class="docutils literal notranslate"><span class=pre>*</span></code> 通配符。</p>
<p>这影响到所有 <code class="xref py py-meth docutils literal notranslate"><span class=pre>loadTestsFrom*()</span></code> 方法。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dl>
</dl>
<dl class=class>
<dt id=unittest.TestResult>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestResult</code><a class=headerlink href=#unittest.TestResult title=永久链接至目标>¶</a></dt>
<dd><p>此类用于编译有关哪些测试成功和哪些测试失败的信息。</p>
<p>A <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 对象存储一组测试的结果。这个 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 和 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 类确保结果被正确地记录；测试作者不需要担心记录测试结果。</p>
<p>测试框架构建在 <a class="reference internal" href=#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 可能需要访问 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 为报告目的运行一组测试生成的对象；a <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 实例由返回 <code class="xref py py-meth docutils literal notranslate"><span class=pre>TestRunner.run()</span></code> 方法。</p>
<p><a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 实例具有以下在检查运行一组测试的结果时会感兴趣的属性：</p>
<dl class=attribute>
<dt id=unittest.TestResult.errors>
<code class="sig-name descname">errors</code><a class=headerlink href=#unittest.TestResult.errors title=永久链接至目标>¶</a></dt>
<dd><p>包含2个元组的列表 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 保存格式化跟踪的实例和字符串。每个元组表示引发意外异常的测试。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.failures>
<code class="sig-name descname">failures</code><a class=headerlink href=#unittest.TestResult.failures title=永久链接至目标>¶</a></dt>
<dd><p>包含2个元组的列表 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 保存格式化跟踪的实例和字符串。每个元组表示一个测试，其中使用 <code class="xref py py-meth docutils literal notranslate"><span class=pre>TestCase.assert*()</span></code> 方法。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.skipped>
<code class="sig-name descname">skipped</code><a class=headerlink href=#unittest.TestResult.skipped title=永久链接至目标>¶</a></dt>
<dd><p>包含2个元组的列表 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 包含跳过测试原因的实例和字符串。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.expectedFailures>
<code class="sig-name descname">expectedFailures</code><a class=headerlink href=#unittest.TestResult.expectedFailures title=永久链接至目标>¶</a></dt>
<dd><p>包含2个元组的列表 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 保存格式化跟踪的实例和字符串。每个元组表示测试用例的预期失败。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.unexpectedSuccesses>
<code class="sig-name descname">unexpectedSuccesses</code><a class=headerlink href=#unittest.TestResult.unexpectedSuccesses title=永久链接至目标>¶</a></dt>
<dd><p>包含以下内容的列表 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 标记为预期失败但成功的实例。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.shouldStop>
<code class="sig-name descname">shouldStop</code><a class=headerlink href=#unittest.TestResult.shouldStop title=永久链接至目标>¶</a></dt>
<dd><p>设置为 <code class="docutils literal notranslate"><span class=pre>True</span></code> 测试执行应在何时停止 <a class="reference internal" href=#unittest.TestResult.stop title=unittest.TestResult.stop><code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code></a> .</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.testsRun>
<code class="sig-name descname">testsRun</code><a class=headerlink href=#unittest.TestResult.testsRun title=永久链接至目标>¶</a></dt>
<dd><p>到目前为止运行的测试总数。</p>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.buffer>
<code class="sig-name descname">buffer</code><a class=headerlink href=#unittest.TestResult.buffer title=永久链接至目标>¶</a></dt>
<dd><p>如果设置为真， <code class="docutils literal notranslate"><span class=pre>sys.stdout</span></code> 和 <code class="docutils literal notranslate"><span class=pre>sys.stderr</span></code> 将在两者之间缓冲 <a class="reference internal" href=#unittest.TestResult.startTest title=unittest.TestResult.startTest><code class="xref py py-meth docutils literal notranslate"><span class=pre>startTest()</span></code></a> 和 <a class="reference internal" href=#unittest.TestResult.stopTest title=unittest.TestResult.stopTest><code class="xref py py-meth docutils literal notranslate"><span class=pre>stopTest()</span></code></a> 正在被调用。收集到的输出将仅回显到 <code class="docutils literal notranslate"><span class=pre>sys.stdout</span></code> 和 <code class="docutils literal notranslate"><span class=pre>sys.stderr</span></code> 如果测试失败或错误。任何输出也附加到故障/错误消息上。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.failfast>
<code class="sig-name descname">failfast</code><a class=headerlink href=#unittest.TestResult.failfast title=永久链接至目标>¶</a></dt>
<dd><p>如果设置为真 <a class="reference internal" href=#unittest.TestResult.stop title=unittest.TestResult.stop><code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code></a> 将在第一次失败或错误时调用，停止测试运行。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.TestResult.tb_locals>
<code class="sig-name descname">tb_locals</code><a class=headerlink href=#unittest.TestResult.tb_locals title=永久链接至目标>¶</a></dt>
<dd><p>如果设置为真，那么局部变量将显示在回溯中。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestResult.wasSuccessful>
<code class="sig-name descname">wasSuccessful</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.wasSuccessful title=永久链接至目标>¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class=pre>True</span></code> 如果到目前为止运行的所有测试都已通过，否则返回 <code class="docutils literal notranslate"><span class=pre>False</span></code> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>返回 <code class="docutils literal notranslate"><span class=pre>False</span></code> 如果有 <a class="reference internal" href=#unittest.TestResult.unexpectedSuccesses title=unittest.TestResult.unexpectedSuccesses><code class="xref py py-attr docutils literal notranslate"><span class=pre>unexpectedSuccesses</span></code></a> 从标记有 <a class="reference internal" href=#unittest.expectedFailure title=unittest.expectedFailure><code class="xref py py-func docutils literal notranslate"><span class=pre>expectedFailure()</span></code></a> decorator。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestResult.stop>
<code class="sig-name descname">stop</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.stop title=永久链接至目标>¶</a></dt>
<dd><p>可以调用此方法，通过设置 <a class="reference internal" href=#unittest.TestResult.shouldStop title=unittest.TestResult.shouldStop><code class="xref py py-attr docutils literal notranslate"><span class=pre>shouldStop</span></code></a> 属性到 <code class="docutils literal notranslate"><span class=pre>True</span></code> . <code class="xref py py-class docutils literal notranslate"><span class=pre>TestRunner</span></code> 对象应尊重此标志并返回，而不运行任何其他测试。</p>
<p>例如，此功能由 <a class="reference internal" href=#unittest.TextTestRunner title=unittest.TextTestRunner><code class="xref py py-class docutils literal notranslate"><span class=pre>TextTestRunner</span></code></a> 类在用户从键盘发出中断信号时停止测试框架。提供的交互式工具 <code class="xref py py-class docutils literal notranslate"><span class=pre>TestRunner</span></code> 实现可以以类似的方式使用它。</p>
</dl>
<p>以下方法 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 类用于维护内部数据结构，可以在子类中扩展以支持其他报告要求。这对于构建在运行测试时支持交互式报告的工具特别有用。</p>
<dl class=method>
<dt id=unittest.TestResult.startTest>
<code class="sig-name descname">startTest</code><span class=sig-paren>(</span><em class=sig-param>test</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.startTest title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 就要运行了。</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.stopTest>
<code class="sig-name descname">stopTest</code><span class=sig-paren>(</span><em class=sig-param>test</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.stopTest title=永久链接至目标>¶</a></dt>
<dd><p>在测试用例之后调用 <em>test</em> 已执行，无论结果如何。</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.startTestRun>
<code class="sig-name descname">startTestRun</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.startTestRun title=永久链接至目标>¶</a></dt>
<dd><p>在执行任何测试之前调用一次。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestResult.stopTestRun>
<code class="sig-name descname">stopTestRun</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.stopTestRun title=永久链接至目标>¶</a></dt>
<dd><p>在执行所有测试后调用一次。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addError>
<code class="sig-name descname">addError</code><span class=sig-paren>(</span><em class=sig-param>test</em>, <em class=sig-param>err</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addError title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 引发意外的异常。 <em>err</em> 是由返回的窗体的元组 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.exc_info title=sys.exc_info><code class="xref py py-func docutils literal notranslate"><span class=pre>sys.exc_info()</span></code></a> ： <code class="docutils literal notranslate"><span class=pre>(type,</span> <span class=pre>value,</span> <span class=pre>traceback)</span></code> .</p>
<p>默认实现附加一个元组 <code class="docutils literal notranslate"><span class=pre>(test,</span> <span class=pre>formatted_err)</span></code> 到实例的 <a class="reference internal" href=#unittest.TestResult.errors title=unittest.TestResult.errors><code class="xref py py-attr docutils literal notranslate"><span class=pre>errors</span></code></a> 属性，其中 <em>formatted_err</em> 是从 <em>err</em> .</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addFailure>
<code class="sig-name descname">addFailure</code><span class=sig-paren>(</span><em class=sig-param>test</em>, <em class=sig-param>err</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addFailure title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 表示故障。 <em>err</em> 是由返回的窗体的元组 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.exc_info title=sys.exc_info><code class="xref py py-func docutils literal notranslate"><span class=pre>sys.exc_info()</span></code></a> ： <code class="docutils literal notranslate"><span class=pre>(type,</span> <span class=pre>value,</span> <span class=pre>traceback)</span></code> .</p>
<p>默认实现附加一个元组 <code class="docutils literal notranslate"><span class=pre>(test,</span> <span class=pre>formatted_err)</span></code> 到实例的 <a class="reference internal" href=#unittest.TestResult.failures title=unittest.TestResult.failures><code class="xref py py-attr docutils literal notranslate"><span class=pre>failures</span></code></a> 属性，其中 <em>formatted_err</em> 是从 <em>err</em> .</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addSuccess>
<code class="sig-name descname">addSuccess</code><span class=sig-paren>(</span><em class=sig-param>test</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addSuccess title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 成功了。</p>
<p>默认实现什么也不做。</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addSkip>
<code class="sig-name descname">addSkip</code><span class=sig-paren>(</span><em class=sig-param>test</em>, <em class=sig-param>reason</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addSkip title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 跳过。 <em>原因</em> 是测试跳过的原因。</p>
<p>默认实现附加一个元组 <code class="docutils literal notranslate"><span class=pre>(test,</span> <span class=pre>reason)</span></code> 到实例的 <a class="reference internal" href=#unittest.TestResult.skipped title=unittest.TestResult.skipped><code class="xref py py-attr docutils literal notranslate"><span class=pre>skipped</span></code></a> 属性。</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addExpectedFailure>
<code class="sig-name descname">addExpectedFailure</code><span class=sig-paren>(</span><em class=sig-param>test</em>, <em class=sig-param>err</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addExpectedFailure title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 失败，但被标记为 <a class="reference internal" href=#unittest.expectedFailure title=unittest.expectedFailure><code class="xref py py-func docutils literal notranslate"><span class=pre>expectedFailure()</span></code></a> decorator。</p>
<p>默认实现附加一个元组 <code class="docutils literal notranslate"><span class=pre>(test,</span> <span class=pre>formatted_err)</span></code> 到实例的 <a class="reference internal" href=#unittest.TestResult.expectedFailures title=unittest.TestResult.expectedFailures><code class="xref py py-attr docutils literal notranslate"><span class=pre>expectedFailures</span></code></a> 属性，其中 <em>formatted_err</em> 是从 <em>err</em> .</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addUnexpectedSuccess>
<code class="sig-name descname">addUnexpectedSuccess</code><span class=sig-paren>(</span><em class=sig-param>test</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addUnexpectedSuccess title=永久链接至目标>¶</a></dt>
<dd><p>当测试用例 <em>test</em> 被标记为 <a class="reference internal" href=#unittest.expectedFailure title=unittest.expectedFailure><code class="xref py py-func docutils literal notranslate"><span class=pre>expectedFailure()</span></code></a> 但成功了。</p>
<p>默认实现将测试附加到实例的 <a class="reference internal" href=#unittest.TestResult.unexpectedSuccesses title=unittest.TestResult.unexpectedSuccesses><code class="xref py py-attr docutils literal notranslate"><span class=pre>unexpectedSuccesses</span></code></a> 属性。</p>
</dl>
<dl class=method>
<dt id=unittest.TestResult.addSubTest>
<code class="sig-name descname">addSubTest</code><span class=sig-paren>(</span><em class=sig-param>test</em>, <em class=sig-param>subtest</em>, <em class=sig-param>outcome</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TestResult.addSubTest title=永久链接至目标>¶</a></dt>
<dd><p>当子测试完成时调用。 <em>test</em> 是与测试方法相对应的测试用例。 <em>子测验</em> 是习俗 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 描述子测试的实例。</p>
<p>如果 <em>结果</em> 是 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/constants.html#None title=None><code class="xref py py-const docutils literal notranslate"><span class=pre>None</span></code></a> ，子测试成功。否则，它将失败，并出现一个异常，其中 <em>结果</em> 是由返回的窗体的元组 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.exc_info title=sys.exc_info><code class="xref py py-func docutils literal notranslate"><span class=pre>sys.exc_info()</span></code></a> ： <code class="docutils literal notranslate"><span class=pre>(type,</span> <span class=pre>value,</span> <span class=pre>traceback)</span></code> .</p>
<p>当结果成功时，默认实现什么也不做，并将子测试失败记录为正常失败。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dl>
</dl>
<dl class=class>
<dt id=unittest.TextTestResult>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TextTestResult</code><span class=sig-paren>(</span><em class=sig-param>stream</em>, <em class=sig-param>descriptions</em>, <em class=sig-param>verbosity</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TextTestResult title=永久链接至目标>¶</a></dt>
<dd><p>具体实施 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 用于 <a class="reference internal" href=#unittest.TextTestRunner title=unittest.TextTestRunner><code class="xref py py-class docutils literal notranslate"><span class=pre>TextTestRunner</span></code></a> .</p>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能: </span>这个类以前是命名的 <code class="docutils literal notranslate"><span class=pre>_TextTestResult</span></code> . 旧名称仍作为别名存在，但已弃用。</p>
</div>
</dl>
<dl class=data>
<dt id=unittest.defaultTestLoader>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">defaultTestLoader</code><a class=headerlink href=#unittest.defaultTestLoader title=永久链接至目标>¶</a></dt>
<dd><p>的实例 <a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 要共享的类。如果没有自定义 <a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 如果需要，可以使用此实例，而不是重复创建新实例。</p>
</dl>
<dl class=class>
<dt id=unittest.TextTestRunner>
<em class=property>class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TextTestRunner</code><span class=sig-paren>(</span><em class=sig-param>stream=None</em>, <em class=sig-param>descriptions=True</em>, <em class=sig-param>verbosity=1</em>, <em class=sig-param>failfast=False</em>, <em class=sig-param>buffer=False</em>, <em class=sig-param>resultclass=None</em>, <em class=sig-param>warnings=None</em>, <em class=sig-param>*</em>, <em class=sig-param>tb_locals=False</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TextTestRunner title=永久链接至目标>¶</a></dt>
<dd><p>将结果输出到流的基本测试运行程序实现。如果 <em>流动</em> 是 <code class="docutils literal notranslate"><span class=pre>None</span></code> 默认情况下， <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.stderr title=sys.stderr><code class="xref py py-data docutils literal notranslate"><span class=pre>sys.stderr</span></code></a> 用作输出流。这个类有一些可配置的参数，但本质上非常简单。运行测试套件的图形应用程序应该提供替代实现。这样的实现应该接受 <code class="docutils literal notranslate"><span class=pre>**kwargs</span></code> 当特性添加到UnitTest时，构造运行程序的接口将发生更改。</p>
<p>默认情况下，此运行程序显示 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#DeprecationWarning title=DeprecationWarning><code class="xref py py-exc docutils literal notranslate"><span class=pre>DeprecationWarning</span></code></a> ， <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#PendingDeprecationWarning title=PendingDeprecationWarning><code class="xref py py-exc docutils literal notranslate"><span class=pre>PendingDeprecationWarning</span></code></a> ， <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#ResourceWarning title=ResourceWarning><code class="xref py py-exc docutils literal notranslate"><span class=pre>ResourceWarning</span></code></a> 和 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#ImportWarning title=ImportWarning><code class="xref py py-exc docutils literal notranslate"><span class=pre>ImportWarning</span></code></a> 即使他们是 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/warnings.html#warning-ignored><span class="std std-ref">ignored by default</span></a> . 由以下原因引起的拒绝警告： <a class="reference internal" href=#deprecated-aliases><span class="std std-ref">deprecated unittest methods</span></a> 也有特殊情况，当警告过滤器 <code class="docutils literal notranslate"><span class=pre>'default'</span></code> 或 <code class="docutils literal notranslate"><span class=pre>'always'</span></code> ，它们在每个模块中只出现一次，以避免出现过多的警告消息。可以使用python的 <code class="xref std std-option docutils literal notranslate"><span class=pre>-Wd</span></code> 或 <code class="xref std std-option docutils literal notranslate"><span class=pre>-Wa</span></code> 选项（见） <a class="reference internal" href=https://www.osgeo.cn/cpython/using/cmdline.html#using-on-warnings><span class="std std-ref">Warning control</span></a> ）然后离开 <em>警告</em> 到 <code class="docutils literal notranslate"><span class=pre>None</span></code> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>增加了 <code class="docutils literal notranslate"><span class=pre>warnings</span></code> 参数。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>默认流设置为 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.stderr title=sys.stderr><code class="xref py py-data docutils literal notranslate"><span class=pre>sys.stderr</span></code></a> 在实例化时间而不是导入时间。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span>添加了tb_locals参数。</p>
</div>
<dl class=method>
<dt id=unittest.TextTestRunner._makeResult>
<code class="sig-name descname">_makeResult</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.TextTestRunner._makeResult title=永久链接至目标>¶</a></dt>
<dd><p>此方法返回的实例 <code class="docutils literal notranslate"><span class=pre>TestResult</span></code> 被使用 <a class="reference internal" href=#unittest.TextTestRunner.run title=unittest.TextTestRunner.run><code class="xref py py-meth docutils literal notranslate"><span class=pre>run()</span></code></a> . 它不打算直接调用，但可以在子类中重写以提供自定义 <code class="docutils literal notranslate"><span class=pre>TestResult</span></code> .</p>
<p><code class="docutils literal notranslate"><span class=pre>_makeResult()</span></code> 实例化传入的类或可调用的 <code class="docutils literal notranslate"><span class=pre>TextTestRunner</span></code> 作为 <code class="docutils literal notranslate"><span class=pre>resultclass</span></code> 参数。它默认为 <a class="reference internal" href=#unittest.TextTestResult title=unittest.TextTestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TextTestResult</span></code></a> <code class="docutils literal notranslate"><span class=pre>resultclass</span></code> 提供。结果类是用以下参数实例化的：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>stream</span><span class=p>,</span> <span class=n>descriptions</span><span class=p>,</span> <span class=n>verbosity</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.TextTestRunner.run>
<code class="sig-name descname">run</code><span class=sig-paren>(</span><em class=sig-param>test</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.TextTestRunner.run title=永久链接至目标>¶</a></dt>
<dd><p>此方法是 <code class="docutils literal notranslate"><span class=pre>TextTestRunner</span></code> . 此方法需要 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 或 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 实例。一 <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 是通过调用 <a class="reference internal" href=#unittest.TextTestRunner._makeResult title=unittest.TextTestRunner._makeResult><code class="xref py py-func docutils literal notranslate"><span class=pre>_makeResult()</span></code></a> 然后运行测试并将结果打印到stdout。</p>
</dl>
</dl>
<dl class=function>
<dt id=unittest.main>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">main</code><span class=sig-paren>(</span><em class=sig-param>module='__main__'</em>, <em class=sig-param>defaultTest=None</em>, <em class=sig-param>argv=None</em>, <em class=sig-param>testRunner=None</em>, <em class=sig-param>testLoader=unittest.defaultTestLoader</em>, <em class=sig-param>exit=True</em>, <em class=sig-param>verbosity=1</em>, <em class=sig-param>failfast=None</em>, <em class=sig-param>catchbreak=None</em>, <em class=sig-param>buffer=None</em>, <em class=sig-param>warnings=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.main title=永久链接至目标>¶</a></dt>
<dd><p>一种命令行程序，它从 <em>模块</em> 并运行它们；这主要是为了使测试模块方便地执行。此函数的最简单用法是在测试脚本末尾包含以下行：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>'__main__'</span><span class=p>:</span>
    <span class=n>unittest</span><span class=o>.</span><span class=n>main</span><span class=p>()</span>
</pre></div>
</div>
<p>您可以通过传入详细参数来运行包含更详细信息的测试：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>'__main__'</span><span class=p>:</span>
    <span class=n>unittest</span><span class=o>.</span><span class=n>main</span><span class=p>(</span><span class=n>verbosity</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
</pre></div>
</div>
<p>这个 <em>默认测试</em> 参数是单个测试的名称，或者是在没有通过指定测试名称的情况下要运行的测试名称的iterable。 <em>argv</em> . 如果未指定或 <code class="docutils literal notranslate"><span class=pre>None</span></code> 并且没有通过以下方式提供测试名称： <em>argv</em> ，中找到的所有测试 <em>模块</em> 正在运行。</p>
<p>这个 <em>argv</em> 参数可以是传递给程序的选项列表，第一个元素是程序名。如果未指定或 <code class="docutils literal notranslate"><span class=pre>None</span></code> 的价值观 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.argv title=sys.argv><code class="xref py py-data docutils literal notranslate"><span class=pre>sys.argv</span></code></a> 被使用。</p>
<p>这个 <em>特斯特朗</em> 参数可以是测试运行程序类，也可以是已创建的实例。默认情况下 <code class="docutils literal notranslate"><span class=pre>main</span></code> 调用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.exit title=sys.exit><code class="xref py py-func docutils literal notranslate"><span class=pre>sys.exit()</span></code></a> 带有指示测试运行成功或失败的退出代码。</p>
<p>这个 <em>测试加载器</em> 参数必须是 <a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 实例，默认为 <a class="reference internal" href=#unittest.defaultTestLoader title=unittest.defaultTestLoader><code class="xref py py-data docutils literal notranslate"><span class=pre>defaultTestLoader</span></code></a> .</p>
<p><code class="docutils literal notranslate"><span class=pre>main</span></code> 支持通过传入参数从交互式解释器中使用 <code class="docutils literal notranslate"><span class=pre>exit=False</span></code> . 这将在标准输出上显示结果，而不调用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/sys.html#sys.exit title=sys.exit><code class="xref py py-func docutils literal notranslate"><span class=pre>sys.exit()</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest</span> <span class=kn>import</span> <span class=n>main</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>main</span><span class=p>(</span><span class=n>module</span><span class=o>=</span><span class=s1>'test_module'</span><span class=p>,</span> <span class=n>exit</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</pre></div>
</div>
<p>这个 <em>故障快速</em> ， <em>诱捕</em> 和 <em>缓冲区</em> 参数与相同的名称具有相同的效果 <a class="reference internal" href=#command-line-options>command-line options</a> .</p>
<p>这个 <em>警告</em> 参数指定 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/warnings.html#warning-filter><span class="std std-ref">warning filter</span></a> 这应该在运行测试时使用。如果没有指定，它将保留 <code class="docutils literal notranslate"><span class=pre>None</span></code> 如果A <code class="xref std std-option docutils literal notranslate"><span class=pre>-W</span></code> 选项传递给 <strong class=program>python</strong> （见 <a class="reference internal" href=https://www.osgeo.cn/cpython/using/cmdline.html#using-on-warnings><span class="std std-ref">Warning control</span></a> ）否则将设置为 <code class="docutils literal notranslate"><span class=pre>'default'</span></code> .</p>
<p>调用 <code class="docutils literal notranslate"><span class=pre>main</span></code> 实际返回 <code class="docutils literal notranslate"><span class=pre>TestProgram</span></code> 类。它将运行的测试结果存储为 <code class="docutils literal notranslate"><span class=pre>result</span></code> 属性。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.1 版更改: </span>这个 <em>exit</em> 已添加参数。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.2 版更改: </span>这个 <em>冗长</em> ， <em>故障快速</em> ， <em>诱捕</em> ， <em>缓冲区</em> 和 <em>警告</em> 已添加参数。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>这个 <em>默认测试</em> 参数也被更改为接受一个不可重复的测试名称。</p>
</div>
</dl>
<div class=section id=load-tests-protocol>
<h4>负载测试协议<a class=headerlink href=#load-tests-protocol title=永久链接至标题>¶</a></h4>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>模块或包可以通过实现一个名为 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> .</p>
<p>如果测试模块定义 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 它将由 <a class="reference internal" href=#unittest.TestLoader.loadTestsFromModule title=unittest.TestLoader.loadTestsFromModule><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestLoader.loadTestsFromModule()</span></code></a> 参数如下：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>load_tests</span><span class=p>(</span><span class=n>loader</span><span class=p>,</span> <span class=n>standard_tests</span><span class=p>,</span> <span class=n>pattern</span><span class=p>)</span>
</pre></div>
</div>
<p>在哪里？ <em>模式</em> 直接从 <code class="docutils literal notranslate"><span class=pre>loadTestsFromModule</span></code> . 它默认为 <code class="docutils literal notranslate"><span class=pre>None</span></code> .</p>
<p>它应该返回 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> .</p>
<p><em>加载器</em> 是的实例 <a class="reference internal" href=#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>TestLoader</span></code></a> 正在加载。 <em>standard_tests</em> 是默认情况下从模块加载的测试。测试模块通常只希望添加或删除标准测试集中的测试。第三个参数在作为测试发现的一部分加载包时使用。</p>
<p>典型 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 从特定集合加载测试的函数 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 类可能如下所示：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>test_cases</span> <span class=o>=</span> <span class=p>(</span><span class=n>TestCase1</span><span class=p>,</span> <span class=n>TestCase2</span><span class=p>,</span> <span class=n>TestCase3</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>load_tests</span><span class=p>(</span><span class=n>loader</span><span class=p>,</span> <span class=n>tests</span><span class=p>,</span> <span class=n>pattern</span><span class=p>):</span>
    <span class=n>suite</span> <span class=o>=</span> <span class=n>TestSuite</span><span class=p>()</span>
    <span class=k>for</span> <span class=n>test_class</span> <span class=ow>in</span> <span class=n>test_cases</span><span class=p>:</span>
        <span class=n>tests</span> <span class=o>=</span> <span class=n>loader</span><span class=o>.</span><span class=n>loadTestsFromTestCase</span><span class=p>(</span><span class=n>test_class</span><span class=p>)</span>
        <span class=n>suite</span><span class=o>.</span><span class=n>addTests</span><span class=p>(</span><span class=n>tests</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>suite</span>
</pre></div>
</div>
<p>如果在包含包的目录中启动发现，可以从命令行或通过调用 <a class="reference internal" href=#unittest.TestLoader.discover title=unittest.TestLoader.discover><code class="xref py py-meth docutils literal notranslate"><span class=pre>TestLoader.discover()</span></code></a> ，然后是包裹 <code class="file docutils literal notranslate"><span class=pre>__init__.py</span></code> 将检查 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> . 如果该函数不存在，则发现将重新出现在包中，就像它只是另一个目录一样。否则，包测试的发现将保留到 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 使用以下参数调用：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>load_tests</span><span class=p>(</span><span class=n>loader</span><span class=p>,</span> <span class=n>standard_tests</span><span class=p>,</span> <span class=n>pattern</span><span class=p>)</span>
</pre></div>
</div>
<p>这应该返回 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> 表示包中的所有测试。 (<code class="docutils literal notranslate"><span class=pre>standard_tests</span></code> 将只包含从中收集的测试 <code class="file docutils literal notranslate"><span class=pre>__init__.py</span></code> ）</p>
<p>因为模式被传递到 <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 该包可以自由地继续（并且可能修改）测试发现。“无所事事” <code class="docutils literal notranslate"><span class=pre>load_tests</span></code> 测试包的函数如下所示：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>load_tests</span><span class=p>(</span><span class=n>loader</span><span class=p>,</span> <span class=n>standard_tests</span><span class=p>,</span> <span class=n>pattern</span><span class=p>):</span>
    <span class=c1># top level directory cached on loader instance</span>
    <span class=n>this_dir</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=vm>__file__</span><span class=p>)</span>
    <span class=n>package_tests</span> <span class=o>=</span> <span class=n>loader</span><span class=o>.</span><span class=n>discover</span><span class=p>(</span><span class=n>start_dir</span><span class=o>=</span><span class=n>this_dir</span><span class=p>,</span> <span class=n>pattern</span><span class=o>=</span><span class=n>pattern</span><span class=p>)</span>
    <span class=n>standard_tests</span><span class=o>.</span><span class=n>addTests</span><span class=p>(</span><span class=n>package_tests</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>standard_tests</span>
</pre></div>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span>发现不再检查包名称是否匹配 <em>模式</em> 因为包名称不可能与默认模式匹配。</p>
</div>
</div>
</div>
</div>
<div class=section id=class-and-module-fixtures>
<h2>类和模块夹具<a class=headerlink href=#class-and-module-fixtures title=永久链接至标题>¶</a></h2>
<p>类和模块级设备实现于 <a class="reference internal" href=#unittest.TestSuite title=unittest.TestSuite><code class="xref py py-class docutils literal notranslate"><span class=pre>TestSuite</span></code></a> . 当测试套件遇到来自新类的测试时， <code class="xref py py-meth docutils literal notranslate"><span class=pre>tearDownClass()</span></code> 从上一个类（如果有）调用，后跟 <code class="xref py py-meth docutils literal notranslate"><span class=pre>setUpClass()</span></code> 从新类。</p>
<p>同样，如果一个测试来自与前一个测试不同的模块，那么 <code class="docutils literal notranslate"><span class=pre>tearDownModule</span></code> 从上一个模块运行，然后 <code class="docutils literal notranslate"><span class=pre>setUpModule</span></code> 来自新模块。</p>
<p>在所有的测试完成后 <code class="docutils literal notranslate"><span class=pre>tearDownClass</span></code> 和 <code class="docutils literal notranslate"><span class=pre>tearDownModule</span></code> 正在运行。</p>
<p>请注意，共享设备不能很好地与 [潜在的] 像测试并行化和破坏测试隔离之类的特性。使用时应小心。</p>
<p>UnitTest测试加载程序创建的测试的默认顺序是将同一模块和类中的所有测试组合在一起。这将导致 <code class="docutils literal notranslate"><span class=pre>setUpClass</span></code> / <code class="docutils literal notranslate"><span class=pre>setUpModule</span></code> （等）在每个类和模块中被调用一次。如果您随机化顺序，使来自不同模块和类的测试彼此相邻，那么这些共享的fixture函数可以在单个测试运行中多次调用。</p>
<p>共享设备不适用于非标准订购的套房。一 <code class="docutils literal notranslate"><span class=pre>BaseTestSuite</span></code> 对于不希望支持共享设备的框架仍然存在。</p>
<p>如果在某个共享夹具功能期间出现任何异常，则将测试报告为错误。因为没有对应的测试实例 <code class="docutils literal notranslate"><span class=pre>_ErrorHolder</span></code> 对象（具有与 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> ）创建以表示错误。如果您只是使用标准的UnitTest测试运行程序，那么这个细节并不重要，但是如果您是框架作者，那么它可能是相关的。</p>
<div class=section id=setupclass-and-teardownclass>
<h3>设置类和拆卸类<a class=headerlink href=#setupclass-and-teardownclass title=永久链接至标题>¶</a></h3>
<p>这些必须作为类方法实现：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=kn>import</span> <span class=nn>unittest</span>

<span class=k>class</span> <span class=nc>Test</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
    <span class=nd>@classmethod</span>
    <span class=k>def</span> <span class=nf>setUpClass</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
        <span class=bp>cls</span><span class=o>.</span><span class=n>_connection</span> <span class=o>=</span> <span class=n>createExpensiveConnectionObject</span><span class=p>()</span>

    <span class=nd>@classmethod</span>
    <span class=k>def</span> <span class=nf>tearDownClass</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
        <span class=bp>cls</span><span class=o>.</span><span class=n>_connection</span><span class=o>.</span><span class=n>destroy</span><span class=p>()</span>
</pre></div>
</div>
<p>如果你想要 <code class="docutils literal notranslate"><span class=pre>setUpClass</span></code> 和 <code class="docutils literal notranslate"><span class=pre>tearDownClass</span></code> 在调用的基类上，您必须自己调用它们。中的实现 <a class="reference internal" href=#unittest.TestCase title=unittest.TestCase><code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code></a> 是空的。</p>
<p>如果在 <code class="docutils literal notranslate"><span class=pre>setUpClass</span></code> 那么类中的测试就不会运行， <code class="docutils literal notranslate"><span class=pre>tearDownClass</span></code> 不运行。跳过的类将没有 <code class="docutils literal notranslate"><span class=pre>setUpClass</span></code> 或 <code class="docutils literal notranslate"><span class=pre>tearDownClass</span></code> 运行。如果例外是 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> 异常，则该类将被报告为已跳过而不是错误。</p>
</div>
<div class=section id=setupmodule-and-teardownmodule>
<h3>设置模块和拆卸模块<a class=headerlink href=#setupmodule-and-teardownmodule title=永久链接至标题>¶</a></h3>
<p>这些应该作为函数来实现：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>def</span> <span class=nf>setUpModule</span><span class=p>():</span>
    <span class=n>createConnection</span><span class=p>()</span>

<span class=k>def</span> <span class=nf>tearDownModule</span><span class=p>():</span>
    <span class=n>closeConnection</span><span class=p>()</span>
</pre></div>
</div>
<p>如果在 <code class="docutils literal notranslate"><span class=pre>setUpModule</span></code> 然后模块中的任何测试都不会运行，并且 <code class="docutils literal notranslate"><span class=pre>tearDownModule</span></code> 不会运行。如果例外是 <a class="reference internal" href=#unittest.SkipTest title=unittest.SkipTest><code class="xref py py-exc docutils literal notranslate"><span class=pre>SkipTest</span></code></a> 异常，则模块将被报告为已跳过而不是错误。</p>
<p>要添加即使在发生异常时也必须运行的清理代码，请使用 <code class="docutils literal notranslate"><span class=pre>addModuleCleanup</span></code> ：</p>
<dl class=function>
<dt id=unittest.addModuleCleanup>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">addModuleCleanup</code><span class=sig-paren>(</span><em class=sig-param>function</em>, <em class=sig-param>/</em>, <em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.addModuleCleanup title=永久链接至目标>¶</a></dt>
<dd><p>添加要在其之后调用的函数 <code class="xref py py-func docutils literal notranslate"><span class=pre>tearDownModule()</span></code> 清理测试类期间使用的资源。函数将按与添加顺序相反的顺序调用 (<abbr title="last-in, first-out">LIFO</abbr> ）调用它们时，会将任何参数和关键字参数传递到 <a class="reference internal" href=#unittest.addModuleCleanup title=unittest.addModuleCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>addModuleCleanup()</span></code></a> 当它们被添加时。</p>
<p>如果 <code class="xref py py-meth docutils literal notranslate"><span class=pre>setUpModule()</span></code> 失败，意味着 <code class="xref py py-func docutils literal notranslate"><span class=pre>tearDownModule()</span></code> 未调用，则仍将调用添加的任何清理函数。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dl>
<dl class=function>
<dt id=unittest.doModuleCleanups>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">doModuleCleanups</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.doModuleCleanups title=永久链接至目标>¶</a></dt>
<dd><p>此函数在以下时间之后无条件调用 <code class="xref py py-func docutils literal notranslate"><span class=pre>tearDownModule()</span></code> ，或之后 <code class="xref py py-func docutils literal notranslate"><span class=pre>setUpModule()</span></code> 如果 <code class="xref py py-func docutils literal notranslate"><span class=pre>setUpModule()</span></code> 引发异常。</p>
<p>它负责调用由 <code class="xref py py-func docutils literal notranslate"><span class=pre>addCleanupModule()</span></code> .如果需要调用清理函数 <em>先前的</em> 到 <code class="xref py py-func docutils literal notranslate"><span class=pre>tearDownModule()</span></code> 然后你可以调用 <a class="reference internal" href=#unittest.doModuleCleanups title=unittest.doModuleCleanups><code class="xref py py-func docutils literal notranslate"><span class=pre>doModuleCleanups()</span></code></a> 你自己。</p>
<p><a class="reference internal" href=#unittest.doModuleCleanups title=unittest.doModuleCleanups><code class="xref py py-func docutils literal notranslate"><span class=pre>doModuleCleanups()</span></code></a> 一次从清理函数堆栈中弹出一个方法，以便随时调用它。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dl>
</div>
</div>
<div class=section id=signal-handling>
<h2>信号处理<a class=headerlink href=#signal-handling title=永久链接至标题>¶</a></h2>
<div class=versionadded>
<p><span class="versionmodified added">3.2 新版功能.</span></p>
</div>
<p>这个 <a class="reference internal" href=#cmdoption-unittest-c><code class="xref std std-option docutils literal notranslate"><span class=pre>-c/--catch</span></code></a> 用于UnitTest的命令行选项，以及 <code class="docutils literal notranslate"><span class=pre>catchbreak</span></code> 参数到 <a class="reference internal" href=#unittest.main title=unittest.main><code class="xref py py-func docutils literal notranslate"><span class=pre>unittest.main()</span></code></a> ，在测试运行期间提供对Control-C更友好的处理。启用catch break行为后，control-c将允许当前运行的测试完成，然后测试运行将结束并报告到目前为止的所有结果。第二个控制器C将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#KeyboardInterrupt title=KeyboardInterrupt><code class="xref py py-exc docutils literal notranslate"><span class=pre>KeyboardInterrupt</span></code></a> 以通常的方式。</p>
<p>Control-C处理信号处理程序试图与安装自己的代码或测试保持兼容。 <code class="xref py py-const docutils literal notranslate"><span class=pre>signal.SIGINT</span></code> 处理程序。如果 <code class="docutils literal notranslate"><span class=pre>unittest</span></code> 调用了处理程序，但 <em>不是</em> 安装的 <code class="xref py py-const docutils literal notranslate"><span class=pre>signal.SIGINT</span></code> 处理程序，即它已经被被被测试的系统替换并委托给，然后它调用默认的处理程序。这通常是替换已安装处理程序并委托给它的代码所期望的行为。对于需要 <code class="docutils literal notranslate"><span class=pre>unittest</span></code> Control-C处理已禁用 <a class="reference internal" href=#unittest.removeHandler title=unittest.removeHandler><code class="xref py py-func docutils literal notranslate"><span class=pre>removeHandler()</span></code></a> 可以使用装饰器。</p>
<p>框架作者可以使用一些实用程序函数在测试框架中启用Control-C处理功能。</p>
<dl class=function>
<dt id=unittest.installHandler>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">installHandler</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.installHandler title=永久链接至目标>¶</a></dt>
<dd><p>安装Control-C处理程序。当A <code class="xref py py-const docutils literal notranslate"><span class=pre>signal.SIGINT</span></code> 收到（通常是响应用户按control-c）所有注册结果 <a class="reference internal" href=#unittest.TestResult.stop title=unittest.TestResult.stop><code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code></a> 调用。</p>
</dl>
<dl class=function>
<dt id=unittest.registerResult>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">registerResult</code><span class=sig-paren>(</span><em class=sig-param>result</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.registerResult title=永久链接至目标>¶</a></dt>
<dd><p>注册A <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 用于Control-C处理的对象。注册结果会存储对它的弱引用，因此它不会阻止对结果进行垃圾收集。</p>
<p>注册A <a class="reference internal" href=#unittest.TestResult title=unittest.TestResult><code class="xref py py-class docutils literal notranslate"><span class=pre>TestResult</span></code></a> 如果不启用Control-C处理，则对象没有副作用，因此测试框架可以无条件地注册它们创建的所有结果，而不管是否启用处理。</p>
</dl>
<dl class=function>
<dt id=unittest.removeResult>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">removeResult</code><span class=sig-paren>(</span><em class=sig-param>result</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.removeResult title=永久链接至目标>¶</a></dt>
<dd><p>删除已注册的结果。一旦结果被删除，那么 <a class="reference internal" href=#unittest.TestResult.stop title=unittest.TestResult.stop><code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code></a> 将不再对该结果对象调用以响应Control-C。</p>
</dl>
<dl class=function>
<dt id=unittest.removeHandler>
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">removeHandler</code><span class=sig-paren>(</span><em class=sig-param>function=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.removeHandler title=永久链接至目标>¶</a></dt>
<dd><p>在没有参数的情况下调用此函数时，如果已安装了Control-C处理程序，则该函数将删除它。此函数还可用作测试装饰器，以便在执行测试时临时删除处理程序：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@unittest</span><span class=o>.</span><span class=n>removeHandler</span>
<span class=k>def</span> <span class=nf>test_signal_handling</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
    <span class=o>...</span>
</pre></div>
</div>
</dl>
</div>
</div>
 </div>
 </div>
 </div>
 
 
 </div> 
 
 
 
<div id=saladict-saladbowl-root class="saladict-div saladict-external" style=display:none!important><div class=saladict-external style=display:none!important><template shadowmode=open style=display:none!important><div style=animation:initial;transition:initial;color:initial;font:initial;font-feature-settings:initial;font-kerning:initial;font-optical-sizing:initial;font-variation-settings:initial;text-orientation:initial;text-rendering:initial;-webkit-font-smoothing:initial;-webkit-locale:initial;-webkit-text-orientation:initial;-webkit-writing-mode:initial;writing-mode:initial;zoom:initial;place-content:initial;place-items:initial;place-self:initial;alignment-baseline:initial;backdrop-filter:initial;backface-visibility:initial;background:initial;background-blend-mode:initial;baseline-shift:initial;block-size:initial;border-block-end:initial;border-block-start:initial;border:initial;border-radius:initial;border-collapse:initial;border-inline-end:initial;border-inline-start:initial;bottom:initial;box-shadow:initial;box-sizing:initial;break-after:initial;break-before:initial;break-inside:initial;buffered-rendering:initial;caption-side:initial;caret-color:initial;clear:initial;clip:initial;clip-path:initial;clip-rule:initial;color-interpolation:initial;color-interpolation-filters:initial;color-rendering:initial;columns:initial;column-fill:initial;gap:initial;column-rule:initial;column-span:initial;contain:initial;content:initial;counter-increment:initial;counter-reset:initial;cursor:initial;cx:initial;cy:initial;d:initial;display:none!important;dominant-baseline:initial;empty-cells:initial;fill:initial;fill-opacity:initial;fill-rule:initial;filter:initial;flex:initial;flex-flow:initial;float:initial;flood-color:initial;flood-opacity:initial;grid:initial;grid-area:initial;height:initial;hyphens:initial;image-rendering:initial;inline-size:initial;isolation:initial;left:initial;letter-spacing:initial;lighting-color:initial;line-break:initial;list-style:initial;margin-block-end:initial;margin-block-start:initial;margin:initial;margin-inline-end:initial;margin-inline-start:initial;marker:initial;mask:initial;mask-type:initial;max-block-size:initial;max-height:initial;max-inline-size:initial;max-width:initial;min-block-size:initial;min-height:initial;min-inline-size:initial;min-width:initial;mix-blend-mode:initial;object-fit:initial;object-position:initial;offset:initial;opacity:initial;order:initial;orphans:initial;outline:initial;outline-offset:initial;overflow-anchor:initial;overflow-wrap:initial;overflow:initial;overscroll-behavior-block:initial;overscroll-behavior-inline:initial;overscroll-behavior:initial;padding-block-end:initial;padding-block-start:initial;padding:initial;padding-inline-end:initial;padding-inline-start:initial;page:initial;paint-order:initial;perspective:initial;perspective-origin:initial;pointer-events:initial;position:initial;quotes:initial;r:initial;resize:initial;right:initial;rx:initial;ry:initial;scroll-behavior:initial;scroll-margin-block:initial;scroll-margin:initial;scroll-margin-inline:initial;scroll-padding-block:initial;scroll-padding:initial;scroll-padding-inline:initial;scroll-snap-align:initial;scroll-snap-stop:initial;scroll-snap-type:initial;shape-image-threshold:initial;shape-margin:initial;shape-outside:initial;shape-rendering:initial;size:initial;speak:initial;stop-color:initial;stop-opacity:initial;stroke:initial;stroke-dasharray:initial;stroke-dashoffset:initial;stroke-linecap:initial;stroke-linejoin:initial;stroke-miterlimit:initial;stroke-opacity:initial;stroke-width:initial;tab-size:initial;table-layout:initial;text-align:initial;text-align-last:initial;text-anchor:initial;text-combine-upright:initial;text-decoration:initial;text-decoration-skip-ink:initial;text-indent:initial;text-overflow:initial;text-shadow:initial;text-size-adjust:initial;text-transform:initial;text-underline-position:initial;top:initial;touch-action:initial;transform:initial;transform-box:initial;transform-origin:initial;transform-style:initial;user-select:initial;vector-effect:initial;vertical-align:initial;visibility:initial;-webkit-app-region:initial;-webkit-appearance:initial;border-spacing:initial;-webkit-border-image:initial;-webkit-box-align:initial;-webkit-box-decoration-break:initial;-webkit-box-direction:initial;-webkit-box-flex:initial;-webkit-box-ordinal-group:initial;-webkit-box-orient:initial;-webkit-box-pack:initial;-webkit-box-reflect:initial;-webkit-font-size-delta:initial;-webkit-highlight:initial;-webkit-hyphenate-character:initial;-webkit-line-break:initial;-webkit-line-clamp:initial;-webkit-margin-collapse:initial;-webkit-margin-bottom-collapse:initial;-webkit-margin-top-collapse:initial;-webkit-mask-box-image:initial;-webkit-mask:initial;-webkit-mask-composite:initial;-webkit-perspective-origin-x:initial;-webkit-perspective-origin-y:initial;-webkit-print-color-adjust:initial;-webkit-rtl-ordering:initial;-webkit-ruby-position:initial;-webkit-tap-highlight-color:initial;-webkit-text-combine:initial;-webkit-text-decorations-in-effect:initial;-webkit-text-emphasis:initial;-webkit-text-emphasis-position:initial;-webkit-text-fill-color:initial;-webkit-text-security:initial;-webkit-text-stroke:initial;-webkit-transform-origin-x:initial;-webkit-transform-origin-y:initial;-webkit-transform-origin-z:initial;-webkit-user-drag:initial;-webkit-user-modify:initial;white-space:initial;widows:initial;width:initial;will-change:initial;word-break:initial;word-spacing:initial;x:initial;y:initial;z-index:initial><style>.saladbowl{position:fixed;z-index:2147483647;top:0;left:0;width:30px;height:30px;-moz-user-select:none;user-select:none;cursor:pointer}.isAnimate.saladbowl{will-change:transform;transition:transform .3s ease-out}.isAnimate.saladbowl.enableHover:hover .saladbowl-leaf{animation:saladbowl-leaf-shake .7s infinite linear}.isAnimate.saladbowl.enableHover:hover .saladbowl-orange{transform-origin:301.8px 187.4px;animation:saladbowl-orange-spin .7s infinite linear}.isAnimate.saladbowl.enableHover:hover .saladbowl-tomato{transform-origin:297.8px 126.4px;animation:saladbowl-tomato-shake .7s infinite linear}.isAnimate.saladbowl-enter-active>svg{animation:saladbowl-jelly 1s linear}.isAnimate.saladbowl-exit{opacity:1}.isAnimate.saladbowl-exit-active{opacity:0;transition:opacity .1s}.saladbowl-exit-done{display:none}@keyframes saladbowl-jelly{0%{transform:matrix3d(.5,0,0,0,0,.5,0,0,0,0,1,0,0,0,0,1)}3.40%{transform:matrix3d(.658,0,0,0,0,.703,0,0,0,0,1,0,0,0,0,1)}4.70%{transform:matrix3d(.725,0,0,0,0,.8,0,0,0,0,1,0,0,0,0,1)}6.81%{transform:matrix3d(.83,0,0,0,0,.946,0,0,0,0,1,0,0,0,0,1)}9.41%{transform:matrix3d(.942,0,0,0,0,1.084,0,0,0,0,1,0,0,0,0,1)}10.21%{transform:matrix3d(.971,0,0,0,0,1.113,0,0,0,0,1,0,0,0,0,1)}13.61%{transform:matrix3d(1.062,0,0,0,0,1.166,0,0,0,0,1,0,0,0,0,1)}14.11%{transform:matrix3d(1.07,0,0,0,0,1.165,0,0,0,0,1,0,0,0,0,1)}17.52%{transform:matrix3d(1.104,0,0,0,0,1.12,0,0,0,0,1,0,0,0,0,1)}18.72%{transform:matrix3d(1.106,0,0,0,0,1.094,0,0,0,0,1,0,0,0,0,1)}21.32%{transform:matrix3d(1.098,0,0,0,0,1.035,0,0,0,0,1,0,0,0,0,1)}24.32%{transform:matrix3d(1.075,0,0,0,0,.98,0,0,0,0,1,0,0,0,0,1)}25.23%{transform:matrix3d(1.067,0,0,0,0,.969,0,0,0,0,1,0,0,0,0,1)}29.03%{transform:matrix3d(1.031,0,0,0,0,.948,0,0,0,0,1,0,0,0,0,1)}29.93%{transform:matrix3d(1.024,0,0,0,0,.949,0,0,0,0,1,0,0,0,0,1)}35.54%{transform:matrix3d(.99,0,0,0,0,.981,0,0,0,0,1,0,0,0,0,1)}36.74%{transform:matrix3d(.986,0,0,0,0,.989,0,0,0,0,1,0,0,0,0,1)}41.04%{transform:matrix3d(.98,0,0,0,0,1.011,0,0,0,0,1,0,0,0,0,1)}44.44%{transform:matrix3d(.983,0,0,0,0,1.016,0,0,0,0,1,0,0,0,0,1)}52.15%{transform:matrix3d(.996,0,0,0,0,1.003,0,0,0,0,1,0,0,0,0,1)}59.86%{transform:matrix3d(1.003,0,0,0,0,.995,0,0,0,0,1,0,0,0,0,1)}63.26%{transform:matrix3d(1.004,0,0,0,0,.996,0,0,0,0,1,0,0,0,0,1)}75.28%{transform:matrix3d(1.001,0,0,0,0,1.002,0,0,0,0,1,0,0,0,0,1)}85.49%{transform:matrix3d(.999,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}90.69%{transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}100%{transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}}@keyframes saladbowl-leaf-shake{0%{transform:translate(2px,1px) rotate(0)}10%{transform:translate(-1px,-2px) rotate(1deg)}20%{transform:translate(-2px,0) rotate(1deg)}30%{transform:translate(0,2px) rotate(0)}40%{transform:translate(1px,-1px) rotate(1deg)}50%{transform:translate(-1px,2px) rotate(1deg)}60%{transform:translate(-2px,1px) rotate(0)}70%{transform:translate(2px,1px) rotate(1deg)}80%{transform:translate(-1px,-1px) rotate(1deg)}90%{transform:translate(2px,2px) rotate(0)}100%{transform:translate(1px,-2px) rotate(1deg)}}@keyframes saladbowl-orange-spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes saladbowl-tomato-shake{0%{transform:rotate(10deg)}30%{transform:rotate(0)}60%{transform:rotate(10deg)}90%{transform:rotate(0)}100%{transform:rotate(5deg)}}</style><div role=img class="saladbowl saladict-external enableHover saladbowl-enter-done" style=transform:translate(1096px,503px);display:none!important><svg viewBox="0 0 612 612" width=30 height=30><g class=saladbowl-leaf><path fill=#6bbc57 d="M 577.557 184.258 C 560.417 140.85 519.54 59.214 519.54 59.214 L 519.543 59.204 C 519.543 59.204 436.903 97.626 396.441 120.878 C 366.171 138.274 354.981 169.755 352.221 177.621 C 349.001 186.851 339.891 228.811 358.341 268.481 C 382.271 319.921 409.201 374.521 409.201 374.521 L 409.201 374.531 C 409.201 374.531 464.511 348.701 515.291 323.401 C 554.451 303.891 573.591 265.441 576.821 256.221 C 579.571 248.356 590.398 216.746 577.574 184.271 Z"></path><path fill=#bde9b7 d="M 501.052 102.162 L 507.518 104.425 L 426.69 335.38 L 420.224 333.117 Z"></path></g><g class=saladbowl-orange><circle fill=#ffb30d cx=299.756 cy=198.246 r=178.613></circle><circle fill=#fce29c cx=299.756 cy=198.246 r=155.24></circle><path fill=#fcc329 d="M 299.756 189.873 L 341.269 113.475 C 349.169 82.543 324.349 58.588 299.749 57.891 C 275.149 57.201 248.229 82.781 256.489 113.481 L 299.749 189.881 Z M 307.026 194.757 L 393.974 194.757 C 424.928 187.083 434.124 153.681 422.994 131.737 C 411.864 109.795 376.534 98.357 353.5 120.27 L 307.025 194.757 Z M 308.79 203.444 L 354.885 277.168 C 377.925 299.268 410.995 289.438 423.701 268.368 C 436.411 247.298 427.381 211.276 396.591 203.362 L 308.801 203.442 Z M 300.208 206.618 L 259.628 283.516 C 252.098 314.543 277.214 338.193 301.815 338.591 C 326.415 338.991 353.022 313.081 344.392 282.491 L 300.208 206.631 Z M 292.058 203.3 L 205.108 203.415 C 174.163 211.277 165.014 244.54 176.172 266.468 C 187.33 288.396 226.052 300.541 249.056 278.598 L 292.056 203.301 Z M 292.465 194.83 L 246.497 121.024 C 223.494 98.884 190.409 108.658 177.667 129.706 C 164.925 150.753 173.893 186.791 204.669 194.756 L 292.459 194.829 Z"></path></g><g class=saladbowl-tomato><path fill=#a63131 d="M 71.014 337.344 C 147.291 422.594 278.234 429.866 363.482 353.589 L 87.258 44.87 C 2.01 121.15 -5.262 252.092 71.014 337.342 Z"></path><path fill=#bc5757 d="M 101.447 310.115 C 162.685 378.555 267.811 384.393 336.251 323.155 L 114.49 75.31 C 46.047 136.55 40.21 241.674 101.447 310.115 Z"></path><path fill=#f1d4af d="M 186.412 237.54 L 151.659 245.444 C 139.989 251.384 139.339 265.51 145.779 273.27 C 152.219 281.028 167.379 282.39 174.599 271.538 L 186.399 237.54 Z M 242.062 269.832 L 223.366 300.175 C 219.439 312.658 229.066 323.018 239.116 323.85 C 249.168 324.685 260.756 314.815 258.061 302.065 L 242.061 269.832 Z M 160.202 178.317 L 130.357 158.837 C 117.98 154.585 107.375 163.939 106.277 173.965 C 105.183 183.99 114.747 195.833 127.563 193.471 L 160.203 178.321 Z"></path></g><g class=saladbowl-bowl><path fill=#2d97b7 d="M 30.857 311.46 C 30.857 429.87 105.371 530.8 209.867 569.52 L 209.867 589.2 L 400.987 589.2 L 400.987 568.9 C 503.595 530.114 576.887 431.202 578.31 314.907 L 589.196 295.97 L 22.804 295.97 L 30.867 309.998 C 30.865 310.488 30.857 310.971 30.857 311.458 Z"></path><path fill=#fff d="M 540.565 321.42 C 540.585 322.587 540.595 323.755 540.595 324.927 C 540.595 405.941 497.513 476.884 433.015 516.122 L 437.178 523.317 C 504.152 482.64 548.895 409.009 548.895 324.927 C 548.895 323.755 548.885 322.587 548.865 321.419 Z M 399.885 532.68 C 388.298 537.31 376.237 541.002 363.793 543.654 L 363.793 544.45 L 364.971 551.893 C 378.481 549.049 391.551 545.018 404.081 539.935 Z"></path></g></svg></div></div></template></div></div>