<!DOCTYPE html> <html xmlns=http://www.w3.org/1999/xhtml lang=zh_CN><!--
 Page saved with SingleFile 
 url: https://docs.python.org/zh-cn/3.9/library/unittest.mock.html 
 saved date: Thu Jun 18 2020 05:55:47 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<title>unittest.mock --- mock对象库 — Python 3.9.0b3 文档</title>
<style>:root{--sf-img-1:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gEGxE4IQYzJ14AAAI3SURBVDjLZZNPSFVBFIe/e9+zd3silBCl0SZoU4s2rVq0EB5tQip4UNvATVGu3QRBiyAi2iltWkgbF5EgRhFFRpiWtrWIzDIV1Pzz7p15M2fmtvDevOqBw8DM9zvnN8ycgF3R/eDtM2mac96ZdrFNxBikqbRV+vHH/ut9gAZczoe7C3gnF0f6au1OLM5avFi8d1Ea+JvAMSAq8nsKOGs5f2cYJ3Y7rc2PO4BqkS8DdD98f9tbe1ysCoxOBo1qlEXHJWcM4b5KPU19zleA0o4Clx99eO3EdqVewHsCoFRugUoVghJO7A6H6Vx9wdtYi27cr5x6dy/03nVtWTU7bWeZh6jNUcAiCaFTURl9A+gs56AviHzh3mnqtdPxm6knfQPLU7UaokASQq/agY7yDrG16Mba6Pz48NP56VdrgAApYObGaicPtkovToFLQBKA/WUxTe3FRk4san15aGKgd3Dj560rrdGJS6FT0X9YYvLuiMKL1kAQOpHZ3PqfyZfP41+9PW1VfzX0RXFSECfgNEmSTgImdDruF2O0E8vvqZG1auQubAsKooIYYHpGvwA2g+xndQBHgWa6cG0ih5cW/w6VvEq3nChwCoBvs+bL2Z7VceBHGTDAIrABpMVuhw+4OiLgLIglOLPYBTQAlfErIeCzjRVg1dtEb1kt5Omv+DTV2YssAN+zNdkzC42N9brV8WdvYp07seOdM2Of1F3AAknW0AJpwN6IgEPAEaANaMlcbmZdl7KRBuAfAb+v//yMAJoAAAAASUVORK5CYII=")}div.clearer{clear:both}div.related{width:100%;font-size:90%}div.related ul{margin:0;padding:0 0 0 10px;list-style:none}div.related li{display:inline}div.related li.right{float:right;margin-right:5px}div.sphinxsidebarwrapper{padding:10px 5px 0 10px}div.sphinxsidebar{float:left;width:230px;margin-left:-100%;word-wrap:break-word;overflow-wrap:break-word}div.sphinxsidebar ul{list-style:none}div.sphinxsidebar ul ul{margin-left:20px;list-style:square}div.sphinxsidebar ul ul{margin-top:0;margin-bottom:0}img{border:0;max-width:100%}div.body{min-width:450px;max-width:800px}div.body p,div.body dd,div.body li,div.body blockquote{-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto}a.headerlink{visibility:hidden}a.brackets:before,span.brackets>a:before{content:"["}a.brackets:after,span.brackets>a:after{content:"]"}h1:hover>a.headerlink,h2:hover>a.headerlink,h3:hover>a.headerlink,h4:hover>a.headerlink,h5:hover>a.headerlink,h6:hover>a.headerlink,dt:hover>a.headerlink,caption:hover>a.headerlink,p.caption:hover>a.headerlink,div.code-block-caption:hover>a.headerlink{visibility:visible}div.admonition{margin-top:10px;margin-bottom:10px;padding:7px}p.admonition-title{margin:0px 10px 5px 0px;font-weight:bold}li>p:first-child{margin-top:0px}li>p:last-child{margin-bottom:0px}dl.footnote>dt{float:left}dl.footnote>dd{margin-bottom:0em}dl.footnote>dd:after,dl.citation>dd:after{content:"";clear:both}dl{margin-bottom:15px}dd>p:first-child{margin-top:0px}dd ul{margin-bottom:10px}dd{margin-top:3px;margin-bottom:10px;margin-left:30px}dt:target,span.highlighted{background-color:#fbe54e}.sig-paren{font-size:larger}.versionmodified{font-style:italic}.footnote:target{background-color:#ffa}pre{overflow:auto;overflow-y:hidden}span.pre{-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;hyphens:none}div.doctest>div.highlight span.gp{user-select:none}code.descname{background-color:transparent;font-weight:bold}code.descclassname{background-color:transparent}code.xref{background-color:transparent;font-weight:bold}html{background-color:#fff}body{font-family:'Lucida Grande',Arial,sans-serif;font-size:100%;color:#000;margin:0;padding:0}div.document{background-color:white}div.documentwrapper{float:left;width:100%}div.bodywrapper{margin:0 0 0 230px}div.body{background-color:white;color:#222}div.footer{color:#555;padding:9px 0 9px 0;font-size:75%}div.footer a{color:#555;text-decoration:underline}div.related{background-color:white;line-height:30px;color:#666}div.related a{color:#444}div.sphinxsidebar h3{font-family:'Lucida Grande',Arial,sans-serif;color:#444;font-size:1.4em;font-weight:normal;margin:0;padding:0}div.sphinxsidebar h3 a{color:#444}div.sphinxsidebar h4{font-family:'Lucida Grande',Arial,sans-serif;color:#444;font-size:1.3em;font-weight:normal;margin:5px 0 0 0;padding:0}div.sphinxsidebar p{color:#444}div.sphinxsidebar p.topless{margin:5px 10px 10px 10px}div.sphinxsidebar ul{margin:10px;padding:0;color:#444}div.sphinxsidebar a{color:#444}a{color:#0090c0;text-decoration:none}a:visited{color:#00608f;text-decoration:none}a:hover{text-decoration:underline}div.body h1,div.body h2,div.body h3{font-family:'Lucida Grande',Arial,sans-serif;background-color:white;font-weight:normal;color:#1a1a1a;border-bottom:1px solid #ccc}div.body h1{margin-top:0;font-size:200%}div.body h2{font-size:160%}div.body h3{font-size:140%}a.headerlink{font-size:.8em;padding:0 4px 0 4px;text-decoration:none}a.headerlink:hover{background-color:#aaa;color:white}div.body p,div.body dd,div.body li,div.body blockquote{text-align:justify;line-height:130%}div.admonition p.admonition-title+p{display:inline}div.admonition p{margin-bottom:5px}div.admonition pre{margin-bottom:5px}div.note{background-color:#eee;border:1px solid #ccc}p.admonition-title{display:inline}p.admonition-title:after{content:":"}pre{padding:5px;background-color:#efc;color:#333;line-height:120%;border-left:0;border-right:0}code{background-color:#ecf0f3;padding:0 1px 0 1px}.note code{background:#d6d6d6}body{background-color:white;margin-left:1em;margin-right:1em}div.related{margin-bottom:1.2em;padding:.5em 0;border-top:1px solid #ccc;margin-top:.5em}div.related a:hover{color:#0095c4}div.related:first-child{border-top:0;border-bottom:1px solid #ccc}.inline-search{display:inline}form.inline-search input{display:inline}form.inline-search input[type="submit"]{width:40px}div.sphinxsidebar{background-color:#eee;border-radius:5px;line-height:130%;font-size:smaller}div.sphinxsidebar h3,div.sphinxsidebar h4{margin-top:1.5em}div.sphinxsidebarwrapper>h3:first-child{margin-top:.2em}div.sphinxsidebarwrapper>ul>li>ul>li{margin-bottom:.4em}div.sphinxsidebar a:hover{color:#0095c4}form.inline-search input{font-family:'Lucida Grande',Arial,sans-serif;border:1px solid #999;font-size:smaller;border-radius:3px}div.body{padding:0 0 0 1.2em}div.body p{line-height:140%}div.body h1,div.body h2,div.body h3{margin:0;border:0;padding:.3em 0}div.body hr{border:0;background-color:#ccc;height:1px}div.body pre{border-radius:3px;border:1px solid #ac9}div.body div.admonition{border-radius:3px}div.body a{color:#0072aa}div.body a:visited{color:#6363bb}div.body a:hover{color:#00b0e4}code,pre{font-family:monospace,sans-serif;font-size:96.5%}div.body code{border-radius:3px}div.body code.descname{font-size:120%}div.body code.xref{font-weight:normal}div.footer{line-height:150%;margin-top:-2em;text-align:right;width:auto;margin-right:10px}div.footer a:hover{color:#0095c4}.highlight{background:none!important}dl>dt span~em{font-family:monospace,sans-serif}.highlight{background:#efc}.highlight .c{color:#408090;font-style:italic}.highlight .k{color:#007020;font-weight:bold}.highlight .o{color:#666}.highlight .c1{color:#408090;font-style:italic}.highlight .gr{color:red}.highlight .go{color:#333}.highlight .gp{color:#c65d09;font-weight:bold}.highlight .gt{color:#04d}.highlight .kc{color:#007020;font-weight:bold}.highlight .kn{color:#007020;font-weight:bold}.highlight .nb{color:#007020}.highlight .nc{color:#0e84b5;font-weight:bold}.highlight .nd{color:#555;font-weight:bold}.highlight .ne{color:#007020}.highlight .nf{color:#06287e}.highlight .nn{color:#0e84b5;font-weight:bold}.highlight .ow{color:#007020;font-weight:bold}.highlight .mf{color:#208050}.highlight .mi{color:#208050}.highlight .s2{color:#4070a0}.highlight .se{color:#4070a0;font-weight:bold}.highlight .s1{color:#4070a0}.highlight .bp{color:#007020}.highlight .fm{color:#06287e}.highlight .vm{color:#bb60d5}</style>
<link rel=search type=application/opensearchdescription+xml title="在 Python 3.9.0b3 文档 中搜索" href=https://docs.python.org/zh-cn/3.9/_static/opensearch.xml>
<link rel=author title=关于这些文档 href=https://docs.python.org/zh-cn/3.9/about.html>
<link rel=index title=索引 href=https://docs.python.org/zh-cn/3.9/genindex.html>
<link rel=search title=搜索 href=https://docs.python.org/zh-cn/3.9/search.html>
<link rel=copyright title=版权所有 href=https://docs.python.org/zh-cn/3.9/copyright.html>
<link rel=next title="unittest.mock 上手指南" href=https://docs.python.org/zh-cn/3.9/library/unittest.mock-examples.html>
<link rel=prev title="unittest --- 单元测试框架" href=https://docs.python.org/zh-cn/3.9/library/unittest.html>
<link rel=canonical href=https://docs.python.org/3/library/unittest.mock.html>
<style>@-webkit-keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@-webkit-keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gEGxE4IQYzJ14AAAI3SURBVDjLZZNPSFVBFIe/e9+zd3silBCl0SZoU4s2rVq0EB5tQip4UNvATVGu3QRBiyAi2iltWkgbF5EgRhFFRpiWtrWIzDIV1Pzz7p15M2fmtvDevOqBw8DM9zvnN8ycgF3R/eDtM2mac96ZdrFNxBikqbRV+vHH/ut9gAZczoe7C3gnF0f6au1OLM5avFi8d1Ea+JvAMSAq8nsKOGs5f2cYJ3Y7rc2PO4BqkS8DdD98f9tbe1ysCoxOBo1qlEXHJWcM4b5KPU19zleA0o4Clx99eO3EdqVewHsCoFRugUoVghJO7A6H6Vx9wdtYi27cr5x6dy/03nVtWTU7bWeZh6jNUcAiCaFTURl9A+gs56AviHzh3mnqtdPxm6knfQPLU7UaokASQq/agY7yDrG16Mba6Pz48NP56VdrgAApYObGaicPtkovToFLQBKA/WUxTe3FRk4san15aGKgd3Dj560rrdGJS6FT0X9YYvLuiMKL1kAQOpHZ3PqfyZfP41+9PW1VfzX0RXFSECfgNEmSTgImdDruF2O0E8vvqZG1auQubAsKooIYYHpGvwA2g+xndQBHgWa6cG0ih5cW/w6VvEq3nChwCoBvs+bL2Z7VceBHGTDAIrABpMVuhw+4OiLgLIglOLPYBTQAlfErIeCzjRVg1dtEb1kt5Omv+DTV2YssAN+zNdkzC42N9brV8WdvYp07seOdM2Of1F3AAknW0AJpwN6IgEPAEaANaMlcbmZdl7KRBuAfAb+v//yMAJoAAAAASUVORK5CYII="><style>.sf-hidden{display:none!important}</style><body><style>.cyxy-target-popup{padding:1.3rem 12px;position:absolute;display:-webkit-flex;flex-direction:row;overflow:scroll;vertical-align:middle;z-index:199099;top:1px;left:1px;background:#fff;opacity:0.98;height:auto;width:auto;border:1px solid #E6E6E6;box-shadow:0 0 8px 0 rgba(0,0,0,0.13);border-radius:5px}@media (max-width:468px){.cyxy-target-popup{left:10%}}.cyxy-footer{position:fixed;bottom:0px;padding:0px 0px;left:0;right:0;margin:auto;border:1px solid #E6E6E6;box-shadow:0 0 8px 0 rgba(0,0,0,0.13);border-radius:2px;z-index:201712;text-align:center}.cyxy-footer-p{padding:12px 0px;margin:0px;font-size:12px;color:#333;background:#fff;text-align:center;line-height:1.6;font-weight:200}@-webkit-keyframes layui-m-anim-scale{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes layui-m-anim-scale{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@-webkit-keyframes layui-m-anim-up{0%{opacity:0;-webkit-transform:translateY(800px);transform:translateY(800px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes layui-m-anim-up{0%{opacity:0;-webkit-transform:translateY(800px);transform:translateY(800px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes layui-m-anim-loading{0%,100%,80%{transform:scale(0);-webkit-transform:scale(0)}40%{transform:scale(1);-webkit-transform:scale(1)}}@keyframes layui-m-anim-loading{0%,100%,80%{transform:scale(0);-webkit-transform:scale(0)}40%{transform:scale(1);-webkit-transform:scale(1)}}.cyxy-function{position:fixed;bottom:140px;right:20px;z-index:109999;cursor:pointer}.cyxy-personal{position:fixed;bottom:190px;right:20px;z-index:109999;cursor:pointer}.cyxy-favorite{position:fixed;bottom:90px;right:20px;z-index:109999;cursor:pointer}.cyxy-favorite-btn{height:36px;width:36px;border-radius:50%;overflow:hidden}</style><style>.cyxy-video-trans{position:fixed;bottom:130px;right:20px;z-index:2147483647!important;cursor:pointer;filter:grayscale(100%);height:50px!important}.cyxy-video-trans-btn{height:36px!important;width:36px!important;border-radius:50%;overflow:hidden}</style>
 
 <div class=related role=navigation aria-label="related navigation">
 <h3 class="cyxy-trs-source cyxy-trs-source-ted sf-hidden">导航</h3><h3 class="cyxy-trs-source cyxy-trs-target sf-hidden">Navigation</h3>
 <ul>
 <li class=right style=margin-right:10px>
 <a href=https://docs.python.org/zh-cn/3.9/genindex.html title=总目录 accesskey=I class="cyxy-trs-source cyxy-trs-source-ted">索引<font class=cyxy-trs-target> Index</font></a></li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/py-modindex.html title="Python 模块索引" class="cyxy-trs-source cyxy-trs-source-ted">模块<font class=cyxy-trs-target> Module</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/unittest.mock-examples.html title="unittest.mock 上手指南" accesskey=N class="cyxy-trs-source cyxy-trs-source-ted">下一页<font class=cyxy-trs-target> Next page</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/unittest.html title="unittest --- 单元测试框架" accesskey=P class="cyxy-trs-source cyxy-trs-source-ted">上一页<font class=cyxy-trs-target> Previous</font></a> |</li>
 <li><img src='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><rect fill-opacity="0"/></svg>' alt style="vertical-align:middle;margin-top:-1px;background-blend-mode:normal!important;background-clip:content-box!important;background-position:50% 50%!important;background-color:rgba(0,0,0,0)!important;background-image:var(--sf-img-1)!important;background-size:100% 100%!important;background-origin:content-box!important;background-repeat:no-repeat!important"></li>
 <li><a href=https://www.python.org/ class="cyxy-trs-source cyxy-trs-source-ted">Python<font class=cyxy-trs-target> 巨蟒</font></a> »</li>
 
 <li>
 <span class=language_switcher_placeholder><select><option value=en>English<option value=fr>French<option value=ja>Japanese<option value=ko>Korean<option value=pt-br>Brazilian Portuguese<option value=zh-cn selected>Simplified Chinese</select></span>
 <span class=version_switcher_placeholder><select><option value=3.10>dev (3.10)<option value=3.9 selected>3.9.0b3<option value=3.8>3.8<option value=3.7>3.7<option value=3.6>3.6<option value=3.5>3.5<option value=2.7>2.7</select></span>
 <a href=https://docs.python.org/zh-cn/3.9/index.html class="cyxy-trs-source cyxy-trs-source-ted">文档<font class=cyxy-trs-target> Documents</font></a> »
 </li>
 <li class="nav-item nav-item-1"><a href=https://docs.python.org/zh-cn/3.9/library/index.html class="cyxy-trs-source cyxy-trs-source-ted">Python 标准库<font class=cyxy-trs-target> Python Standard Library</font></a> »</li>
 <li class="nav-item nav-item-2"><a href=https://docs.python.org/zh-cn/3.9/library/development.html accesskey=U class="cyxy-trs-source cyxy-trs-source-ted">开发工具<font class=cyxy-trs-target> Development tools</font></a> »</li>
 <li class=right>
 
 <div class=inline-search role=search>
 <form class=inline-search action=../search.html>
 <input placeholder=快速搜索 type=text name=q value>
 <input type=submit value=转向>
 
 
 </form>
 </div>
 
 |
 </li>
 </ul>
 </div> 
 <div class=document>
 <div class=documentwrapper>
 <div class=bodywrapper>
 <div class=body role=main>
 
 <div class=section id=module-unittest.mock>
<span id=unittest-mock-mock-object-library></span><h1 class=cyxy-trs-source><a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> --- mock对象库<font class=cyxy-trs-target> -- Mock Object Library</font><a class=headerlink href=#module-unittest.mock title=永久链接至标题>¶</a></h1>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.3 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">3.3 new features.</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><strong>源代码：</strong> <a class="reference external" href=https://github.com/python/cpython/tree/3.9/Lib/unittest/mock.py>Lib/unittest/mock.py</a><p class="cyxy-trs-source cyxy-trs-target">Source: mock.py</p>
<hr class=docutils>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> 是一个用于测试的Python库。它允许使用mock对象替换受测试系统的部分，并对它们如何已经被使用进行断言。<p class="cyxy-trs-source cyxy-trs-target">And it's going to be. A mock is a Python library for testing. It allows parts of the system under test to be replaced with mock objects and makes assertions about how they have been used.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> 提供了一个核心类 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 用于消除了在整个测试套件中创建大量存根(stub)的需求。创建后，就可以断言调用了哪些方法/属性及其参数。还可以以常规方式指定返回值并设置所需的属性。<p class="cyxy-trs-source cyxy-trs-target">And it's going to be. Mocks provide a core class that mocks the need to create a large number of Stub stubs throughout the test suite. Once created, you can assert which methods / properties and their parameters are invoked. You can also specify the return value and set the desired properties in the normal way.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">此外，mock 提供了用于修补测试范围内模块和类级别属性的 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 装饰器，和用于创建独特对象的 <a class="reference internal" href=#unittest.mock.sentinel title=unittest.mock.sentinel><code class="xref py py-const docutils literal notranslate"><span class=pre>sentinel</span></code></a> 。 阅读 <a class="reference internal" href=#quick-guide>quick guide</a> 中的案例了解如何使用 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> ，<a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 和 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 。<p class="cyxy-trs-source cyxy-trs-target">Additionally, mocks provide patch decorators for patching module-and class-level properties within the scope of the test, and sentinels for creating unique objects. Read the cases in the quick guide to understand how to use mocks, MagicMock, and patch.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock 是为 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.html#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 而设计，且简单易用。模拟基于 'action -&gt; assertion' 模式，而不是许多模拟框架所使用的 'record -&gt; replay'模式。<p class="cyxy-trs-source cyxy-trs-target">Mocks are designed for unittest and are simple to use. The simulation is based on the 'action-assertion' mode, rather than the 'record-replay' mode used by many simulation frameworks.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">在 Python 的早期版本要单独使用 <a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> ，在 <a class="reference external" href=https://pypi.org/project/mock>PyPI 获取 mock</a> 。<p class="cyxy-trs-source cyxy-trs-target">In earlier versions of Python, unit test. was used separately. Mock, get the mock in PYPI.</p>
<div class=section id=quick-guide>
<h2 class=cyxy-trs-source>快速上手<font class=cyxy-trs-target> Quick Start</font><a class=headerlink href=#quick-guide title=永久链接至标题>¶</a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">当您访问对象时， <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 和 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 将创建所有属性和方法，并保存他们在使用时的细节。你可以通过配置，指定返回值或者限制可访问属性，然后断言他们如何被调用：<p class="cyxy-trs-source cyxy-trs-target">When you access an object, Mock and MagicMock create all the properties and methods and save the details of their use. You can configure this by specifying the return value or limiting the accessible properties and then asserting how they are invoked:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>MagicMock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=o>.</span><span class=n>method</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'value'</span><span class=p>)</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'value'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">通过 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 设置副作用(side effects) ，可以是一个 mock 被调用是抛出的异常：<p class="cyxy-trs-source cyxy-trs-target">With side effects like side effects, you can have a mock that is called an exception that is thrown:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>KeyError</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>KeyError</span><span>: </span><span class=n>'foo'</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>values</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'a'</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=n>arg</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>values</span><span class=p>[</span><span class=n>arg</span><span class=p>]</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'a'</span><span class=p>),</span> <span class=n>mock</span><span class=p>(</span><span class=s1>'b'</span><span class=p>),</span> <span class=n>mock</span><span class=p>(</span><span class=s1>'c'</span><span class=p>)</span>
<span class=go>(1, 2, 3)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>()</span>
<span class=go>(5, 4, 3)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock 还可以通过其他方法配置和控制其行为。例如 mock 可以通过设置 <em>spec</em> 参数来从一个对象中获取其规格(specification)。如果访问 mock 的属性或方法不在 spec 中，会报 <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> 错误。<p class="cyxy-trs-source cyxy-trs-target">Mocks can also be configured and controlled in other ways. For example, a mock can obtain its specification specification from an object by setting a SPEC parameter. If access to the mock's properties or methods is not in the SPEC, an AttributeError is reported.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">使用 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 装饰去/上下文管理器，可以更方便地测试一个模块下的类或对象。你指定的对象会在测试过程中替换成 mock （或者其他对象），测试结束后恢复。<p class="cyxy-trs-source cyxy-trs-target">Using Patch decorations to / context manager makes it easier to test classes or objects under a module. The object you specify will be replaced as a mock (or other object) during the test and will be restored when the test is over.</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>patch</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'module.ClassName2'</span><span class=p>)</span>
<span class=gp>... </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'module.ClassName1'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>MockClass1</span><span class=p>,</span> <span class=n>MockClass2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>module</span><span class=o>.</span><span class=n>ClassName1</span><span class=p>()</span>
<span class=gp>... </span>    <span class=n>module</span><span class=o>.</span><span class=n>ClassName2</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass1</span> <span class=ow>is</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName1</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass2</span> <span class=ow>is</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName2</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass1</span><span class=o>.</span><span class=n>called</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass2</span><span class=o>.</span><span class=n>called</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">当你嵌套 patch 装饰器时，mock 将以执行顺序传递给装饰器函数（<em>Python</em> 装饰器正常顺序）。由于从下至上，因此在上面的示例中，首先 mock 传入的 <code class="docutils literal notranslate"><span class=pre>module.ClassName1</span></code> 。<p class="cyxy-trs-source cyxy-trs-target">When you nest a patch decorator, the mock is passed to the decorator function (in the normal order of the Python decorator) in the execution order. Since it's bottom-up, in the example above, the module.module.module.module.module.module.module.module. CLASSNAME1.</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">With <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> it matters that you patch objects in the namespace where they
are looked up. This is normally straightforward, but for a quick guide
read <a class="reference internal" href=#where-to-patch><span class="std std-ref">where to patch</span></a>.<p class="cyxy-trs-source cyxy-trs-target">使用 patch ()时，重要的是在查找对象的名称空间中对其进行补丁。 这通常是直截了当的，但作为一个快速指南，请阅读哪里需要修补。</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">As well as a decorator <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> can be used as a context manager in a with
statement:<p class="cyxy-trs-source cyxy-trs-target">还可以在 with 语句中使用 decorator 补丁()作为上下文管理器:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>ProductionClass</span><span class=p>,</span> <span class=s1>'method'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_method</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>thing</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>... </span>    <span class=n>thing</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_method</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">There is also <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> for setting values in a dictionary just
during a scope and restoring the dictionary to its original state when the test
ends:<p class="cyxy-trs-source cyxy-trs-target">还有 patch.dict () ，用于在范围内设置字典中的值，并在测试结束时将字典恢复到原始状态:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'key'</span><span class=p>:</span> <span class=s1>'value'</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>foo</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>},</span> <span class=n>clear</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=n>original</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock supports the mocking of Python <a class="reference internal" href=#magic-methods><span class="std std-ref">magic methods</span></a>. The
easiest way of using magic methods is with the <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> class. It
allows you to do things like:<p class="cyxy-trs-source cyxy-trs-target">Mock 支持嘲弄 Python 魔法方法。 使用魔法方法的最简单方法是使用 MagicMock 类。 它允许你这样做:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'foobarbaz'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'foobarbaz'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock allows you to assign functions (or other Mock instances) to magic methods
and they will be called appropriately. The <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> class is just a Mock
variant that has all of the magic methods pre-created for you (well, all the
useful ones anyway).<p class="cyxy-trs-source cyxy-trs-target">Mock 允许您将函数(或其他 Mock 实例)分配给魔术方法，并对它们进行适当的调用。 Magicmock 类只是 Mock 的一个变体，它拥有为您预先创建的所有魔法方法(当然，所有有用的方法都是如此)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The following is an example of using magic methods with the ordinary Mock
class:<p class="cyxy-trs-source cyxy-trs-target">下面是对普通 Mock 类使用魔法方法的一个例子:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=s1>'wheeeeee'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'wheeeeee'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">For ensuring that the mock objects in your tests have the same api as the
objects they are replacing, you can use <a class="reference internal" href=#auto-speccing><span class="std std-ref">auto-speccing</span></a>.
Auto-speccing can be done through the <em>autospec</em> argument to patch, or the
<a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> function. Auto-speccing creates mock objects that
have the same attributes and methods as the objects they are replacing, and
any functions and methods (including constructors) have the same call
signature as the real object.<p class="cyxy-trs-source cyxy-trs-target">为了确保测试中的模拟对象具有与它们所替换的对象相同的 api，可以使用自动投影。 自动分配可以通过 autospec 参数来实现，或者通过 create autospec ()函数来实现。 Auto-speccing 创建的模拟对象具有与它们所替换的对象相同的属性和方法，而且任何函数和方法(包括构造函数)具有与实际对象相同的调用签名。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">This ensures that your mocks will fail in the same way as your production
code if they are used incorrectly:<p class="cyxy-trs-source cyxy-trs-target">这确保了如果模拟使用不正确，它们将以与生产代码相同的方式失败:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>create_autospec</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>function</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span> <span class=o>=</span> <span class=n>create_autospec</span><span class=p>(</span><span class=n>function</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=s1>'fishy'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=go>'fishy'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span><span class=p>(</span><span class=s1>'wrong arguments'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>TypeError</span><span>: </span><span class=n>&lt;lambda&gt;() takes exactly 3 arguments (1 given)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> can also be used on classes, where it copies the signature of
the <code class="docutils literal notranslate"><span class=pre>__init__</span></code> method, and on callable objects where it copies the signature of
the <code class="docutils literal notranslate"><span class=pre>__call__</span></code> method.<p class="cyxy-trs-source cyxy-trs-target">Create autospec ()也可以用于类，其中它复制 init 方法的签名，以及可调用对象，其中它复制调用方法的签名。</p>
</div>
<div class=section id=the-mock-class>
<h2 class=cyxy-trs-source>The Mock Class<font class=cyxy-trs-target> 模拟课程</font><a class=headerlink href=#the-mock-class title=永久链接至标题>¶</a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> is a flexible mock object intended to replace the use of stubs and
test doubles throughout your code. Mocks are callable and create attributes as
new mocks when you access them <a class="footnote-reference brackets" href=#id3 id=id1>1</a>. Accessing the same attribute will always
return the same mock. Mocks record how you use them, allowing you to make
assertions about what your code has done to them.<p class="cyxy-trs-source cyxy-trs-target">Mock 是一个灵活的模拟对象，用于在整个代码中替换存根的使用并测试双精度测试。 Mocks 是可调用的，并且在访问它们时创建属性作为新的 Mocks 1。 访问相同的属性将始终返回相同的 mock。 Mock 记录您如何使用它们，允许您对代码对它们做了什么做出断言。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> is a subclass of <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> with all the magic methods
pre-created and ready to use. There are also non-callable variants, useful
when you are mocking out objects that aren't callable:
<a class="reference internal" href=#unittest.mock.NonCallableMock title=unittest.mock.NonCallableMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMock</span></code></a> and <a class="reference internal" href=#unittest.mock.NonCallableMagicMock title=unittest.mock.NonCallableMagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMagicMock</span></code></a><p class="cyxy-trs-source cyxy-trs-target">Magicmock 是 Mock 的一个子类，其中包含预先创建并可随时使用的所有魔法方法。 还有一些不可调用的变体，在您模拟不可调用的对象时非常有用: NonCallableMock 和 NonCallableMagicMock</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorators makes it easy to temporarily replace classes
in a particular module with a <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> object. By default <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> will create
a <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> for you. You can specify an alternative class of <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> using
the <em>new_callable</em> argument to <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Patch () decorator 可以使用 Mock 对象临时替换特定模块中的类。 默认情况下，patch ()将为您创建 MagicMock。 您可以使用新的可调用参数来指定 Mock 的替代类 patch ()。</p>
<dl class=class>
<dt id=unittest.mock.Mock>
<em class="property cyxy-trs-source">class <font class=cyxy-trs-target> 类</font></em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">Mock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">spec=None<font class=cyxy-trs-target> 没有</font></em>, <em class="sig-param cyxy-trs-source">side_effect=None<font class=cyxy-trs-target> 没有副作用</font></em>, <em class="sig-param cyxy-trs-source">return_value=DEFAULT<font class=cyxy-trs-target> 返回值 DEFAULT</font></em>, <em class="sig-param cyxy-trs-source">wraps=None<font class=cyxy-trs-target> 没有包装</font></em>, <em class="sig-param cyxy-trs-source">name=None<font class=cyxy-trs-target> 名称无</font></em>, <em class="sig-param cyxy-trs-source">spec_set=None<font class=cyxy-trs-target> 规格设置为 None</font></em>, <em class="sig-param cyxy-trs-source">unsafe=False<font class=cyxy-trs-target> 不安全的错误</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Create a new <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> object. <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> takes several optional arguments
that specify the behaviour of the Mock object:<p class="cyxy-trs-source cyxy-trs-target">创建一个新的 Mock 对象。 Mock 接受几个可选参数，这些参数指定 Mock 对象的行为:</p>
<ul>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>spec</em>: This can be either a list of strings or an existing object (a
class or instance) that acts as the specification for the mock object. If
you pass in an object then a list of strings is formed by calling dir on
the object (excluding unsupported magic attributes and methods).
Accessing any attribute not in this list will raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Spec: 这可以是字符串列表，也可以是充当模拟对象规范的现有对象(类或实例)。 如果传入对象，则通过调用对象上的 dir (排除不支持的魔术属性和方法)形成字符串列表。 访问列表以外的任何属性都会引发一个 AttributeError 错误。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>spec</em> is an object (rather than a list of strings) then
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/stdtypes.html#instance.__class__ title=instance.__class__><code class="xref py py-attr docutils literal notranslate"><span class=pre>__class__</span></code></a> returns the class of the spec object. This
allows mocks to pass <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> tests.<p class="cyxy-trs-source cyxy-trs-target">如果 spec 是一个对象(而不是字符串列表) ，那么类返回 spec 对象的类。 这允许模拟通过 isinstance ()测试。</p>
</li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>spec_set</em>: A stricter variant of <em>spec</em>. If used, attempting to <em>set</em>
or get an attribute on the mock that isn't on the object passed as
<em>spec_set</em> will raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Spec set: spec 的一个更严格的变体。 如果使用，试图在模拟上设置或获取一个不在作为 spec 设置传递的对象上的属性将引发 AttributeError。</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>side_effect</em>: A function to be called whenever the Mock is called. See
the <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> attribute. Useful for raising exceptions or
dynamically changing return values. The function is called with the same
arguments as the mock, and unless it returns <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a>, the return
value of this function is used as the return value.<p class="cyxy-trs-source cyxy-trs-target">Side effect: 调用 Mock 时要调用的函数。 请参见副作用属性。 用于引发异常或动态更改返回值。 使用与 mock 相同的参数调用该函数，除非它返回 DEFAULT，否则将使用该函数的返回值作为返回值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Alternatively <em>side_effect</em> can be an exception class or instance. In
this case the exception will be raised when the mock is called.<p class="cyxy-trs-source cyxy-trs-target">或者，副作用可以是异常类或实例。 在这种情况下，在调用 mock 时将引发异常。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>side_effect</em> is an iterable then each call to the mock will return
the next value from the iterable.<p class="cyxy-trs-source cyxy-trs-target">如果副作用是可迭代的，那么对模拟的每个调用都将返回迭代中的下一个值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">A <em>side_effect</em> can be cleared by setting it to <code class="docutils literal notranslate"><span class=pre>None</span></code>.<p class="cyxy-trs-source cyxy-trs-target">副作用可以通过将其设置为 None 来清除。</p>
</li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>return_value</em>: The value returned when the mock is called. By default
this is a new Mock (created on first access). See the
<a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> attribute.<p class="cyxy-trs-source cyxy-trs-target">Return value: 调用 mock 时返回的值。 默认情况下，这是一个新的 Mock (在第一次访问时创建)。 请参见 return value 属性。</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>unsafe</em>: By default if any attribute starts with <em>assert</em> or
<em>assret</em> will raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>. Passing <code class="docutils literal notranslate"><span class=pre>unsafe=True</span></code>
will allow access to these attributes.<p class="cyxy-trs-source cyxy-trs-target">Unsafe: 默认情况下，如果任何属性以 assert 开头，或者 assret 将引发 AttributeError。 传递 unsafe True 将允许访问这些属性。</p>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.5 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">New version 3.5 features.</p>
</div>
</li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>wraps</em>: Item for the mock object to wrap. If <em>wraps</em> is not <code class="docutils literal notranslate"><span class=pre>None</span></code> then
calling the Mock will pass the call through to the wrapped object
(returning the real result). Attribute access on the mock will return a
Mock object that wraps the corresponding attribute of the wrapped
object (so attempting to access an attribute that doesn't exist will
raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>).<p class="cyxy-trs-source cyxy-trs-target">Wraps: 用于包装模拟对象的项。 如果换行不是 None，那么调用 Mock 将把调用传递给换行后的对象(返回真正的结果)。 对 Mock 的属性访问将返回一个 Mock 对象，该对象包装了被包装对象的相应属性(因此试图访问不存在的属性将引发 AttributeError)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If the mock has an explicit <em>return_value</em> set then calls are not passed
to the wrapped object and the <em>return_value</em> is returned instead.<p class="cyxy-trs-source cyxy-trs-target">如果模拟具有一个显式的返回值集，则不会将调用传递给被包装的对象，而是返回返回值。</p>
</li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><em>name</em>: If the mock has a name then it will be used in the repr of the
mock. This can be useful for debugging. The name is propagated to child
mocks.<p class="cyxy-trs-source cyxy-trs-target">Name: 如果 mock 有一个名称，那么它将在 mock 的 repr 中使用。 这对调试非常有用。 将名称传播到子模拟。</p></li>
</ul>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mocks can also be called with arbitrary keyword arguments. These will be
used to set attributes on the mock after it is created. See the
<a class="reference internal" href=#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a> method for details.<p class="cyxy-trs-source cyxy-trs-target">也可以使用任意的关键字参数调用 mock。 这些属性将用于在模拟创建后在模拟上设置属性。 有关详细信息，请参阅 configure mock ()方法。</p>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called>
<code class="sig-name descname">assert_called</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was called at least once.<p class="cyxy-trs-source cyxy-trs-target">断言至少调用过 mock 一次。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called</span><span class=p>()</span>
</pre></div>
</div>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.6 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">New version 3.6 features.</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called_once>
<code class="sig-name descname">assert_called_once</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called_once title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was called exactly once.<p class="cyxy-trs-source cyxy-trs-target">断言 mock 只被调用了一次。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_once</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_once</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'method' to have been called once. Called 2 times.</span>
</pre></div>
</div>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.6 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">New version 3.6 features.</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called_with>
<code class="sig-name descname">assert_called_with</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called_with title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This method is a convenient way of asserting that the last call has been
made in a particular way:<p class="cyxy-trs-source cyxy-trs-target">这种方法可以方便地断定最后一次调用是以某种特定方式进行的:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=o>=</span><span class=s1>'wow'</span><span class=p>)</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=o>=</span><span class=s1>'wow'</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called_once_with>
<code class="sig-name descname">assert_called_once_with</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called_once_with title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was called exactly once and that that call was
with the specified arguments.<p class="cyxy-trs-source cyxy-trs-target">断言 mock 仅被调用一次，并且该调用具有指定的参数。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'baz'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'baz'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'other'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'values'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'other'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'values'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'mock' to be called once. Called 2 times.</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_any_call>
<code class="sig-name descname">assert_any_call</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_any_call title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">assert the mock has been called with the specified arguments.<p class="cyxy-trs-source cyxy-trs-target">Assert 已使用指定的参数调用 mock。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The assert passes if the mock has <em>ever</em> been called, unlike
<a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> that
only pass if the call is the most recent one, and in the case of
<a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> it must also be the only call.<p class="cyxy-trs-source cyxy-trs-target">如果 mock 曾被调用过，那么 assert 就会传递，不像 assert 调用 with ()和 assert 调用 once with () ，assert 调用 once with ()只有在调用是最近的调用时才传递，而 assert 调用 once with ()时，它也必须是唯一的调用。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'thing'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'some'</span><span class=p>,</span> <span class=s1>'thing'</span><span class=p>,</span> <span class=s1>'else'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_any_call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'thing'</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_has_calls>
<code class="sig-name descname">assert_has_calls</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">calls<font class=cyxy-trs-target> 呼叫</font></em>, <em class="sig-param cyxy-trs-source">any_order=False<font class=cyxy-trs-target> 任何命令错误</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_has_calls title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">assert the mock has been called with the specified calls.
The <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> list is checked for the calls.<p class="cyxy-trs-source cyxy-trs-target">断言已用指定的调用调用了 mock。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>any_order</em> is false then the calls must be
sequential. There can be extra calls before or after the
specified calls.<p class="cyxy-trs-source cyxy-trs-target">如果任何命令为 false，那么调用必须是顺序的。 在指定的调用之前或之后可以有额外的调用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>any_order</em> is true then the calls can be in any order, but
they must all appear in <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">如果任何顺序为真，则调用可以按任意顺序进行，但它们都必须出现在模拟调用中。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_calls</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>4</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_calls</span><span class=p>(</span><span class=n>calls</span><span class=p>,</span> <span class=n>any_order</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_not_called>
<code class="sig-name descname">assert_not_called</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_not_called title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert the mock was never called.<p class="cyxy-trs-source cyxy-trs-target">声明从未调用 mock。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>hello</span><span class=o>.</span><span class=n>assert_not_called</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>obj</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>hello</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>hello</span><span class=o>.</span><span class=n>assert_not_called</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'hello' to not have been called. Called 1 times.</span>
</pre></div>
</div>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.5 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">New version 3.5 features.</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.reset_mock>
<code class="sig-name descname">reset_mock</code><span class=sig-paren>(</span><em class=sig-param>*</em>, <em class="sig-param cyxy-trs-source">return_value=False<font class=cyxy-trs-target> 返回值 False</font></em>, <em class="sig-param cyxy-trs-source">side_effect=False<font class=cyxy-trs-target> 副作用错误</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.reset_mock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">The reset_mock method resets all the call attributes on a mock object:<p class="cyxy-trs-source cyxy-trs-target">Reset mock 方法重置模拟对象上的所有调用属性:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'hello'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>reset_mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>False</span>
</pre></div>
</div>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.6 版更改: </span>Added two keyword only argument to the reset_mock function.<p class="cyxy-trs-source cyxy-trs-target">Something 3.6 something something: 在重置模拟函数中添加了两个只有关键字的参数。</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">This can be useful where you want to make a series of assertions that
reuse the same object. Note that <a class="reference internal" href=#unittest.mock.Mock.reset_mock title=unittest.mock.Mock.reset_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>reset_mock()</span></code></a> <em>doesn't</em> clear the
return value, <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> or any child attributes you have
set using normal assignment by default. In case you want to reset
<em>return_value</em> or <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a>, then pass the corresponding
parameter as <code class="docutils literal notranslate"><span class=pre>True</span></code>. Child mocks and the return value mock
(if any) are reset as well.<p class="cyxy-trs-source cyxy-trs-target">当您希望做出一系列重用相同对象的断言时，这可能非常有用。 请注意，默认情况下，reset mock ()不会清除使用正常赋值设置的返回值、副作用或任何子属性。 如果希望重置返回值或副作用，则将相应的参数作为 True 传递。 子模拟和返回值 mock (如果有的话)也被重置。</p>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>return_value</em>, and <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> are keyword only
argument.<p class="cyxy-trs-source cyxy-trs-target">返回值，而副作用只是关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.mock_add_spec>
<code class="sig-name descname">mock_add_spec</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">spec<font class=cyxy-trs-target> 规格</font></em>, <em class="sig-param cyxy-trs-source">spec_set=False<font class=cyxy-trs-target> 规格设置为 False</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.mock_add_spec title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Add a spec to a mock. <em>spec</em> can either be an object or a
list of strings. Only attributes on the <em>spec</em> can be fetched as
attributes from the mock.<p class="cyxy-trs-source cyxy-trs-target">给模拟添加一个规范。 Spec 可以是对象，也可以是字符串列表。 只有规范上的属性可以从模拟中作为属性提取。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>spec_set</em> is true then only attributes on the spec can be set.<p class="cyxy-trs-source cyxy-trs-target">如果 spec set 为 true，那么只能设置 spec 上的属性。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.attach_mock>
<code class="sig-name descname">attach_mock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">mock<font class=cyxy-trs-target> 嘲笑</font></em>, <em class="sig-param cyxy-trs-source">attribute<font class=cyxy-trs-target> 属性</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.attach_mock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Attach a mock as an attribute of this one, replacing its name and
parent. Calls to the attached mock will be recorded in the
<a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> attributes of this one.<p class="cyxy-trs-source cyxy-trs-target">附加一个 mock 作为这个 mock 的属性，替换它的名称和父属性。 对所附 mock 的调用将记录在此方法调用和 mock 调用属性中。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.configure_mock>
<code class="sig-name descname">configure_mock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.configure_mock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Set attributes on the mock through keyword arguments.<p class="cyxy-trs-source cyxy-trs-target">通过关键字参数在 mock 上设置属性。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Attributes plus return values and side effects can be set on child
mocks using standard dot notation and unpacking a dictionary in the
method call:<p class="cyxy-trs-source cyxy-trs-target">属性加上返回值和副作用可以使用标准点表示法在子模拟上设置，并在方法调用中解压字典:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>attrs</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>configure_mock</span><span class=p>(</span><span class=o>**</span><span class=n>attrs</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The same thing can be achieved in the constructor call to mocks:<p class="cyxy-trs-source cyxy-trs-target">在构造函数调用 mock 中也可以实现同样的功能:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>attrs</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>some_attribute</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>,</span> <span class=o>**</span><span class=n>attrs</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>some_attribute</span>
<span class=go>'eggs'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a> exists to make it easier to do configuration
after the mock has been created.<p class="cyxy-trs-source cyxy-trs-target">Configure mock ()的存在使得在创建 mock 之后进行配置更加容易。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.__dir__>
<code class="sig-name descname">__dir__</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.__dir__ title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> objects limit the results of <code class="docutils literal notranslate"><span class=pre>dir(some_mock)</span></code> to useful results.
For mocks with a <em>spec</em> this includes all the permitted attributes
for the mock.<p class="cyxy-trs-source cyxy-trs-target">模拟对象将 dir (某些模拟)的结果限制为有用的结果。 对于带有规范的模拟，该模拟包括所有允许的模拟属性。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">See <a class="reference internal" href=#unittest.mock.FILTER_DIR title=unittest.mock.FILTER_DIR><code class="xref py py-data docutils literal notranslate"><span class=pre>FILTER_DIR</span></code></a> for what this filtering does, and how to
switch it off.<p class="cyxy-trs-source cyxy-trs-target">请参阅 FILTER dir 了解这个过滤器的作用，以及如何关闭它。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock._get_child_mock>
<code class="sig-name descname">_get_child_mock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">**kw<font class=cyxy-trs-target> 我知道</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock._get_child_mock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Create the child mocks for attributes and return value.
By default child mocks will be the same type as the parent.
Subclasses of Mock may want to override this to customize the way
child mocks are made.<p class="cyxy-trs-source cyxy-trs-target">为属性和返回值创建子模拟。 默认情况下，子模拟与父模拟的类型相同。 Mock 的子类可能希望重写这个命令，以自定义子模拟的制作方式。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">For non-callable mocks the callable variant will be used (rather than
any custom subclass).<p class="cyxy-trs-source cyxy-trs-target">对于非可调用的 mock，将使用可调用的变量(而不是任何自定义子类)。</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.called>
<code class="sig-name descname">called</code><a class=headerlink href=#unittest.mock.Mock.called title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">A boolean representing whether or not the mock object has been called:<p class="cyxy-trs-source cyxy-trs-target">一个布尔值，表示是否调用了模拟对象:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>True</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.call_count>
<code class="sig-name descname">call_count</code><a class=headerlink href=#unittest.mock.Mock.call_count title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">An integer telling you how many times the mock object has been called:<p class="cyxy-trs-source cyxy-trs-target">一个整数，它告诉你模拟对象被调用了多少次:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_count</span>
<span class=go>0</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_count</span>
<span class=go>2</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.return_value>
<code class="sig-name descname">return_value</code><a class=headerlink href=#unittest.mock.Mock.return_value title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Set this to configure the value returned by calling the mock:<p class="cyxy-trs-source cyxy-trs-target">通过调用 mock 来配置返回的值:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>'fish'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The default return value is a mock object and you can configure it in
the normal way:<p class="cyxy-trs-source cyxy-trs-target">默认返回值是一个模拟对象，你可以用正常的方式配置它:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>attribute</span> <span class=o>=</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>Attribute</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock()()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> can also be set in the constructor:<p class="cyxy-trs-source cyxy-trs-target">返回值也可以在构造函数中设置:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.side_effect>
<code class="sig-name descname">side_effect</code><a class=headerlink href=#unittest.mock.Mock.side_effect title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This can either be a function to be called when the mock is called,
an iterable or an exception (class or instance) to be raised.<p class="cyxy-trs-source cyxy-trs-target">这既可以是调用 mock 时要调用的函数，也可以是要引发的迭代或异常(类或实例)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you pass in a function it will be called with same arguments as the
mock and unless the function returns the <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> singleton the
call to the mock will then return whatever the function returns. If the
function returns <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> then the mock will return its normal
value (from the <a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a>).<p class="cyxy-trs-source cyxy-trs-target">如果您传入一个函数，它将被调用与 mock 相同的参数，并且除非函数返回 DEFAULT 单例，否则对 mock 的调用将返回函数返回的任何内容。 如果函数返回 DEFAULT，那么模拟将返回其正常值(来自返回值)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you pass in an iterable, it is used to retrieve an iterator which
must yield a value on every call. This value can either be an exception
instance to be raised, or a value to be returned from the call to the
mock (<a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> handling is identical to the function case).<p class="cyxy-trs-source cyxy-trs-target">如果传入一个迭代器，它用于检索一个迭代器，该迭代器必须在每次调用中产生一个值。 此值既可以是要引发的异常实例，也可以是从调用 mock 时返回的值(DEFAULT 处理与函数大小写相同)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">An example of a mock that raises an exception (to test exception
handling of an API):<p class="cyxy-trs-source cyxy-trs-target">一个引发异常的模拟示例(用于测试 API 的异常处理) :</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=ne>Exception</span><span class=p>(</span><span class=s1>'Boom!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>Exception</span><span>: </span><span class=n>Boom!</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> to return a sequence of values:<p class="cyxy-trs-source cyxy-trs-target">使用副作用返回一系列值:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>()</span>
<span class=go>(3, 2, 1)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using a callable:<p class="cyxy-trs-source cyxy-trs-target">使用可调用的:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>DEFAULT</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> can be set in the constructor. Here's an example that
adds one to the value the mock is called with and returns it:<p class="cyxy-trs-source cyxy-trs-target">可以在构造函数中设置副作用。 下面是一个示例，它将一个值添加到 mock 调用的值中，并返回它:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>side_effect</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>value</span><span class=p>:</span> <span class=n>value</span> <span class=o>+</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>side_effect</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=go>4</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=o>-</span><span class=mi>8</span><span class=p>)</span>
<span class=go>-7</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Setting <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> to <code class="docutils literal notranslate"><span class=pre>None</span></code> clears it:<p class="cyxy-trs-source cyxy-trs-target">将副作用设置为 None 可以清除它:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>KeyError</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>KeyError</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.call_args>
<code class="sig-name descname">call_args</code><a class=headerlink href=#unittest.mock.Mock.call_args title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This is either <code class="docutils literal notranslate"><span class=pre>None</span></code> (if the mock hasn't been called), or the
arguments that the mock was last called with. This will be in the
form of a tuple: the first member, which can also be accessed through
the <code class="docutils literal notranslate"><span class=pre>args</span></code> property, is any ordered arguments the mock was
called with (or an empty tuple) and the second member, which can
also be accessed through the <code class="docutils literal notranslate"><span class=pre>kwargs</span></code> property, is any keyword
arguments (or an empty dictionary).<p class="cyxy-trs-source cyxy-trs-target">这可能是 None (如果没有调用 mock) ，也可能是上次调用 mock 时使用的参数。 这将是一个 tuple 的形式: 第一个成员(也可以通过 args 属性访问)是 mock 调用的任何有序参数(或空 tuple) ，第二个成员(也可以通过 kwargs 属性访问)是 any keyword arguments (或空 dictionary)。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=p>)</span>
<span class=go>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span> <span class=o>==</span> <span class=p>()</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call(3, 4)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span> <span class=o>==</span> <span class=p>((</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>),)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>args</span>
<span class=go>(3, 4)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>kwargs</span>
<span class=go>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'fish'</span><span class=p>,</span> <span class=nb>next</span><span class=o>=</span><span class=s1>'w00t!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call(3, 4, 5, key='fish', next='w00t!')</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>args</span>
<span class=go>(3, 4, 5)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>kwargs</span>
<span class=go>{'key': 'fish', 'next': 'w00t!'}</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a>, along with members of the lists <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a>,
<a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> are <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> objects.
These are tuples, so they can be unpacked to get at the individual
arguments and make more complex assertions. See
<a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a>.<p class="cyxy-trs-source cyxy-trs-target">调用 args，连同 list 的成员调用 args list，方法调用和模拟调用是 call 对象。 这些是元组，因此可以对它们进行解压缩，以获得单个参数并生成更复杂的断言。 将调用视为元组。</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.call_args_list>
<code class="sig-name descname">call_args_list</code><a class=headerlink href=#unittest.mock.Mock.call_args_list title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This is a list of all the calls made to the mock object in sequence
(so the length of the list is the number of times it has been
called). Before any calls have been made it is an empty list. The
<a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> object can be used for conveniently constructing lists of
calls to compare with <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">这是按顺序对模拟对象进行的所有调用的列表(因此列表的长度是它被调用的次数)。 在调用之前，它是一个空列表。 调用对象可用于方便地构造调用列表，以与调用 args 列表进行比较。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=s1>'fish'</span><span class=p>,</span> <span class=nb>next</span><span class=o>=</span><span class=s1>'w00t!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args_list</span>
<span class=go>[call(), call(3, 4), call(key='fish', next='w00t!')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=p>[(),</span> <span class=p>((</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>),),</span> <span class=p>({</span><span class=s1>'key'</span><span class=p>:</span> <span class=s1>'fish'</span><span class=p>,</span> <span class=s1>'next'</span><span class=p>:</span> <span class=s1>'w00t!'</span><span class=p>},)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args_list</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Members of <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a> are <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> objects. These can be
unpacked as tuples to get at the individual arguments. See
<a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a>.<p class="cyxy-trs-source cyxy-trs-target">调用 args 列表的成员是调用对象。 这些参数可以作为元组解压缩，以获得单个参数。 将调用视为元组。</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.method_calls>
<code class="sig-name descname">method_calls</code><a class=headerlink href=#unittest.mock.Mock.method_calls title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">As well as tracking calls to themselves, mocks also track calls to
methods and attributes, and <em>their</em> methods and attributes:<p class="cyxy-trs-source cyxy-trs-target">除了跟踪自身的调用之外，mock 还跟踪方法和属性的调用，以及它们的方法和属性:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>property</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>attribute</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.property.method.attribute()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method_calls</span>
<span class=go>[call.method(), call.property.method.attribute()]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Members of <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> are <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> objects. These can be
unpacked as tuples to get at the individual arguments. See
<a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a>.<p class="cyxy-trs-source cyxy-trs-target">方法调用的成员是调用对象。 这些参数可以作为元组解压缩，以获得单个参数。 将调用视为元组。</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.mock_calls>
<code class="sig-name descname">mock_calls</code><a class=headerlink href=#unittest.mock.Mock.mock_calls title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> records <em>all</em> calls to the mock object, its methods,
magic methods <em>and</em> return value mocks.<p class="cyxy-trs-source cyxy-trs-target">Mock 调用记录对 mock 对象、它的方法、 magic 方法的所有调用，并返回值 mock。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span> <span class=o>=</span> <span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>first</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock.first()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>second</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.second()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>int</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock()()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>call</span><span class=o>.</span><span class=n>first</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>),</span> <span class=n>call</span><span class=o>.</span><span class=n>second</span><span class=p>(),</span>
<span class=gp>... </span><span class=n>call</span><span class=o>.</span><span class=fm>__int__</span><span class=p>(),</span> <span class=n>call</span><span class=p>()(</span><span class=mi>1</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Members of <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> are <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> objects. These can be
unpacked as tuples to get at the individual arguments. See
<a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a>.<p class="cyxy-trs-source cyxy-trs-target">模拟调用的成员是调用对象。 这些参数可以作为元组解压缩，以获得单个参数。 将调用视为元组。</p>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The way <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> are recorded means that where nested
calls are made, the parameters of ancestor calls are not recorded
and so will always compare equal:<p class="cyxy-trs-source cyxy-trs-target">记录 mock 调用的方式意味着在进行嵌套调用的地方，祖先调用的参数不被记录，因此将始终比较相等:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>top</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span><span class=o>.</span><span class=n>bottom</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.top().bottom()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.top(a=3), call.top().bottom()]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>call</span><span class=o>.</span><span class=n>top</span><span class=p>(</span><span class=n>a</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>bottom</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.__class__>
<code class="sig-name descname">__class__</code><a class=headerlink href=#unittest.mock.Mock.__class__ title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Normally the <a class="reference internal" href=#unittest.mock.Mock.__class__ title=unittest.mock.Mock.__class__><code class="xref py py-attr docutils literal notranslate"><span class=pre>__class__</span></code></a> attribute of an object will return its type.
For a mock object with a <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code>, <code class="docutils literal notranslate"><span class=pre>__class__</span></code> returns the spec class
instead. This allows mock objects to pass <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> tests for the
object they are replacing / masquerading as:<p class="cyxy-trs-source cyxy-trs-target">通常，对象的 class 属性将返回其类型。 对于带 spec 的模拟对象，类将返回 spec 类。 这允许 mock 对象通过 isinstance ()测试来替换 / 伪装为:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=nb>int</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock.__class__ title=unittest.mock.Mock.__class__><code class="xref py py-attr docutils literal notranslate"><span class=pre>__class__</span></code></a> is assignable to, this allows a mock to pass an
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> check without forcing you to use a spec:<p class="cyxy-trs-source cyxy-trs-target">类是可分配的，这允许 mock 通过 isinstance ()检查，而不必使用 spec:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=vm>__class__</span> <span class=o>=</span> <span class=nb>dict</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=nb>dict</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
</dl>
</dl>
<dl class=class>
<dt id=unittest.mock.NonCallableMock>
<em class="property cyxy-trs-source">class <font class=cyxy-trs-target> 类</font></em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">NonCallableMock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">spec=None<font class=cyxy-trs-target> 没有</font></em>, <em class="sig-param cyxy-trs-source">wraps=None<font class=cyxy-trs-target> 没有包装</font></em>, <em class="sig-param cyxy-trs-source">name=None<font class=cyxy-trs-target> 名称无</font></em>, <em class="sig-param cyxy-trs-source">spec_set=None<font class=cyxy-trs-target> 规格设置为 None</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.NonCallableMock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">A non-callable version of <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>. The constructor parameters have the same
meaning of <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>, with the exception of <em>return_value</em> and <em>side_effect</em>
which have no meaning on a non-callable mock.<p class="cyxy-trs-source cyxy-trs-target">Mock 的不可调用版本。 构造函数参数的含义与 Mock 相同，只是返回值和副作用在不可调用的 Mock 上没有含义。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock objects that use a class or an instance as a <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> or
<code class="xref py py-attr docutils literal notranslate"><span class=pre>spec_set</span></code> are able to pass <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> tests:<p class="cyxy-trs-source cyxy-trs-target">使用类或实例作为 spec 或 spec 集的 Mock 对象能够通过 isinstance ()测试:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>SomeClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=n>SomeClass</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec_set</span><span class=o>=</span><span class=n>SomeClass</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=n>SomeClass</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> classes have support for mocking magic methods. See <a class="reference internal" href=#magic-methods><span class="std std-ref">magic
methods</span></a> for the full details.<p class="cyxy-trs-source cyxy-trs-target">模拟类支持模拟魔术方法。详细信息请参阅魔术方法。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The mock classes and the <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorators all take arbitrary keyword
arguments for configuration. For the <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorators the keywords are
passed to the constructor of the mock being created. The keyword arguments
are for configuring attributes of the mock:<p class="cyxy-trs-source cyxy-trs-target">模拟类和 patch () decorator 都为配置接受任意的关键字参数。 对于 patch () decorator，关键字被传递给要创建的 mock 的构造函数。 关键字参数用于配置 mock 的属性:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>attribute</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=s1>'fish'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>attribute</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>other</span>
<span class=go>'fish'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The return value and side effect of child mocks can be set in the same way,
using dotted notation. As you can't use dotted names directly in a call you
have to create a dictionary and unpack it using <code class="docutils literal notranslate"><span class=pre>**</span></code>:<p class="cyxy-trs-source cyxy-trs-target">子模拟的返回值和副作用可以用同样的方式设置，即使用点符号。 因为你不能直接在调用中使用虚线名称，所以你必须创建一个字典并用 * * 解压缩它:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>attrs</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>some_attribute</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>,</span> <span class=o>**</span><span class=n>attrs</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>some_attribute</span>
<span class=go>'eggs'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A callable mock which was created with a <em>spec</em> (or a <em>spec_set</em>) will
introspect the specification object's signature when matching calls to
the mock. Therefore, it can match the actual call's arguments regardless
of whether they were passed positionally or by name:<p class="cyxy-trs-source cyxy-trs-target">使用 spec (或 spec 集)创建的可调用 mock 将在匹配对 mock 的调用时自省规范对象的签名。 因此，它可以匹配实际调用的参数，而不管它们是按位置还是按名称传递的:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span> <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>f</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>c</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=go>&lt;Mock name='mock()' id='140161580456576'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>c</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">This applies to <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a>,
<a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a>, <a class="reference internal" href=#unittest.mock.Mock.assert_has_calls title=unittest.mock.Mock.assert_has_calls><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_has_calls()</span></code></a> and
<a class="reference internal" href=#unittest.mock.Mock.assert_any_call title=unittest.mock.Mock.assert_any_call><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_any_call()</span></code></a>. When <a class="reference internal" href=#auto-speccing><span class="std std-ref">Autospeccing</span></a>, it will also
apply to method calls on the mock object.<p class="cyxy-trs-source cyxy-trs-target">这适用于 assert 调用 with () ，assert 调用一次 assert 调用() ，assert 拥有 calls ()和 assert 任何 call ()。 当 Autospeccing 时，它也将应用于模拟对象上的方法调用。</p>
<blockquote>
<div><div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.4 版更改: </span>Added signature introspection on specced and autospecced mock objects.<p class="cyxy-trs-source cyxy-trs-target">Something 3.4 something something something: 增加签名反省对特殊和自动特殊的模拟对象。</p>
</div>
</div></blockquote>
<dl class=class>
<dt id=unittest.mock.PropertyMock>
<em class="property cyxy-trs-source">class <font class=cyxy-trs-target> 类</font></em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">PropertyMock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.PropertyMock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">A mock intended to be used as a property, or other descriptor, on a class.
<a class="reference internal" href=#unittest.mock.PropertyMock title=unittest.mock.PropertyMock><code class="xref py py-class docutils literal notranslate"><span class=pre>PropertyMock</span></code></a> provides <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__get__ title=object.__get__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__get__()</span></code></a> and <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__set__ title=object.__set__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__set__()</span></code></a> methods
so you can specify a return value when it is fetched.<p class="cyxy-trs-source cyxy-trs-target">用作类上的属性或其他描述符的模拟。 Propertymock 提供了 get ()和 set ()方法，因此可以在获取时指定返回值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Fetching a <a class="reference internal" href=#unittest.mock.PropertyMock title=unittest.mock.PropertyMock><code class="xref py py-class docutils literal notranslate"><span class=pre>PropertyMock</span></code></a> instance from an object calls the mock, with
no args. Setting it calls the mock with the value being set.<p class="cyxy-trs-source cyxy-trs-target">从对象中提取 PropertyMock 实例调用 mock，不使用 args。 设置它将调用设置值的 mock。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=nd>@property</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=s1>'something'</span>
<span class=gp>... </span>    <span class=nd>@foo</span><span class=o>.</span><span class=n>setter</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Foo.foo'</span><span class=p>,</span> <span class=n>new_callable</span><span class=o>=</span><span class=n>PropertyMock</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>mock_foo</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'mockity-mock'</span>
<span class=gp>... </span>    <span class=n>this_foo</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>()</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=n>this_foo</span><span class=o>.</span><span class=n>foo</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>this_foo</span><span class=o>.</span><span class=n>foo</span> <span class=o>=</span> <span class=mi>6</span>
<span class=gp>...</span>
<span class=go>mockity-mock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(), call(6)]</span>
</pre></div>
</div>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">Because of the way mock attributes are stored you can't directly attach a
<a class="reference internal" href=#unittest.mock.PropertyMock title=unittest.mock.PropertyMock><code class="xref py py-class docutils literal notranslate"><span class=pre>PropertyMock</span></code></a> to a mock object. Instead you can attach it to the mock type
object:<p class="cyxy-trs-source cyxy-trs-target">由于存储模拟属性的方式，您不能直接将 PropertyMock 附加到模拟对象。 相反，你可以将它附加到模拟类型对象:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>p</span> <span class=o>=</span> <span class=n>PropertyMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=n>m</span><span class=p>)</span><span class=o>.</span><span class=n>foo</span> <span class=o>=</span> <span class=n>p</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>foo</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>p</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>()</span>
</pre></div>
</div>
<dl class=class>
<dt id=unittest.mock.AsyncMock>
<em class="property cyxy-trs-source">class <font class=cyxy-trs-target> 类</font></em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">AsyncMock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">spec=None<font class=cyxy-trs-target> 没有</font></em>, <em class="sig-param cyxy-trs-source">side_effect=None<font class=cyxy-trs-target> 没有副作用</font></em>, <em class="sig-param cyxy-trs-source">return_value=DEFAULT<font class=cyxy-trs-target> 返回值 DEFAULT</font></em>, <em class="sig-param cyxy-trs-source">wraps=None<font class=cyxy-trs-target> 没有包装</font></em>, <em class="sig-param cyxy-trs-source">name=None<font class=cyxy-trs-target> 名称无</font></em>, <em class="sig-param cyxy-trs-source">spec_set=None<font class=cyxy-trs-target> 规格设置为 None</font></em>, <em class="sig-param cyxy-trs-source">unsafe=False<font class=cyxy-trs-target> 不安全的错误</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">An asynchronous version of <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>. The <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> object will
behave so the object is recognized as an async function, and the result of a
call is an awaitable.<p class="cyxy-trs-source cyxy-trs-target">Magicmock 的异步版本。 Asyncmock 对象将进行操作，以便将该对象识别为异步函数，并且调用的结果是可以调用的。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>iscoroutinefunction</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>inspect</span><span class=o>.</span><span class=n>isawaitable</span><span class=p>(</span><span class=n>mock</span><span class=p>())</span>  
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The result of <code class="docutils literal notranslate"><span class=pre>mock()</span></code> is an async function which will have the outcome
of <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> or <code class="docutils literal notranslate"><span class=pre>return_value</span></code> after it has been awaited:<p class="cyxy-trs-source cyxy-trs-target">Mock ()的结果是一个异步函数，它在等待之后会产生副作用或返回值:</p>
<ul class=simple>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">if <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> is a function, the async function will return the
result of that function,<p class="cyxy-trs-source cyxy-trs-target">如果副作用是一个函数，async 函数将返回该函数的结果,</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">if <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> is an exception, the async function will raise the
exception,<p class="cyxy-trs-source cyxy-trs-target">如果副作用是异常，async 函数将引发异常,</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">if <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> is an iterable, the async function will return the
next value of the iterable, however, if the sequence of result is
exhausted, <code class="docutils literal notranslate"><span class=pre>StopAsyncIteration</span></code> is raised immediately,<p class="cyxy-trs-source cyxy-trs-target">如果副作用是可迭代的，async 函数将返回可迭代的下一个值，但是，如果结果序列已经用尽，StopAsyncIteration 将立即引发,</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">if <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> is not defined, the async function will return the
value defined by <code class="docutils literal notranslate"><span class=pre>return_value</span></code>, hence, by default, the async function
returns a new <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> object.<p class="cyxy-trs-source cyxy-trs-target">如果没有定义副作用，async 函数将返回由返回值定义的值，因此，在默认情况下，async 函数将返回一个新的 AsyncMock 对象。</p></li>
</ul>
<p class="cyxy-trs-source cyxy-trs-source-ted">Setting the <em>spec</em> of a <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> or <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> to an async function
will result in a coroutine object being returned after calling.<p class="cyxy-trs-source cyxy-trs-target">将 Mock 或 MagicMock 的规范设置为异步函数将导致在调用后返回 coroutine 对象。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>async_func</span><span class=p>():</span> <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>async_func</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span>
<span class=go>&lt;MagicMock spec='function' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>  
<span class=go>&lt;coroutine object AsyncMockMixin._mock_call at ...&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Setting the <em>spec</em> of a <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>, <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>, or <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a>
to a class with asynchronous and synchronous functions will automatically
detect the synchronous functions and set them as <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> (if the
parent mock is <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> or <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>) or <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> (if
the parent mock is <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>). All asynchronous functions will be
<a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">将 Mock、 MagicMock 或 AsyncMock 的规范设置为具有异步和同步函数的类，将自动检测同步函数并将其设置为 MagicMock (如果父 Mock 是 AsyncMock 或 MagicMock)或 Mock (如果父 Mock 是 Mock)。 所有的异步函数都是 AsyncMock。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>ExampleClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>sync_foo</span><span class=p>():</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>... </span>    <span class=k>async</span> <span class=k>def</span> <span class=nf>async_foo</span><span class=p>():</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>a_mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>(</span><span class=n>ExampleClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>a_mock</span><span class=o>.</span><span class=n>sync_foo</span>
<span class=go>&lt;MagicMock name='mock.sync_foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>a_mock</span><span class=o>.</span><span class=n>async_foo</span>
<span class=go>&lt;AsyncMock name='mock.async_foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>ExampleClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>sync_foo</span>
<span class=go>&lt;Mock name='mock.sync_foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>async_foo</span>
<span class=go>&lt;AsyncMock name='mock.async_foo' id='...'&gt;</span>
</pre></div>
</div>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.8 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">New version 3.8 features.</p>
</div>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited>
<code class="sig-name descname">assert_awaited</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was awaited at least once. Note that this is separate
from the object having been called, the <code class="docutils literal notranslate"><span class=pre>await</span></code> keyword must be used:<p class="cyxy-trs-source cyxy-trs-target">断言至少有一次有人在等待模拟。 注意，这与被调用的对象是分开的，所以必须使用 await 关键字:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=n>coroutine_mock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>coroutine_mock</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>coroutine_mock</span> <span class=o>=</span> <span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected mock to have been awaited.</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=n>coroutine_mock</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited</span><span class=p>()</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited_once>
<code class="sig-name descname">assert_awaited_once</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited_once title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was awaited exactly once.<p class="cyxy-trs-source cyxy-trs-target">断言模拟只等待一次。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_once</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_awaited_once</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected mock to have been awaited once. Awaited 2 times.</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited_with>
<code class="sig-name descname">assert_awaited_with</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited_with title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the last await was with the specified arguments.<p class="cyxy-trs-source cyxy-trs-target">断言最后一个 await 具有指定的参数。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_with</span><span class=p>(</span><span class=s1>'other'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>expected call not found.</span>
<span class=go>Expected: mock('other')</span>
<span class=go>Actual: mock('foo', bar='bar')</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited_once_with>
<code class="sig-name descname">assert_awaited_once_with</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited_once_with title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was awaited exactly once and with the specified
arguments.<p class="cyxy-trs-source cyxy-trs-target">断言 mock 正好等待了一次并且带有指定的参数。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected mock to have been awaited once. Awaited 2 times.</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_any_await>
<code class="sig-name descname">assert_any_await</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_any_await title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert the mock has ever been awaited with the specified arguments.<p class="cyxy-trs-source cyxy-trs-target">使用指定的参数等待 Assert mock。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'hello'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_any_await</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_any_await</span><span class=p>(</span><span class=s1>'other'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>mock('other') await not found</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_has_awaits>
<code class="sig-name descname">assert_has_awaits</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">calls<font class=cyxy-trs-target> 呼叫</font></em>, <em class="sig-param cyxy-trs-source">any_order=False<font class=cyxy-trs-target> 任何命令错误</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_has_awaits title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert the mock has been awaited with the specified calls.
The <a class="reference internal" href=#unittest.mock.AsyncMock.await_args_list title=unittest.mock.AsyncMock.await_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args_list</span></code></a> list is checked for the awaits.<p class="cyxy-trs-source cyxy-trs-target">断言模拟已被指定的调用等待。等待参数列表被检查为等待。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>any_order</em> is false then the awaits must be
sequential. There can be extra calls before or after the
specified awaits.<p class="cyxy-trs-source cyxy-trs-target">如果任何命令是错误的，那么等待必须是顺序的。 在指定的等待之前或之后可以有额外的调用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>any_order</em> is true then the awaits can be in any order, but
they must all appear in <a class="reference internal" href=#unittest.mock.AsyncMock.await_args_list title=unittest.mock.AsyncMock.await_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args_list</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">如果任何顺序是正确的，那么等待可以是任何顺序，但是他们必须全部出现在等待的 args 列表中。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=s2>"foo"</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=s2>"bar"</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_awaits</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Awaits not found.</span>
<span class=go>Expected: [call('foo'), call('bar')]</span>
<span class=go>Actual: []</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_awaits</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_not_awaited>
<code class="sig-name descname">assert_not_awaited</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_not_awaited title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Assert that the mock was never awaited.<p class="cyxy-trs-source cyxy-trs-target">断言从来没有人在等待嘲弄。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_not_awaited</span><span class=p>()</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.reset_mock>
<code class="sig-name descname">reset_mock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.reset_mock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">See <a class="reference internal" href=#unittest.mock.Mock.reset_mock title=unittest.mock.Mock.reset_mock><code class="xref py py-func docutils literal notranslate"><span class=pre>Mock.reset_mock()</span></code></a>. Also sets <a class="reference internal" href=#unittest.mock.AsyncMock.await_count title=unittest.mock.AsyncMock.await_count><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_count</span></code></a> to 0,
<a class="reference internal" href=#unittest.mock.AsyncMock.await_args title=unittest.mock.AsyncMock.await_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args</span></code></a> to None, and clears the <a class="reference internal" href=#unittest.mock.AsyncMock.await_args_list title=unittest.mock.AsyncMock.await_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args_list</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">参见 Mock.reset mock ()。还将等待计数设置为0，等待 args 设置为 None，并清除等待 args 列表。</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.AsyncMock.await_count>
<code class="sig-name descname">await_count</code><a class=headerlink href=#unittest.mock.AsyncMock.await_count title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">An integer keeping track of how many times the mock object has been awaited.<p class="cyxy-trs-source cyxy-trs-target">一个整数，用于跟踪模拟对象等待的次数。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_count</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_count</span>
<span class=go>2</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.AsyncMock.await_args>
<code class="sig-name descname">await_args</code><a class=headerlink href=#unittest.mock.AsyncMock.await_args title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This is either <code class="docutils literal notranslate"><span class=pre>None</span></code> (if the mock hasn’t been awaited), or the arguments that
the mock was last awaited with. Functions the same as <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">这可能是 None (如果还没有等待 mock) ，也可能是最后等待 mock 的参数。 函数与 Mock.call args 相同。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args</span>
<span class=go>call('foo')</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args</span>
<span class=go>call('bar')</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.AsyncMock.await_args_list>
<code class="sig-name descname">await_args_list</code><a class=headerlink href=#unittest.mock.AsyncMock.await_args_list title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This is a list of all the awaits made to the mock object in sequence (so the
length of the list is the number of times it has been awaited). Before any
awaits have been made it is an empty list.<p class="cyxy-trs-source cyxy-trs-target">这是按顺序对模拟对象进行的所有等待的列表(因此列表的长度是等待它的次数)。 在任何等待已经作出它是一个空的名单。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args_list</span>
<span class=go>[]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args_list</span>
<span class=go>[call('foo')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args_list</span>
<span class=go>[call('foo'), call('bar')]</span>
</pre></div>
</div>
</dl>
</dl>
<div class=section id=calling>
<h3 class=cyxy-trs-source>Calling<font class=cyxy-trs-target> 来电</font><a class=headerlink href=#calling title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock objects are callable. The call will return the value set as the
<a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> attribute. The default return value is a new Mock
object; it is created the first time the return value is accessed (either
explicitly or by calling the Mock) - but it is stored and the same one
returned each time.<p class="cyxy-trs-source cyxy-trs-target">模仿对象是可调用的。 该调用将返回设置为返回值属性的值。 默认返回值是一个新的 Mock 对象; 它是在第一次访问返回值时创建的(显式地或通过调用 Mock) ，但是每次都存储并返回相同的返回值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Calls made to the object will be recorded in the attributes
like <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">对对象的调用将被记录在诸如调用 args 和调用 args 列表之类的属性中。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> is set then it will be called after the call has
been recorded, so if <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> raises an exception the call is still
recorded.<p class="cyxy-trs-source cyxy-trs-target">如果设置了副作用，那么它将在调用被记录之后被调用，因此如果副作用引发异常，调用仍然被记录。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The simplest way to make a mock raise an exception when called is to make
<a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> an exception class or instance:<p class="cyxy-trs-source cyxy-trs-target">在调用模拟引发时，使其成为异常的最简单方法是使副作用成为异常类或实例:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>IndexError</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>IndexError</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(1, 2, 3)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=ne>KeyError</span><span class=p>(</span><span class=s1>'Bang!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=s1>'two'</span><span class=p>,</span> <span class=s1>'three'</span><span class=p>,</span> <span class=s1>'four'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span><span>: </span><span class=n>'Bang!'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(1, 2, 3), call('two', 'three', 'four')]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> is a function then whatever that function returns is what
calls to the mock return. The <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> function is called with the
same arguments as the mock. This allows you to vary the return value of the
call dynamically, based on the input:<p class="cyxy-trs-source cyxy-trs-target">如果副作用是一个函数，那么该函数返回的内容就是调用 mock 返回的内容。 使用与 mock 相同的参数调用副作用函数。 这允许你根据输入动态地改变调用的返回值:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=n>value</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>value</span> <span class=o>+</span> <span class=mi>1</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>side_effect</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=go>2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(1), call(2)]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want the mock to still return the default return value (a new mock), or
any set return value, then there are two ways of doing this. Either return
<code class="xref py py-attr docutils literal notranslate"><span class=pre>mock.return_value</span></code> from inside <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code>, or return <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">如果您希望 mock 仍然返回默认的返回值(一个新的 mock)或任何设置的返回值，那么有两种方法可以做到这一点。 返回 mock.return 值，或者返回 DEFAULT:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>m</span><span class=o>.</span><span class=n>return_value</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=mi>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>DEFAULT</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">To remove a <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code>, and return to the default behaviour, set the
<code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> to <code class="docutils literal notranslate"><span class=pre>None</span></code>:<p class="cyxy-trs-source cyxy-trs-target">要消除副作用，并返回默认行为，请将副作用设置为 None:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>6</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=mi>3</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>6</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> can also be any iterable object. Repeated calls to the mock
will return values from the iterable (until the iterable is exhausted and
a <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#StopIteration title=StopIteration><code class="xref py py-exc docutils literal notranslate"><span class=pre>StopIteration</span></code></a> is raised):<p class="cyxy-trs-source cyxy-trs-target">副作用也可以是任何可迭代的对象。 对 mock 的重复调用将返回可迭代的值(直到可迭代的值用完并引发 StopIteration) :</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>StopIteration</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If any members of the iterable are exceptions they will be raised instead of
returned:<p class="cyxy-trs-source cyxy-trs-target">如果任何可迭代的成员是异常，它们将被引发而不是返回:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>iterable</span> <span class=o>=</span> <span class=p>(</span><span class=mi>33</span><span class=p>,</span> <span class=ne>ValueError</span><span class=p>,</span> <span class=mi>66</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>iterable</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>33</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>ValueError</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>66</span>
</pre></div>
</div>
</div>
<div class=section id=deleting-attributes>
<span id=id2></span><h3 class=cyxy-trs-source>Deleting Attributes<font class=cyxy-trs-target> 删除属性</font><a class=headerlink href=#deleting-attributes title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mock objects create attributes on demand. This allows them to pretend to be
objects of any type.<p class="cyxy-trs-source cyxy-trs-target">模拟对象根据需要创建属性。这允许它们假装是任何类型的对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You may want a mock object to return <code class="docutils literal notranslate"><span class=pre>False</span></code> to a <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#hasattr title=hasattr><code class="xref py py-func docutils literal notranslate"><span class=pre>hasattr()</span></code></a> call, or raise an
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> when an attribute is fetched. You can do this by providing
an object as a <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> for a mock, but that isn't always convenient.<p class="cyxy-trs-source cyxy-trs-target">您可能希望模拟对象将 False 返回到 hasattr ()调用，或者在提取属性时引发 AttributeError。 您可以通过为模拟提供一个对象作为 spec 来实现这一点，但这并不总是很方便。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You "block" attributes by deleting them. Once deleted, accessing an attribute
will raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">通过删除属性“阻塞”属性。一旦删除，访问属性将引发 AttributeError。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=s1>'m'</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>del</span> <span class=n>mock</span><span class=o>.</span><span class=n>m</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=s1>'m'</span><span class=p>)</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>del</span> <span class=n>mock</span><span class=o>.</span><span class=n>f</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>f</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>f</span>
</pre></div>
</div>
</div>
<div class=section id=mock-names-and-the-name-attribute>
<h3 class=cyxy-trs-source>Mock names and the name attribute<font class=cyxy-trs-target> 模拟名称和 name 属性</font><a class=headerlink href=#mock-names-and-the-name-attribute title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Since "name" is an argument to the <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> constructor, if you want your
mock object to have a "name" attribute you can't just pass it in at creation
time. There are two alternatives. One option is to use
<a class="reference internal" href=#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">因为“ name”是 Mock 构造函数的一个参数，所以如果您希望您的 Mock 对象具有一个“ name”属性，那么您不能在创建时将它传入。 有两种选择。 一种选择是使用 configure mock () :</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>configure_mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'my_name'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>name</span>
<span class=go>'my_name'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A simpler option is to simply set the "name" attribute after mock creation:<p class="cyxy-trs-source cyxy-trs-target">一个更简单的选择是在模拟创建后简单地设置“ name”属性:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=s2>"foo"</span>
</pre></div>
</div>
</div>
<div class=section id=attaching-mocks-as-attributes>
<h3 class=cyxy-trs-source>Attaching Mocks as Attributes<font class=cyxy-trs-target> 作为属性附加模拟</font><a class=headerlink href=#attaching-mocks-as-attributes title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">When you attach a mock as an attribute of another mock (or as the return
value) it becomes a "child" of that mock. Calls to the child are recorded in
the <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> attributes of the
parent. This is useful for configuring child mocks and then attaching them to
the parent, or for attaching mocks to a parent that records all calls to the
children and allows you to make assertions about the order of calls between
mocks:<p class="cyxy-trs-source cyxy-trs-target">当您将 mock 附加为另一个 mock 的属性(或作为返回值)时，它就变成了该 mock 的“子”。 对子类的调用记录在父类的方法调用和模拟调用属性中。 这对于配置子模拟，然后将它们附加到父模拟，或者将模拟附加到父模拟，记录所有对子模拟的调用，并允许您断言模拟之间的调用顺序:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child1</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child2</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>child1</span> <span class=o>=</span> <span class=n>child1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>child2</span> <span class=o>=</span> <span class=n>child2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child1</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child2</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.child1(1), call.child2(2)]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The exception to this is if the mock has a name. This allows you to prevent
the "parenting" if for some reason you don't want it to happen.<p class="cyxy-trs-source cyxy-trs-target">这个例外是，如果 mock 有一个名称。 如果出于某种原因你不希望这种情况发生，这可以让你阻止“养育”。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>not_a_child</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'not-a-child'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>attribute</span> <span class=o>=</span> <span class=n>not_a_child</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>attribute</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='not-a-child()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mocks created for you by <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> are automatically given names. To
attach mocks that have names to a parent you use the <a class="reference internal" href=#unittest.mock.Mock.attach_mock title=unittest.mock.Mock.attach_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>attach_mock()</span></code></a>
method:<p class="cyxy-trs-source cyxy-trs-target">通过 patch ()为您创建的模拟会自动给出名称。 要将具有名称的模拟连接到父类，可以使用 attach mock ()方法:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>thing1</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing2</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing1'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=k>as</span> <span class=n>child1</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing2'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=k>as</span> <span class=n>child2</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>parent</span><span class=o>.</span><span class=n>attach_mock</span><span class=p>(</span><span class=n>child1</span><span class=p>,</span> <span class=s1>'child1'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>parent</span><span class=o>.</span><span class=n>attach_mock</span><span class=p>(</span><span class=n>child2</span><span class=p>,</span> <span class=s1>'child2'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>child1</span><span class=p>(</span><span class=s1>'one'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>child2</span><span class=p>(</span><span class=s1>'two'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.child1('one'), call.child2('two')]</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class=label id=id3><span class=brackets><a class=fn-backref href=#id1>1</a></span></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">The only exceptions are magic methods and attributes (those that have
leading and trailing double underscores). Mock doesn't create these but
instead raises an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>. This is because the interpreter
will often implicitly request these methods, and gets <em>very</em> confused to
get a new Mock object when it expects a magic method. If you need magic
method support see <a class="reference internal" href=#magic-methods><span class="std std-ref">magic methods</span></a>.<p class="cyxy-trs-source cyxy-trs-target">唯一的例外是神奇的方法和属性(那些具有前导和尾随的双下划线)。 不创建这些，而是引发一个属性错误。 这是因为解释器通常会隐式地请求这些方法，并且当它需要一个魔法方法时，会非常困惑地获得一个新的 Mock 对象。 如果您需要魔术方法支持，请参阅魔术方法。</p>
</dd>
</dl>
</div>
</div>
<div class=section id=the-patchers>
<h2 class=cyxy-trs-source>The patchers<font class=cyxy-trs-target> 修补者</font><a class=headerlink href=#the-patchers title=永久链接至标题>¶</a></h2>
<p class="cyxy-trs-source cyxy-trs-source-ted">The patch decorators are used for patching objects only within the scope of
the function they decorate. They automatically handle the unpatching for you,
even if exceptions are raised. All of these functions can also be used in with
statements or as class decorators.<p class="cyxy-trs-source cyxy-trs-target">修补程序装饰器仅用于修补它们装饰的功能范围内的对象。 它们会自动为您处理解包，即使引发了异常。 所有这些函数也可以与语句一起使用，或者用作类装饰符。</p>
<div class=section id=patch>
<h3 class=cyxy-trs-source>patch<font class=cyxy-trs-target> 补丁</font><a class=headerlink href=#patch title=永久链接至标题>¶</a></h3>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The key is to do the patching in the right namespace. See the section <a class="reference internal" href=#id6>where to patch</a>.<p class="cyxy-trs-source cyxy-trs-target">关键是在正确的名称空间中进行修补。</p>
</div>
<dl class=function>
<dt id=unittest.mock.patch>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">patch</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">target<font class=cyxy-trs-target> 目标</font></em>, <em class="sig-param cyxy-trs-source">new=DEFAULT<font class=cyxy-trs-target> 新的违约</font></em>, <em class="sig-param cyxy-trs-source">spec=None<font class=cyxy-trs-target> 没有</font></em>, <em class="sig-param cyxy-trs-source">create=False<font class=cyxy-trs-target> 创造虚假</font></em>, <em class="sig-param cyxy-trs-source">spec_set=None<font class=cyxy-trs-target> 规格设置为 None</font></em>, <em class="sig-param cyxy-trs-source">autospec=None<font class=cyxy-trs-target> 自动投影仪</font></em>, <em class="sig-param cyxy-trs-source">new_callable=None<font class=cyxy-trs-target> 新的可调用无</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> acts as a function decorator, class decorator or a context
manager. Inside the body of the function or with statement, the <em>target</em>
is patched with a <em>new</em> object. When the function/with statement exits
the patch is undone.<p class="cyxy-trs-source cyxy-trs-target">Patch ()充当函数装饰器、类装饰器或上下文管理器。 在函数或 with 语句的主体内部，用一个新对象修补目标。 当函数 / with 语句退出时，补丁程序被撤消。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>new</em> is omitted, then the target is replaced with an
<a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> if the patched object is an async function or
a <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> otherwise.
If <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> is used as a decorator and <em>new</em> is
omitted, the created mock is passed in as an extra argument to the
decorated function. If <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> is used as a context manager the created
mock is returned by the context manager.<p class="cyxy-trs-source cyxy-trs-target">如果省略 new，则如果补丁对象是异步函数或 MagicMock，则用 AsyncMock 替换目标。 如果 patch ()用作装饰符，而 new 被省略，则创建的 mock 将作为一个额外参数传递给修饰函数。 如果 patch ()用作上下文管理器，则上下文管理器将返回创建的 mock。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>target</em> should be a string in the form <code class="docutils literal notranslate"><span class=pre>'package.module.ClassName'</span></code>. The
<em>target</em> is imported and the specified object replaced with the <em>new</em>
object, so the <em>target</em> must be importable from the environment you are
calling <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> from. The target is imported when the decorated function
is executed, not at decoration time.<p class="cyxy-trs-source cyxy-trs-target">Target 应该是 package.module 表单中的字符串。 类名。 导入目标并用新对象替换指定的对象，因此目标必须可从调用 patch ()的环境中导入。 在执行修饰函数时导入目标，而不是在修饰时导入。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <em>spec</em> and <em>spec_set</em> keyword arguments are passed to the <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>
if patch is creating one for you.<p class="cyxy-trs-source cyxy-trs-target">如果 patch 正在为您创建一个关键字参数，那么 spec 和 spec set 关键字参数将传递给 MagicMock。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">In addition you can pass <code class="docutils literal notranslate"><span class=pre>spec=True</span></code> or <code class="docutils literal notranslate"><span class=pre>spec_set=True</span></code>, which causes
patch to pass in the object being mocked as the spec/spec_set object.<p class="cyxy-trs-source cyxy-trs-target">此外，您可以传递 spec True 或 spec set True，这会导致补丁传递给被嘲笑为 spec / spec set 对象的对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>new_callable</em> allows you to specify a different class, or callable object,
that will be called to create the <em>new</em> object. By default <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a>
is used for async functions and <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> for the rest.<p class="cyxy-trs-source cyxy-trs-target">New callable 允许您指定一个不同的类或可调用对象，这个类或可调用对象将被调用以创建新对象。 默认情况下，AsyncMock 用于异步函数，MagicMock 用于其余的函数。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">A more powerful form of <em>spec</em> is <em>autospec</em>. If you set <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code>
then the mock will be created with a spec from the object being replaced.
All attributes of the mock will also have the spec of the corresponding
attribute of the object being replaced. Methods and functions being mocked
will have their arguments checked and will raise a <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#TypeError title=TypeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>TypeError</span></code></a> if they are
called with the wrong signature. For mocks
replacing a class, their return value (the 'instance') will have the same
spec as the class. See the <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> function and
<a class="reference internal" href=#auto-speccing><span class="std std-ref">Autospeccing</span></a>.<p class="cyxy-trs-source cyxy-trs-target">一种更强大的天赋形式是 autospec。 如果您设置 autospec True，那么将使用替换对象的 spec 创建 mock。 Mock 的所有属性还将具有被替换对象的相应属性的规范。 被嘲笑的方法和函数将检查它们的参数，如果使用错误的签名调用它们，将引发 TypeError。 对于替换类的模拟，它们的返回值(“实例”)将具有与类相同的规范。 请参阅 create autospec ()函数和 Autospeccing。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Instead of <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> you can pass <code class="docutils literal notranslate"><span class=pre>autospec=some_object</span></code> to use an
arbitrary object as the spec instead of the one being replaced.<p class="cyxy-trs-source cyxy-trs-target">除了 autospec True 之外，您还可以传递 autospec 一些对象来使用任意的对象作为 spec，而不是被替换的对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">By default <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> will fail to replace attributes that don't exist.
If you pass in <code class="docutils literal notranslate"><span class=pre>create=True</span></code>, and the attribute doesn't exist, patch will
create the attribute for you when the patched function is called, and delete
it again after the patched function has exited. This is useful for writing
tests against attributes that your production code creates at runtime. It is
off by default because it can be dangerous. With it switched on you can
write passing tests against APIs that don't actually exist!<p class="cyxy-trs-source cyxy-trs-target">默认情况下，patch ()将无法替换不存在的属性。 如果传入 create True，而该属性不存在，则 patch 将在调用补丁函数时为您创建该属性，并在补丁函数退出后再次删除该属性。 这对于针对生产代码在运行时创建的属性编写测试非常有用。 默认情况下它是关闭的，因为它可能是危险的。 打开它之后，您可以针对实际上并不存在的 api 编写传递测试！</p>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.5 版更改: </span>If you are patching builtins in a module then you don't
need to pass <code class="docutils literal notranslate"><span class=pre>create=True</span></code>, it will be added by default.<p class="cyxy-trs-source cyxy-trs-target">Something 3.5 something something: 如果你在一个模块中补丁内置的，那么你不需要通过创建真，它将被默认添加。</p>
</div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Patch can be used as a <code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code> class decorator. It works by
decorating each test method in the class. This reduces the boilerplate
code when your test methods share a common patchings set. <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> finds
tests by looking for method names that start with <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code>.
By default this is <code class="docutils literal notranslate"><span class=pre>'test'</span></code>, which matches the way <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.html#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> finds tests.
You can specify an alternative prefix by setting <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code>.<p class="cyxy-trs-source cyxy-trs-target">修补程序可以用作 TestCase 类装饰器。 它通过修饰类中的每个测试方法来工作。 当您的测试方法共享一个共同的拼凑集合时，这将减少样板代码。 Patch ()通过查找以 patch.TEST PREFIX 开头的方法名来查找测试。 默认情况下，这是‘ test’ ，与 unittest 查找测试的方式相匹配。 您可以通过设置 patch.TEST PREFIX 来指定替代前缀。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Patch can be used as a context manager, with the with statement. Here the
patching applies to the indented block after the with statement. If you
use "as" then the patched object will be bound to the name after the
"as"; very useful if <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> is creating a mock object for you.<p class="cyxy-trs-source cyxy-trs-target">补丁可以用作上下文管理器，带有 with 语句。 在这里，修补应用于 with 语句之后的缩进块。 如果使用“ as” ，那么打补丁的对象将绑定到“ as”后面的名称; 如果 patch ()正在为您创建一个模拟对象，则非常有用。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> takes arbitrary keyword arguments. These will be passed to
<a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> if the patched object is asynchronous, to
<a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> otherwise or to <em>new_callable</em> if specified.<p class="cyxy-trs-source cyxy-trs-target">Patch ()接受任意的关键字参数。 如果打补丁的对象是异步的，那么这些函数将被传递给 AsyncMock，如果指定了，则传递给 MagicMock 或者传递给新的可调用函数。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>patch.dict(...)</span></code>, <code class="docutils literal notranslate"><span class=pre>patch.multiple(...)</span></code> and <code class="docutils literal notranslate"><span class=pre>patch.object(...)</span></code> are
available for alternate use-cases.<p class="cyxy-trs-source cyxy-trs-target">Patch.dict (...)、 patch.multiple (...)和 patch.object (...)可用于替代用例。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> as function decorator, creating the mock for you and passing it into
the decorated function:<p class="cyxy-trs-source cyxy-trs-target">Patch ()作为函数 decorator，为您创建模型并将其传递到修饰函数:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'__main__.SomeClass'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>function</span><span class=p>(</span><span class=n>normal_argument</span><span class=p>,</span> <span class=n>mock_class</span><span class=p>):</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=n>mock_class</span> <span class=ow>is</span> <span class=n>SomeClass</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>function</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Patching a class replaces the class with a <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> <em>instance</em>. If the
class is instantiated in the code under test then it will be the
<a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> of the mock that will be used.<p class="cyxy-trs-source cyxy-trs-target">用 MagicMock 实例替换类。 如果类是在测试代码中实例化的，那么将使用 mock 的返回值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If the class is instantiated multiple times you could use
<a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> to return a new mock each time. Alternatively you
can set the <em>return_value</em> to be anything you want.<p class="cyxy-trs-source cyxy-trs-target">如果类被实例化多次，您可以使用副作用每次返回一个新的 mock。 或者，您可以将返回值设置为您想要的任何值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">To configure return values on methods of <em>instances</em> on the patched class
you must do this on the <code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code>. For example:<p class="cyxy-trs-source cyxy-trs-target">若要在补丁类上的实例方法上配置返回值，必须在返回值上进行此操作。 例如:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Class</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Class'</span><span class=p>)</span> <span class=k>as</span> <span class=n>MockClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>instance</span> <span class=o>=</span> <span class=n>MockClass</span><span class=o>.</span><span class=n>return_value</span>
<span class=gp>... </span>    <span class=n>instance</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'foo'</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>Class</span><span class=p>()</span> <span class=ow>is</span> <span class=n>instance</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>Class</span><span class=p>()</span><span class=o>.</span><span class=n>method</span><span class=p>()</span> <span class=o>==</span> <span class=s1>'foo'</span>
<span class=gp>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you use <em>spec</em> or <em>spec_set</em> and <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> is replacing a <em>class</em>, then the
return value of the created mock will have the same spec.<p class="cyxy-trs-source cyxy-trs-target">如果您使用 spec 或 spec set，而 patch ()正在替换一个类，那么创建的 mock 的返回值将具有相同的 spec。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>Original</span> <span class=o>=</span> <span class=n>Class</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Class'</span><span class=p>,</span> <span class=n>spec</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MockClass</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>instance</span> <span class=o>=</span> <span class=n>MockClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>instance</span><span class=p>,</span> <span class=n>Original</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <em>new_callable</em> argument is useful where you want to use an alternative
class to the default <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> for the created mock. For example, if
you wanted a <a class="reference internal" href=#unittest.mock.NonCallableMock title=unittest.mock.NonCallableMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMock</span></code></a> to be used:<p class="cyxy-trs-source cyxy-trs-target">新的可调用参数非常有用，因为您希望为创建的 mock 使用默认 MagicMock 的替代类。 例如，如果您希望使用 NonCallableMock:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing'</span><span class=p>,</span> <span class=n>new_callable</span><span class=o>=</span><span class=n>NonCallableMock</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_thing</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>thing</span> <span class=ow>is</span> <span class=n>mock_thing</span>
<span class=gp>... </span>    <span class=n>thing</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>TypeError</span><span>: </span><span class=n>'NonCallableMock' object is not callable</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Another use case might be to replace an object with an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/io.html#io.StringIO title=io.StringIO><code class="xref py py-class docutils literal notranslate"><span class=pre>io.StringIO</span></code></a> instance:<p class="cyxy-trs-source cyxy-trs-target">另一个用例可能是用 io.StringIO 实例替换对象:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>io</span> <span class=kn>import</span> <span class=n>StringIO</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>foo</span><span class=p>():</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=s1>'Something'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.stdout'</span><span class=p>,</span> <span class=n>new_callable</span><span class=o>=</span><span class=n>StringIO</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_stdout</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>foo</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>mock_stdout</span><span class=o>.</span><span class=n>getvalue</span><span class=p>()</span> <span class=o>==</span> <span class=s1>'Something</span><span class=se>\n</span><span class=s1>'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">When <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> is creating a mock for you, it is common that the first thing
you need to do is to configure the mock. Some of that configuration can be done
in the call to patch. Any arbitrary keywords you pass into the call will be
used to set attributes on the created mock:<p class="cyxy-trs-source cyxy-trs-target">当 patch ()为您创建模拟时，通常需要做的第一件事是配置模拟。 其中一些配置可以在调用补丁时完成。 你传递给调用的任意关键字都会被用来在创建的 mock 上设置属性:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing'</span><span class=p>,</span> <span class=n>first</span><span class=o>=</span><span class=s1>'one'</span><span class=p>,</span> <span class=n>second</span><span class=o>=</span><span class=s1>'two'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>first</span>
<span class=go>'one'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>second</span>
<span class=go>'two'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">As well as attributes on the created mock attributes, like the
<a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a>, of child mocks can
also be configured. These aren't syntactically valid to pass in directly as
keyword arguments, but a dictionary with these as keys can still be expanded
into a <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> call using <code class="docutils literal notranslate"><span class=pre>**</span></code>:<p class="cyxy-trs-source cyxy-trs-target">除了已创建的模拟属性(如返回值和副作用)上的属性外，还可以配置子模拟的属性。 它们在语法上不能直接作为关键字参数传入，但是使用它们作为键的字典仍然可以扩展为使用 * * 的 patch ()调用:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>config</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing'</span><span class=p>,</span> <span class=o>**</span><span class=n>config</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">By default, attempting to patch a function in a module (or a method or an
attribute in a class) that does not exist will fail with <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">默认情况下，尝试将不存在的模块(或类中的方法或属性)中的函数打补丁将失败。 AttributeError:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.non_existing_attribute'</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>sys</span><span class=o>.</span><span class=n>non_existing_attribute</span> <span class=o>==</span> <span class=mi>42</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>&lt;module 'sys' (built-in)&gt; does not have the attribute 'non_existing'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">but adding <code class="docutils literal notranslate"><span class=pre>create=True</span></code> in the call to <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> will make the previous example
work as expected:<p class="cyxy-trs-source cyxy-trs-target">但是在对 patch ()的调用中添加 create True 将使前面的示例正常工作:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.non_existing_attribute'</span><span class=p>,</span> <span class=mi>42</span><span class=p>,</span> <span class=n>create</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_stdout</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>sys</span><span class=o>.</span><span class=n>non_existing_attribute</span> <span class=o>==</span> <span class=mi>42</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> now returns an <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> if the target is an async function.<p class="cyxy-trs-source cyxy-trs-target">如果目标是一个异步函数，那么3.8 something something: patch ()现在返回一个 AsyncMock。</p>
</div>
</div>
<div class=section id=patch-object>
<h3 class=cyxy-trs-source>patch.object<font class=cyxy-trs-target> 补丁，对象</font><a class=headerlink href=#patch-object title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.patch.object>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">object</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">target<font class=cyxy-trs-target> 目标</font></em>, <em class="sig-param cyxy-trs-source">attribute<font class=cyxy-trs-target> 属性</font></em>, <em class="sig-param cyxy-trs-source">new=DEFAULT<font class=cyxy-trs-target> 新的违约</font></em>, <em class="sig-param cyxy-trs-source">spec=None<font class=cyxy-trs-target> 没有</font></em>, <em class="sig-param cyxy-trs-source">create=False<font class=cyxy-trs-target> 创造虚假</font></em>, <em class="sig-param cyxy-trs-source">spec_set=None<font class=cyxy-trs-target> 规格设置为 None</font></em>, <em class="sig-param cyxy-trs-source">autospec=None<font class=cyxy-trs-target> 自动投影仪</font></em>, <em class="sig-param cyxy-trs-source">new_callable=None<font class=cyxy-trs-target> 新的可调用无</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.object title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">patch the named member (<em>attribute</em>) on an object (<em>target</em>) with a mock
object.<p class="cyxy-trs-source cyxy-trs-target">用模拟对象在对象(目标)上修补命名成员(属性)。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> can be used as a decorator, class decorator or a context
manager. Arguments <em>new</em>, <em>spec</em>, <em>create</em>, <em>spec_set</em>, <em>autospec</em> and
<em>new_callable</em> have the same meaning as for <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>. Like <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>,
<a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> takes arbitrary keyword arguments for configuring the mock
object it creates.<p class="cyxy-trs-source cyxy-trs-target">Object ()可以用作装饰器、类装饰器或上下文管理器。 参数 new、 spec、 create、 spec set、 autospec 和 new callable 与 patch ()的含义相同。 与 patch ()一样，patch.object ()可以使用任意的关键字参数配置它创建的模拟对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">When used as a class decorator <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> honours <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code>
for choosing which methods to wrap.<p class="cyxy-trs-source cyxy-trs-target">当用作类装饰器 patch.object ()时，patch.TEST 前缀可用于选择包装哪个方法。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can either call <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> with three arguments or two arguments. The
three argument form takes the object to be patched, the attribute name and the
object to replace the attribute with.<p class="cyxy-trs-source cyxy-trs-target">您可以使用三个参数或两个参数调用 patch.object ()。 三个参数表单接受要修补的对象、属性名和要用来替换属性的对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">When calling with the two argument form you omit the replacement object, and a
mock is created for you and passed in as an extra argument to the decorated
function:<p class="cyxy-trs-source cyxy-trs-target">当使用这两个参数表单调用时，可以省略替换对象，然后为您创建一个 mock，并将其作为一个额外的参数传入修饰函数:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'class_method'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_method</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>SomeClass</span><span class=o>.</span><span class=n>class_method</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>mock_method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>spec</em>, <em>create</em> and the other arguments to <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> have the same
meaning as they do for <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Spec、 create 和 patch.object ()的其他参数的含义与 patch ()的含义相同。</p>
</div>
<div class=section id=patch-dict>
<h3>patch.dict<a class=headerlink href=#patch-dict title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.patch.dict>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">dict</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">in_dict<font class=cyxy-trs-target> 在 dict</font></em>, <em class="sig-param cyxy-trs-source">values=()<font class=cyxy-trs-target> 值()</font></em>, <em class="sig-param cyxy-trs-source">clear=False<font class=cyxy-trs-target> 清除错误</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.dict title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Patch a dictionary, or dictionary like object, and restore the dictionary
to its original state after the test.<p class="cyxy-trs-source cyxy-trs-target">修补字典或类似字典的对象，并在测试后将字典恢复到其原始状态。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>in_dict</em> can be a dictionary or a mapping like container. If it is a
mapping then it must at least support getting, setting and deleting items
plus iterating over keys.<p class="cyxy-trs-source cyxy-trs-target">在 dict 可以是一个字典或映射像容器。 如果它是一个映射，那么它必须至少支持获取、设置和删除项目，并在键上迭代。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>in_dict</em> can also be a string specifying the name of the dictionary, which
will then be fetched by importing it.<p class="cyxy-trs-source cyxy-trs-target">Dict 中也可以是一个指定字典名称的字符串，然后通过导入该字典获取该字符串。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>values</em> can be a dictionary of values to set in the dictionary. <em>values</em>
can also be an iterable of <code class="docutils literal notranslate"><span class=pre>(key,</span> <span class=pre>value)</span></code> pairs.<p class="cyxy-trs-source cyxy-trs-target">值可以是要在字典中设置的值的字典。 值也可以是(键、值)对的迭代。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>clear</em> is true then the dictionary will be cleared before the new
values are set.<p class="cyxy-trs-source cyxy-trs-target">如果 clear 为 true，则在设置新值之前将清除字典。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> can also be called with arbitrary keyword arguments to set
values in the dictionary.<p class="cyxy-trs-source cyxy-trs-target">Patch.dict ()也可以使用任意的关键字参数来调用，以便在字典中设置值。</p>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> now returns the patched dictionary when used as a context
manager.<p class="cyxy-trs-source cyxy-trs-target">当用作上下文管理器时，patch.dict ()现在返回打补丁的字典。</p>
</div>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> can be used as a context manager, decorator or class
decorator:<p class="cyxy-trs-source cyxy-trs-target">Patch.dict ()可用作上下文管理器、装饰器或类装饰器:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>})</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{}</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">When used as a class decorator <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> honours
<code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> (default to <code class="docutils literal notranslate"><span class=pre>'test'</span></code>) for choosing which methods to wrap:<p class="cyxy-trs-source cyxy-trs-target">当用作类装饰器 patch.dict ()时，patch.TEST PREFIX (默认为“ test”)用于选择包装哪些方法:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>os</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>unittest</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>patch</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'os.environ'</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>})</span>
<span class=gp>... </span><span class=k>class</span> <span class=nc>TestSample</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_sample</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s1>'newkey'</span><span class=p>],</span> <span class=s1>'newvalue'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want to use a different prefix for your test, you can inform the
patchers of the different prefix by setting <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code>. For
more details about how to change the value of see <a class="reference internal" href=#test-prefix><span class="std std-ref">TEST_PREFIX</span></a>.<p class="cyxy-trs-source cyxy-trs-target">如果您想为您的测试使用不同的前缀，您可以通过设置 patc.test PREFIX 通知不同前缀的 patchers。 有关如何更改 testprefix 值的详细信息，请参阅。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> can be used to add members to a dictionary, or simply let a test
change a dictionary, and ensure the dictionary is restored when the test
ends.<p class="cyxy-trs-source cyxy-trs-target">Patch.dict ()可用于向字典添加成员，或者只是让测试更改字典，并确保在测试结束时还原字典。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>})</span> <span class=k>as</span> <span class=n>patched_foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>patched_foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>... </span>    <span class=c1># You can add, update or delete keys of foo (or patched_foo, it's the same dict)</span>
<span class=gp>... </span>    <span class=n>patched_foo</span><span class=p>[</span><span class=s1>'spam'</span><span class=p>]</span> <span class=o>=</span> <span class=s1>'eggs'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>patched_foo</span> <span class=o>==</span> <span class=p>{}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>os</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'os.environ'</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}):</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s1>'newkey'</span><span class=p>])</span>
<span class=gp>...</span>
<span class=go>newvalue</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=s1>'newkey'</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Keywords can be used in the <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> call to set values in the dictionary:<p class="cyxy-trs-source cyxy-trs-target">可以在 patch.dict ()调用中使用关键字来设置字典中的值:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mymodule</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymodule</span><span class=o>.</span><span class=n>function</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'sys.modules'</span><span class=p>,</span> <span class=n>mymodule</span><span class=o>=</span><span class=n>mymodule</span><span class=p>):</span>
<span class=gp>... </span>    <span class=kn>import</span> <span class=nn>mymodule</span>
<span class=gp>... </span>    <span class=n>mymodule</span><span class=o>.</span><span class=n>function</span><span class=p>(</span><span class=s1>'some'</span><span class=p>,</span> <span class=s1>'args'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=go>'fish'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> can be used with dictionary like objects that aren't actually
dictionaries. At the very minimum they must support item getting, setting,
deleting and either iteration or membership test. This corresponds to the
magic methods <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__getitem__ title=object.__getitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__getitem__()</span></code></a>, <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__setitem__ title=object.__setitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__setitem__()</span></code></a>, <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__delitem__ title=object.__delitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__delitem__()</span></code></a> and either
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__iter__ title=object.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a> or <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__contains__ title=object.__contains__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__contains__()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Patch.dict ()可以与字典一样用于实际上不是字典的对象。 至少他们必须支持项目获取，设置，删除和迭代或成员资格测试。 这对应于魔法方法 getitem ()、 setitem ()、 delitem ()和 iter ()或 contains ()。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Container</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>values</span> <span class=o>=</span> <span class=p>{}</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>[</span><span class=n>name</span><span class=p>]</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__setitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>[</span><span class=n>name</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__delitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>[</span><span class=n>name</span><span class=p>]</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>iter</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=n>Container</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=p>[</span><span class=s1>'one'</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>thing</span><span class=p>,</span> <span class=n>one</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>two</span><span class=o>=</span><span class=mi>3</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>thing</span><span class=p>[</span><span class=s1>'one'</span><span class=p>]</span> <span class=o>==</span> <span class=mi>2</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>thing</span><span class=p>[</span><span class=s1>'two'</span><span class=p>]</span> <span class=o>==</span> <span class=mi>3</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>thing</span><span class=p>[</span><span class=s1>'one'</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=nb>list</span><span class=p>(</span><span class=n>thing</span><span class=p>)</span> <span class=o>==</span> <span class=p>[</span><span class=s1>'one'</span><span class=p>]</span>
</pre></div>
</div>
</div>
<div class=section id=patch-multiple>
<h3 class=cyxy-trs-source>patch.multiple<font class=cyxy-trs-target> 拼凑，复合</font><a class=headerlink href=#patch-multiple title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.patch.multiple>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">multiple</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">target<font class=cyxy-trs-target> 目标</font></em>, <em class="sig-param cyxy-trs-source">spec=None<font class=cyxy-trs-target> 没有</font></em>, <em class="sig-param cyxy-trs-source">create=False<font class=cyxy-trs-target> 创造虚假</font></em>, <em class="sig-param cyxy-trs-source">spec_set=None<font class=cyxy-trs-target> 规格设置为 None</font></em>, <em class="sig-param cyxy-trs-source">autospec=None<font class=cyxy-trs-target> 自动投影仪</font></em>, <em class="sig-param cyxy-trs-source">new_callable=None<font class=cyxy-trs-target> 新的可调用无</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.multiple title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Perform multiple patches in a single call. It takes the object to be
patched (either as an object or a string to fetch the object by importing)
and keyword arguments for the patches:<p class="cyxy-trs-source cyxy-trs-target">在一个调用中执行多个补丁。 它接受要修补的对象(作为对象或通过导入获取对象的字符串)和补丁的关键字参数:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=n>settings</span><span class=p>,</span> <span class=n>FIRST_PATCH</span><span class=o>=</span><span class=s1>'one'</span><span class=p>,</span> <span class=n>SECOND_PATCH</span><span class=o>=</span><span class=s1>'two'</span><span class=p>):</span>
    <span class=o>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Use <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> as the value if you want <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> to create
mocks for you. In this case the created mocks are passed into a decorated
function by keyword, and a dictionary is returned when <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> is
used as a context manager.<p class="cyxy-trs-source cyxy-trs-target">如果希望 patch.multiple ()为您创建模拟，请使用 DEFAULT 作为值。 在这种情况下，通过关键字将创建的模拟传递到修饰函数中，当 patc.multiple ()用作上下文管理器时，将返回一个 dictionary。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> can be used as a decorator, class decorator or a context
manager. The arguments <em>spec</em>, <em>spec_set</em>, <em>create</em>, <em>autospec</em> and
<em>new_callable</em> have the same meaning as for <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>. These arguments will
be applied to <em>all</em> patches done by <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Multiple ()可以用作装饰器、类装饰器或上下文管理器。 参数 spec、 spec set、 create、 autospec 和 new callable 的含义与 patch ()相同。 这些参数将应用于 patch.multiple ()完成的所有补丁。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">When used as a class decorator <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> honours <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code>
for choosing which methods to wrap.<p class="cyxy-trs-source cyxy-trs-target">当用作类装饰器 patch.multiple ()时，会使用 patch.TEST 前缀来选择包装哪个方法。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> to create mocks for you, then you can use
<a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> as the value. If you use <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> as a decorator
then the created mocks are passed into the decorated function by keyword.<p class="cyxy-trs-source cyxy-trs-target">如果希望 patch.multiple ()为您创建模拟，则可以使用 DEFAULT 作为值。 如果使用 patch.multiple ()作为装饰器，那么通过关键字将创建的模拟传递到修饰函数中。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>other</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>

<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=s1>'__main__'</span><span class=p>,</span> <span class=n>thing</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test_function</span><span class=p>(</span><span class=n>thing</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>thing</span><span class=p>,</span> <span class=n>MagicMock</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>MagicMock</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test_function</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> can be nested with other <code class="docutils literal notranslate"><span class=pre>patch</span></code> decorators, but put arguments
passed by keyword <em>after</em> any of the standard arguments created by <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">Multiple ()可以与其他补丁修饰符嵌套，但是在 patch ()创建的任何标准参数之后放置通过关键字传递的参数:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.exit'</span><span class=p>)</span>
<span class=gp>... </span><span class=nd>@patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=s1>'__main__'</span><span class=p>,</span> <span class=n>thing</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test_function</span><span class=p>(</span><span class=n>mock_exit</span><span class=p>,</span> <span class=n>other</span><span class=p>,</span> <span class=n>thing</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'other'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>other</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'thing'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>thing</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'exit'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>mock_exit</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test_function</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> is used as a context manager, the value returned by the
context manager is a dictionary where created mocks are keyed by name:<p class="cyxy-trs-source cyxy-trs-target">如果 patc.multiple ()用作上下文管理器，上下文管理器返回的值就是一个字典，其中创建的模拟按名称键入:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=s1>'__main__'</span><span class=p>,</span> <span class=n>thing</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>)</span> <span class=k>as</span> <span class=n>values</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'other'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=s1>'other'</span><span class=p>])</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'thing'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=s1>'thing'</span><span class=p>])</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>values</span><span class=p>[</span><span class=s1>'thing'</span><span class=p>]</span> <span class=ow>is</span> <span class=n>thing</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>values</span><span class=p>[</span><span class=s1>'other'</span><span class=p>]</span> <span class=ow>is</span> <span class=n>other</span>
<span class=gp>...</span>
</pre></div>
</div>
</div>
<div class=section id=patch-methods-start-and-stop>
<span id=start-and-stop></span><h3 class=cyxy-trs-source>patch methods: start and stop<font class=cyxy-trs-target> 补丁方法: 启动和停止</font><a class=headerlink href=#patch-methods-start-and-stop title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">All the patchers have <code class="xref py py-meth docutils literal notranslate"><span class=pre>start()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code> methods. These make it simpler to do
patching in <code class="docutils literal notranslate"><span class=pre>setUp</span></code> methods or where you want to do multiple patches without
nesting decorators or with statements.<p class="cyxy-trs-source cyxy-trs-target">所有的 patchers 都有 start ()和 stop ()方法。 这使得在 setUp 方法中或在不使用嵌套 decorator 或语句的情况下执行多个补丁更加简单。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">To use them call <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>, <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> or <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> as
normal and keep a reference to the returned <code class="docutils literal notranslate"><span class=pre>patcher</span></code> object. You can then
call <code class="xref py py-meth docutils literal notranslate"><span class=pre>start()</span></code> to put the patch in place and <code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code> to undo it.<p class="cyxy-trs-source cyxy-trs-target">要正常使用它们，可以调用 patch ()、 patc.object ()或 patc.dict () ，并保持对返回的 patcher 对象的引用。 然后可以调用 start ()来放置补丁并停止()来撤销补丁。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you are using <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> to create a mock for you then it will be returned by
the call to <code class="docutils literal notranslate"><span class=pre>patcher.start</span></code>.<p class="cyxy-trs-source cyxy-trs-target">如果您使用 patch ()为您创建一个 mock，那么调用 patcher.start 将返回它。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.ClassName'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>package</span> <span class=kn>import</span> <span class=n>module</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>new_mock</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>original</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=n>new_mock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=n>original</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>new_mock</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">A typical use case for this might be for doing multiple patches in the <code class="docutils literal notranslate"><span class=pre>setUp</span></code>
method of a <code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code>:<p class="cyxy-trs-source cyxy-trs-target">一个典型的用例可能是在一个 TestCase 的 setUp 方法中做多个补丁:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher1</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.Class1'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher2</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.Class2'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>MockClass1</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patcher1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>MockClass2</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patcher2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>tearDown</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher1</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher2</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>Class1</span> <span class=ow>is</span> <span class=bp>self</span><span class=o>.</span><span class=n>MockClass1</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>Class2</span> <span class=ow>is</span> <span class=bp>self</span><span class=o>.</span><span class=n>MockClass2</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_something'</span><span class=p>)</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">警告<p class="admonition-title cyxy-trs-source cyxy-trs-target">Warning</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you use this technique you must ensure that the patching is "undone" by
calling <code class="docutils literal notranslate"><span class=pre>stop</span></code>. This can be fiddlier than you might think, because if an
exception is raised in the <code class="docutils literal notranslate"><span class=pre>setUp</span></code> then <code class="docutils literal notranslate"><span class=pre>tearDown</span></code> is not called.
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.html#unittest.TestCase.addCleanup title=unittest.TestCase.addCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>unittest.TestCase.addCleanup()</span></code></a> makes this easier:<p class="cyxy-trs-source cyxy-trs-target">如果使用此技术，则必须通过调用 stop 来确保补丁是“撤消”的。 这可能比您想象的要难，因为如果在安装中引发了异常，那么就不会调用 tearDown。 单位试验。 Addcleanup ()让这个变得更简单:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.Class'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>MockClass</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>addCleanup</span><span class=p>(</span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>Class</span> <span class=ow>is</span> <span class=bp>self</span><span class=o>.</span><span class=n>MockClass</span>
<span class=gp>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">As an added bonus you no longer need to keep a reference to the <code class="docutils literal notranslate"><span class=pre>patcher</span></code>
object.<p class="cyxy-trs-source cyxy-trs-target">作为一个额外的奖励，你不再需要保留一个对修补程序对象的引用。</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">It is also possible to stop all patches which have been started by using
<a class="reference internal" href=#unittest.mock.patch.stopall title=unittest.mock.patch.stopall><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.stopall()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">使用 patch.stopall ()也可以停止所有已经启动的补丁。</p>
<dl class=function>
<dt id=unittest.mock.patch.stopall>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">stopall</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.stopall title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Stop all active patches. Only stops patches started with <code class="docutils literal notranslate"><span class=pre>start</span></code>.<p class="cyxy-trs-source cyxy-trs-target">停止所有活动补丁。只停止开始时开始的补丁。</p>
</dl>
</div>
<div class=section id=patch-builtins>
<span id=id4></span><h3 class=cyxy-trs-source>patch builtins<font class=cyxy-trs-target> 补丁内建物</font><a class=headerlink href=#patch-builtins title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can patch any builtins within a module. The following example patches
builtin <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#ord title=ord><code class="xref py py-func docutils literal notranslate"><span class=pre>ord()</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">你可以在一个模块中修补任何内置的程序:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'__main__.ord'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_ord</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>mock_ord</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=mi>101</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=nb>ord</span><span class=p>(</span><span class=s1>'c'</span><span class=p>))</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=go>101</span>
</pre></div>
</div>
</div>
<div class=section id=test-prefix>
<span id=id5></span><h3 class=cyxy-trs-source>TEST_PREFIX<font class=cyxy-trs-target> 测试前缀</font><a class=headerlink href=#test-prefix title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">All of the patchers can be used as class decorators. When used in this way
they wrap every test method on the class. The patchers recognise methods that
start with <code class="docutils literal notranslate"><span class=pre>'test'</span></code> as being test methods. This is the same way that the
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/unittest.html#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>unittest.TestLoader</span></code></a> finds test methods by default.<p class="cyxy-trs-source cyxy-trs-target">所有的修补程序都可以用作类装饰程序。 当以这种方式使用时，它们将类上的每个测试方法都包装起来。 专利商将以“测试”开头的方法视为测试方法。 这是同样的方式，单位测试。 默认情况下，TestLoader 查找测试方法。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">It is possible that you want to use a different prefix for your tests. You can
inform the patchers of the different prefix by setting <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code>:<p class="cyxy-trs-source cyxy-trs-target">您可能希望为测试使用不同的前缀。 您可以通过设置 patc.test PREFIX 来告知不同前缀的 patchers:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>patch</span><span class=o>.</span><span class=n>TEST_PREFIX</span> <span class=o>=</span> <span class=s1>'foo'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>value</span> <span class=o>=</span> <span class=mi>3</span>
<span class=go>&gt;&gt;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'__main__.value'</span><span class=p>,</span> <span class=s1>'not three'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>class</span> <span class=nc>Thing</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo_one</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo_two</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
<span class=gp>...</span>
<span class=go>&gt;&gt;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Thing</span><span class=p>()</span><span class=o>.</span><span class=n>foo_one</span><span class=p>()</span>
<span class=go>not three</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Thing</span><span class=p>()</span><span class=o>.</span><span class=n>foo_two</span><span class=p>()</span>
<span class=go>not three</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>value</span>
<span class=go>3</span>
</pre></div>
</div>
</div>
<div class=section id=nesting-patch-decorators>
<h3 class=cyxy-trs-source>Nesting Patch Decorators<font class=cyxy-trs-target> 嵌套修补装饰器</font><a class=headerlink href=#nesting-patch-decorators title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you want to perform multiple patches then you can simply stack up the
decorators.<p class="cyxy-trs-source cyxy-trs-target">如果您想执行多个补丁，那么您可以简单地堆叠装饰器。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can stack up multiple patch decorators using this pattern:<p class="cyxy-trs-source cyxy-trs-target">你可以使用这个模式堆叠多个修补程序修饰器:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'class_method'</span><span class=p>)</span>
<span class=gp>... </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'static_method'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock1</span><span class=p>,</span> <span class=n>mock2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>static_method</span> <span class=ow>is</span> <span class=n>mock1</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>class_method</span> <span class=ow>is</span> <span class=n>mock2</span>
<span class=gp>... </span>    <span class=n>SomeClass</span><span class=o>.</span><span class=n>static_method</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>SomeClass</span><span class=o>.</span><span class=n>class_method</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>mock1</span><span class=p>,</span> <span class=n>mock2</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock1</span><span class=p>,</span> <span class=n>mock2</span> <span class=o>=</span> <span class=n>test</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock1</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock2</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Note that the decorators are applied from the bottom upwards. This is the
standard way that Python applies decorators. The order of the created mocks
passed into your test function matches this order.<p class="cyxy-trs-source cyxy-trs-target">注意，decorator 是从底部向上应用的。 这是 Python 应用 decorator 的标准方式。 传递到测试函数中的已创建模拟的顺序与此顺序相匹配。</p>
</div>
<div class=section id=where-to-patch>
<span id=id6></span><h3 class=cyxy-trs-source>Where to patch<font class=cyxy-trs-target> 在哪里修补</font><a class=headerlink href=#where-to-patch title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> works by (temporarily) changing the object that a <em>name</em> points to with
another one. There can be many names pointing to any individual object, so
for patching to work you must ensure that you patch the name used by the system
under test.<p class="cyxy-trs-source cyxy-trs-target">Patch ()通过(暂时)改变一个名称指向另一个名称的对象来工作。 可能有许多名称指向任何单个对象，因此为了进行修补，您必须确保修补被测系统使用的名称。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The basic principle is that you patch where an object is <em>looked up</em>, which
is not necessarily the same place as where it is defined. A couple of
examples will help to clarify this.<p class="cyxy-trs-source cyxy-trs-target">基本原则是，在查找对象的地方进行补丁，这不一定与定义对象的地方相同。 下面的几个例子将有助于阐明这一点。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Imagine we have a project that we want to test with the following structure:<p class="cyxy-trs-source cyxy-trs-target">假设我们有一个项目，我们想用下面的结构进行测试:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>a</span><span class=o>.</span><span class=n>py</span>
    <span class=o>-&gt;</span> <span class=n>Defines</span> <span class=n>SomeClass</span>

<span class=n>b</span><span class=o>.</span><span class=n>py</span>
    <span class=o>-&gt;</span> <span class=kn>from</span> <span class=nn>a</span> <span class=kn>import</span> <span class=n>SomeClass</span>
    <span class=o>-&gt;</span> <span class=n>some_function</span> <span class=n>instantiates</span> <span class=n>SomeClass</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Now we want to test <code class="docutils literal notranslate"><span class=pre>some_function</span></code> but we want to mock out <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> using
<a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>. The problem is that when we import module b, which we will have to
do then it imports <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> from module a. If we use <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> to mock out
<code class="docutils literal notranslate"><span class=pre>a.SomeClass</span></code> then it will have no effect on our test; module b already has a
reference to the <em>real</em> <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> and it looks like our patching had no
effect.<p class="cyxy-trs-source cyxy-trs-target">现在我们想测试一些函数，但是我们想使用 patch ()模拟出 SomeClass。 问题是，当我们导入模块 b 时，我们必须这样做，然后它从模块 a 导入 SomeClass。 如果我们使用 patch ()来模拟 a.SomeClass，那么它对我们的测试没有任何影响; 模块 b 已经引用了真正的 SomeClass，看起来我们的修补没有任何效果。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The key is to patch out <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> where it is used (or where it is looked up).
In this case <code class="docutils literal notranslate"><span class=pre>some_function</span></code> will actually look up <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> in module b,
where we have imported it. The patching should look like:<p class="cyxy-trs-source cyxy-trs-target">关键是在使用它的地方(或查找它的地方)补丁 SomeClass。 在这种情况下，某个函数实际上会在模块 b 中查找 SomeClass，我们已经导入了它。 修补应该是这样的:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'b.SomeClass'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">However, consider the alternative scenario where instead of <code class="docutils literal notranslate"><span class=pre>from</span> <span class=pre>a</span> <span class=pre>import</span>
<span class=pre>SomeClass</span></code> module b does <code class="docutils literal notranslate"><span class=pre>import</span> <span class=pre>a</span></code> and <code class="docutils literal notranslate"><span class=pre>some_function</span></code> uses <code class="docutils literal notranslate"><span class=pre>a.SomeClass</span></code>. Both
of these import forms are common. In this case the class we want to patch is
being looked up in the module and so we have to patch <code class="docutils literal notranslate"><span class=pre>a.SomeClass</span></code> instead:<p class="cyxy-trs-source cyxy-trs-target">但是，考虑另一种情况，即不从 import SomeClass 模块 b 导入 a，而是有些函数使用 a. SomeClass。 这两种导入形式都很常见。 在这种情况下，我们要修补的类正在模块中查找，所以我们必须修补 a.SomeClass:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'a.SomeClass'</span><span class=p>)</span>
</pre></div>
</div>
</div>
<div class=section id=patching-descriptors-and-proxy-objects>
<h3 class=cyxy-trs-source>Patching Descriptors and Proxy Objects<font class=cyxy-trs-target> 修补描述符和代理对象</font><a class=headerlink href=#patching-descriptors-and-proxy-objects title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Both <a class="reference internal" href=#patch>patch</a> and <a class="reference internal" href=#patch-object>patch.object</a> correctly patch and restore descriptors: class
methods, static methods and properties. You should patch these on the <em>class</em>
rather than an instance. They also work with <em>some</em> objects
that proxy attribute access, like the <a class="reference external" href=http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>django settings object</a>.<p class="cyxy-trs-source cyxy-trs-target">补丁和 patc.object 都正确地补丁和恢复描述符: 类方法、静态方法和属性。 您应该在类上而不是在实例上打补丁。 它们还可以处理一些代理属性访问的对象，比如 django 设置对象。</p>
</div>
</div>
<div class=section id=magicmock-and-magic-method-support>
<h2 class=cyxy-trs-source>MagicMock and magic method support<font class=cyxy-trs-target> Magicmock 和 magic 方法支持</font><a class=headerlink href=#magicmock-and-magic-method-support title=永久链接至标题>¶</a></h2>
<div class=section id=mocking-magic-methods>
<span id=magic-methods></span><h3 class=cyxy-trs-source>Mocking Magic Methods<font class=cyxy-trs-target> 嘲笑魔法的方法</font><a class=headerlink href=#mocking-magic-methods title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> supports mocking the Python protocol methods, also known as
"magic methods". This allows mock objects to replace containers or other
objects that implement Python protocols.<p class="cyxy-trs-source cyxy-trs-target">Mock 支持模仿 Python 协议方法，也称为“魔法方法”。 这允许模拟对象替换实现 Python 协议的容器或其他对象。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Because magic methods are looked up differently from normal methods <a class="footnote-reference brackets" href=#id9 id=id7>2</a>, this
support has been specially implemented. This means that only specific magic
methods are supported. The supported list includes <em>almost</em> all of them. If
there are any missing that you need please let us know.<p class="cyxy-trs-source cyxy-trs-target">因为查找魔术方法与查找普通方法2不同，所以特别实现了这种支持。 这意味着只支持特定的魔法方法。 支持的列表几乎包含了所有的列表。 如果您需要什么，请告诉我们。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You mock magic methods by setting the method you are interested in to a function
or a mock instance. If you are using a function then it <em>must</em> take <code class="docutils literal notranslate"><span class=pre>self</span></code> as
the first argument <a class="footnote-reference brackets" href=#id10 id=id8>3</a>.<p class="cyxy-trs-source cyxy-trs-target">您可以通过将感兴趣的方法设置为函数或模拟实例来模拟魔法方法。 如果你使用一个函数，那么它必须以 self 作为第一个参数3。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=s1>'fooble'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span> <span class=o>=</span> <span class=fm>__str__</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'fooble'</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'fooble'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'fooble'</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__iter__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=nb>iter</span><span class=p>([]))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>[]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">One use case for this is for mocking objects used as context managers in a
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/compound_stmts.html#with><code class="xref std std-keyword docutils literal notranslate"><span class=pre>with</span></code></a> statement:<p class="cyxy-trs-source cyxy-trs-target">其中一个用例是在 with 语句中使用 mocking 对象作为上下文管理器:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__enter__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__exit__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>mock</span> <span class=k>as</span> <span class=n>m</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>m</span> <span class=o>==</span> <span class=s1>'foo'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__enter__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__exit__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Calls to magic methods do not appear in <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a>, but they
are recorded in <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">对神奇方法的调用不会出现在方法调用中，但它们会被记录在模拟调用中。</p>
<div class="admonition note">
<p class="admonition-title cyxy-trs-source cyxy-trs-source-ted">注解<p class="admonition-title cyxy-trs-source cyxy-trs-target">Notes</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you use the <em>spec</em> keyword argument to create a mock then attempting to
set a magic method that isn't in the spec will raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">如果您使用 spec 关键字参数创建一个 mock，那么试图设置一个不在 spec 中的魔法方法将引发一个 AttributeError 错误。</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The full list of supported magic methods is:<p class="cyxy-trs-source cyxy-trs-target">支持的魔术方法的完整列表如下:</p>
<ul class=simple>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__hash__</span></code>, <code class="docutils literal notranslate"><span class=pre>__sizeof__</span></code>, <code class="docutils literal notranslate"><span class=pre>__repr__</span></code> and <code class="docutils literal notranslate"><span class=pre>__str__</span></code><p class="cyxy-trs-source cyxy-trs-target">Hash，sizeof，repr 和 str</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__dir__</span></code>, <code class="docutils literal notranslate"><span class=pre>__format__</span></code> and <code class="docutils literal notranslate"><span class=pre>__subclasses__</span></code><p class="cyxy-trs-source cyxy-trs-target">目录，格式和子类</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__round__</span></code>, <code class="docutils literal notranslate"><span class=pre>__floor__</span></code>, <code class="docutils literal notranslate"><span class=pre>__trunc__</span></code> and <code class="docutils literal notranslate"><span class=pre>__ceil__</span></code><p class="cyxy-trs-source cyxy-trs-target">圆形，地板，后备箱和天花板</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Comparisons: <code class="docutils literal notranslate"><span class=pre>__lt__</span></code>, <code class="docutils literal notranslate"><span class=pre>__gt__</span></code>, <code class="docutils literal notranslate"><span class=pre>__le__</span></code>, <code class="docutils literal notranslate"><span class=pre>__ge__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__eq__</span></code> and <code class="docutils literal notranslate"><span class=pre>__ne__</span></code><p class="cyxy-trs-source cyxy-trs-target">比较: lt，gt，le，ge，eq 和 ne</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Container methods: <code class="docutils literal notranslate"><span class=pre>__getitem__</span></code>, <code class="docutils literal notranslate"><span class=pre>__setitem__</span></code>, <code class="docutils literal notranslate"><span class=pre>__delitem__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__contains__</span></code>, <code class="docutils literal notranslate"><span class=pre>__len__</span></code>, <code class="docutils literal notranslate"><span class=pre>__iter__</span></code>, <code class="docutils literal notranslate"><span class=pre>__reversed__</span></code>
and <code class="docutils literal notranslate"><span class=pre>__missing__</span></code><p class="cyxy-trs-source cyxy-trs-target">集装箱方法: 包装箱、箱、箱、箱、箱、箱、箱、箱、箱、箱</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Context manager: <code class="docutils literal notranslate"><span class=pre>__enter__</span></code>, <code class="docutils literal notranslate"><span class=pre>__exit__</span></code>, <code class="docutils literal notranslate"><span class=pre>__aenter__</span></code> and <code class="docutils literal notranslate"><span class=pre>__aexit__</span></code><p class="cyxy-trs-source cyxy-trs-target">上下文管理器: 进入、退出、进入和退出</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Unary numeric methods: <code class="docutils literal notranslate"><span class=pre>__neg__</span></code>, <code class="docutils literal notranslate"><span class=pre>__pos__</span></code> and <code class="docutils literal notranslate"><span class=pre>__invert__</span></code><p class="cyxy-trs-source cyxy-trs-target">一元数值方法: neg、 pos 和 invert</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">The numeric methods (including right hand and in-place variants):
<code class="docutils literal notranslate"><span class=pre>__add__</span></code>, <code class="docutils literal notranslate"><span class=pre>__sub__</span></code>, <code class="docutils literal notranslate"><span class=pre>__mul__</span></code>, <code class="docutils literal notranslate"><span class=pre>__matmul__</span></code>, <code class="docutils literal notranslate"><span class=pre>__div__</span></code>, <code class="docutils literal notranslate"><span class=pre>__truediv__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__floordiv__</span></code>, <code class="docutils literal notranslate"><span class=pre>__mod__</span></code>, <code class="docutils literal notranslate"><span class=pre>__divmod__</span></code>, <code class="docutils literal notranslate"><span class=pre>__lshift__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__rshift__</span></code>, <code class="docutils literal notranslate"><span class=pre>__and__</span></code>, <code class="docutils literal notranslate"><span class=pre>__xor__</span></code>, <code class="docutils literal notranslate"><span class=pre>__or__</span></code>, and <code class="docutils literal notranslate"><span class=pre>__pow__</span></code><p class="cyxy-trs-source cyxy-trs-target">数字方法(包括右手和就地变量) : add、 sub、 mul、 matmul、 div、 truediv、 floordiv、 mod、 divmod、 lshift、 rshift 和、 xor，以及 pow</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Numeric conversion methods: <code class="docutils literal notranslate"><span class=pre>__complex__</span></code>, <code class="docutils literal notranslate"><span class=pre>__int__</span></code>, <code class="docutils literal notranslate"><span class=pre>__float__</span></code>
and <code class="docutils literal notranslate"><span class=pre>__index__</span></code><p class="cyxy-trs-source cyxy-trs-target">数值转换方法: 复杂、整数、浮点数和索引</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Descriptor methods: <code class="docutils literal notranslate"><span class=pre>__get__</span></code>, <code class="docutils literal notranslate"><span class=pre>__set__</span></code> and <code class="docutils literal notranslate"><span class=pre>__delete__</span></code><p class="cyxy-trs-source cyxy-trs-target">描述符方法: get、 set 和 delete</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Pickling: <code class="docutils literal notranslate"><span class=pre>__reduce__</span></code>, <code class="docutils literal notranslate"><span class=pre>__reduce_ex__</span></code>, <code class="docutils literal notranslate"><span class=pre>__getinitargs__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__getnewargs__</span></code>, <code class="docutils literal notranslate"><span class=pre>__getstate__</span></code> and <code class="docutils literal notranslate"><span class=pre>__setstate__</span></code><p class="cyxy-trs-source cyxy-trs-target">酸洗: 减少，减少前期，后期，后期，后期和后期</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">File system path representation: <code class="docutils literal notranslate"><span class=pre>__fspath__</span></code><p class="cyxy-trs-source cyxy-trs-target">文件系统路径表示: fspath</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted">Asynchronous iteration methods: <code class="docutils literal notranslate"><span class=pre>__aiter__</span></code> and <code class="docutils literal notranslate"><span class=pre>__anext__</span></code><p class="cyxy-trs-source cyxy-trs-target">异步迭代方法: aiter 和 anext</p></li>
</ul>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.8 版更改: </span>Added support for <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/os.html#os.PathLike.__fspath__ title=os.PathLike.__fspath__><code class="xref py py-func docutils literal notranslate"><span class=pre>os.PathLike.__fspath__()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Something 3.8 something something: 添加对 os. PathLike. fspath ()的支持。</p>
</div>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.8 版更改: </span>Added support for <code class="docutils literal notranslate"><span class=pre>__aenter__</span></code>, <code class="docutils literal notranslate"><span class=pre>__aexit__</span></code>, <code class="docutils literal notranslate"><span class=pre>__aiter__</span></code> and <code class="docutils literal notranslate"><span class=pre>__anext__</span></code>.<p class="cyxy-trs-source cyxy-trs-target">Something 3.8 something something: 增加了对 aenter，aexit，aiter 和 anext 的支持。</p>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The following methods exist but are <em>not</em> supported as they are either in use
by mock, can't be set dynamically, or can cause problems:<p class="cyxy-trs-source cyxy-trs-target">下面的方法虽然存在，但不受支持，因为它们要么在 mock 中使用，要么不能动态设置，或者可能导致问题:</p>
<ul class=simple>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__getattr__</span></code>, <code class="docutils literal notranslate"><span class=pre>__setattr__</span></code>, <code class="docutils literal notranslate"><span class=pre>__init__</span></code> and <code class="docutils literal notranslate"><span class=pre>__new__</span></code><p class="cyxy-trs-source cyxy-trs-target">Getattr setattr init 和 new</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__prepare__</span></code>, <code class="docutils literal notranslate"><span class=pre>__instancecheck__</span></code>, <code class="docutils literal notranslate"><span class=pre>__subclasscheck__</span></code>, <code class="docutils literal notranslate"><span class=pre>__del__</span></code><p class="cyxy-trs-source cyxy-trs-target">准备，实验，子班检查，戴尔</p></li>
</ul>
</div>
<div class=section id=magic-mock>
<h3 class=cyxy-trs-source>Magic Mock<font class=cyxy-trs-target> 魔术模拟</font><a class=headerlink href=#magic-mock title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">There are two <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> variants: <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> and <a class="reference internal" href=#unittest.mock.NonCallableMagicMock title=unittest.mock.NonCallableMagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMagicMock</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">有两个 MagicMock 变体: MagicMock 和 NonCallableMagicMock。</p>
<dl class=class>
<dt id=unittest.mock.MagicMock>
<em class="property cyxy-trs-source">class <font class=cyxy-trs-target> 类</font></em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">MagicMock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kw<font class=cyxy-trs-target> 我知道</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.MagicMock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> is a subclass of <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> with default implementations
of most of the magic methods. You can use <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> without having to
configure the magic methods yourself.<p class="cyxy-trs-source cyxy-trs-target">Magicmock 是 Mock 的一个子类，具有大多数魔术方法的默认实现。 您可以使用 MagicMock，而无需自己配置魔法方法。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The constructor parameters have the same meaning as for <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">构造函数参数的含义与 Mock 相同。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If you use the <em>spec</em> or <em>spec_set</em> arguments then <em>only</em> magic methods
that exist in the spec will be created.<p class="cyxy-trs-source cyxy-trs-target">如果您使用 spec 或 spec 集参数，那么只创建 spec 中存在的魔法方法。</p>
</dl>
<dl class=class>
<dt id=unittest.mock.NonCallableMagicMock>
<em class="property cyxy-trs-source">class <font class=cyxy-trs-target> 类</font></em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">NonCallableMagicMock</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kw<font class=cyxy-trs-target> 我知道</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.NonCallableMagicMock title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">A non-callable version of <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Magicmock 的非调用版本。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The constructor parameters have the same meaning as for
<a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a>, with the exception of <em>return_value</em> and
<em>side_effect</em> which have no meaning on a non-callable mock.<p class="cyxy-trs-source cyxy-trs-target">构造函数参数的意义与 MagicMock 相同，只是返回值和副作用在不可调用的 mock 上没有意义。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">The magic methods are setup with <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> objects, so you can configure them
and use them in the usual way:<p class="cyxy-trs-source cyxy-trs-target">这些神奇的方法是通过 MagicMock 对象设置的，所以你可以配置它们，并以通常的方式使用它们:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__setitem__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s1>'fish'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__getitem__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'result'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
<span class=go>'result'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">By default many of the protocol methods are required to return objects of a
specific type. These methods are preconfigured with a default return value, so
that they can be used without you having to do anything if you aren't interested
in the return value. You can still <em>set</em> the return value manually if you want
to change the default.<p class="cyxy-trs-source cyxy-trs-target">默认情况下，许多 protocol 方法都需要返回特定类型的对象。 这些方法都预先配置了一个默认的返回值，这样如果您对返回值不感兴趣，就可以不用做任何事情就可以使用它们。 如果您想更改默认值，仍然可以手动设置返回值。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Methods and their defaults:<p class="cyxy-trs-source cyxy-trs-target">方法及其缺省值:</p>
<ul class=simple>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__lt__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code><p class="cyxy-trs-source cyxy-trs-target">上面写着: 没有</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__gt__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code><p class="cyxy-trs-source cyxy-trs-target">没有</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__le__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code><p class="cyxy-trs-source cyxy-trs-target">没有</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__ge__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code><p class="cyxy-trs-source cyxy-trs-target">通用电气: notimpore</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__int__</span></code>: <code class="docutils literal notranslate"><span class=pre>1</span></code><p class="cyxy-trs-source cyxy-trs-target">1</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__contains__</span></code>: <code class="docutils literal notranslate"><span class=pre>False</span></code><p class="cyxy-trs-source cyxy-trs-target">包含: False</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__len__</span></code>: <code class="docutils literal notranslate"><span class=pre>0</span></code><p class="cyxy-trs-source cyxy-trs-target">Len: 0</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__iter__</span></code>: <code class="docutils literal notranslate"><span class=pre>iter([])</span></code><p class="cyxy-trs-source cyxy-trs-target">Iter ([])</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__exit__</span></code>: <code class="docutils literal notranslate"><span class=pre>False</span></code><p class="cyxy-trs-source cyxy-trs-target">退出: False</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__aexit__</span></code>: <code class="docutils literal notranslate"><span class=pre>False</span></code><p class="cyxy-trs-source cyxy-trs-target">出口: 错</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__complex__</span></code>: <code class="docutils literal notranslate"><span class=pre>1j</span></code><p class="cyxy-trs-source cyxy-trs-target">复数: 1j</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__float__</span></code>: <code class="docutils literal notranslate"><span class=pre>1.0</span></code><p class="cyxy-trs-source cyxy-trs-target">1.0</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__bool__</span></code>: <code class="docutils literal notranslate"><span class=pre>True</span></code><p class="cyxy-trs-source cyxy-trs-target">布尔: 没错</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__index__</span></code>: <code class="docutils literal notranslate"><span class=pre>1</span></code><p class="cyxy-trs-source cyxy-trs-target">索引: 1</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__hash__</span></code>: default hash for the mock<p class="cyxy-trs-source cyxy-trs-target">Hash: mock 的默认散列</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__str__</span></code>: default str for the mock<p class="cyxy-trs-source cyxy-trs-target">模拟的默认 str</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__sizeof__</span></code>: default sizeof for the mock<p class="cyxy-trs-source cyxy-trs-target">Sizeof: mock 的默认 sizeof</p></li>
</ul>
<p class="cyxy-trs-source cyxy-trs-source-ted">例如:<p class="cyxy-trs-source cyxy-trs-target">For example:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>int</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>len</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>0</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>[]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>object</span><span class=p>()</span> <span class=ow>in</span> <span class=n>mock</span>
<span class=go>False</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The two equality methods, <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__eq__ title=object.__eq__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__eq__()</span></code></a> and <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__ne__ title=object.__ne__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__ne__()</span></code></a>, are special.
They do the default equality comparison on identity, using the
<a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> attribute, unless you change their return value to
return something else:<p class="cyxy-trs-source cyxy-trs-target">两种等式方法 eq ()和 ne ()是特殊的。 它们使用 side effect 属性对 identity 进行默认的相等比较，除非您更改它们的返回值以返回其他内容:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>MagicMock</span><span class=p>()</span> <span class=o>==</span> <span class=mi>3</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MagicMock</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>3</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__eq__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=kc>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>==</span> <span class=mi>3</span>
<span class=go>True</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The return value of <code class="xref py py-meth docutils literal notranslate"><span class=pre>MagicMock.__iter__()</span></code> can be any iterable object and isn't
required to be an iterator:<p class="cyxy-trs-source cyxy-trs-target">返回值 MagicMock. iter ()可以是任何可迭代的对象，不需要是迭代器:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__iter__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=p>[</span><span class=s1>'a'</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>['a', 'b', 'c']</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>['a', 'b', 'c']</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If the return value <em>is</em> an iterator, then iterating over it once will consume
it and subsequent iterations will result in an empty list:<p class="cyxy-trs-source cyxy-trs-target">如果返回值是一个迭代器，那么对它进行一次迭代将消耗它，随后的迭代将导致一个空列表:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__iter__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=nb>iter</span><span class=p>([</span><span class=s1>'a'</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>['a', 'b', 'c']</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>[]</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> has all of the supported magic methods configured except for some
of the obscure and obsolete ones. You can still set these up if you want.<p class="cyxy-trs-source cyxy-trs-target">Magicmock 配置了所有支持的魔法方法，除了一些晦涩和过时的方法。 你仍然可以设置这些，如果你想。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Magic methods that are supported but not setup by default in <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> are:<p class="cyxy-trs-source cyxy-trs-target">在 MagicMock 中支持但不默认设置的魔法方法是:</p>
<ul class=simple>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__subclasses__</span></code><p class="cyxy-trs-source cyxy-trs-target">亚纲</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__dir__</span></code><p class="cyxy-trs-source cyxy-trs-target">目录</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__format__</span></code><p class="cyxy-trs-source cyxy-trs-target">格式</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__get__</span></code>, <code class="docutils literal notranslate"><span class=pre>__set__</span></code> and <code class="docutils literal notranslate"><span class=pre>__delete__</span></code><p class="cyxy-trs-source cyxy-trs-target">获取，设置和删除</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__reversed__</span></code> and <code class="docutils literal notranslate"><span class=pre>__missing__</span></code><p class="cyxy-trs-source cyxy-trs-target">反过来丢了</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__reduce__</span></code>, <code class="docutils literal notranslate"><span class=pre>__reduce_ex__</span></code>, <code class="docutils literal notranslate"><span class=pre>__getinitargs__</span></code>, <code class="docutils literal notranslate"><span class=pre>__getnewargs__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__getstate__</span></code> and <code class="docutils literal notranslate"><span class=pre>__setstate__</span></code><p class="cyxy-trs-source cyxy-trs-target">减少，减少前，getitargs，getnewargs，getstate 和 setstate</p></li>
<li><p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>__getformat__</span></code> and <code class="docutils literal notranslate"><span class=pre>__setformat__</span></code><p class="cyxy-trs-source cyxy-trs-target">Getformat 和 setformat</p></li>
</ul>
<dl class="footnote brackets">
<dt class=label id=id9><span class=brackets><a class=fn-backref href=#id7>2</a></span></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Magic methods <em>should</em> be looked up on the class rather than the
instance. Different versions of Python are inconsistent about applying this
rule. The supported protocol methods should work with all supported versions
of Python.<p class="cyxy-trs-source cyxy-trs-target">应该在类而不是实例上查找魔法方法。 不同版本的 Python 在应用此规则时不一致。 支持的协议方法应该适用于所有支持的 Python 版本。</p>
</dd>
<dt class=label id=id10><span class=brackets><a class=fn-backref href=#id8>3</a></span></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">The function is basically hooked up to the class, but each <code class="docutils literal notranslate"><span class=pre>Mock</span></code>
instance is kept isolated from the others.<p class="cyxy-trs-source cyxy-trs-target">该函数基本上与类挂钩，但是每个 Mock 实例都与其他实例保持隔离。</p>
</dd>
</dl>
</div>
</div>
<div class=section id=helpers>
<h2 class=cyxy-trs-source>Helpers<font class=cyxy-trs-target> 助手</font><a class=headerlink href=#helpers title=永久链接至标题>¶</a></h2>
<div class=section id=sentinel>
<h3 class=cyxy-trs-source>sentinel<font class=cyxy-trs-target> 哨兵</font><a class=headerlink href=#sentinel title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.sentinel>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">sentinel</code><a class=headerlink href=#unittest.mock.sentinel title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">The <code class="docutils literal notranslate"><span class=pre>sentinel</span></code> object provides a convenient way of providing unique
objects for your tests.<p class="cyxy-trs-source cyxy-trs-target">哨兵对象提供了一种为您的测试提供唯一对象的方便方法。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Attributes are created on demand when you access them by name. Accessing
the same attribute will always return the same object. The objects
returned have a sensible repr so that test failure messages are readable.<p class="cyxy-trs-source cyxy-trs-target">当您通过名称访问属性时，可以根据需要创建属性。 访问相同的属性将总是返回相同的对象。 返回的对象具有一个合理的 repr，这样测试失败消息就可以被读取。</p>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.7 版更改: </span>The <code class="docutils literal notranslate"><span class=pre>sentinel</span></code> attributes now preserve their identity when they are
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/copy.html#module-copy title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class=pre>copied</span></code></a> or <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/pickle.html#module-pickle title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class=pre>pickled</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Something 3.7 something something something: 哨兵属性现在保存他们的身份，当他们被复制或腌制。</p>
</div>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes when testing you need to test that a specific object is passed as an
argument to another method, or returned. It can be common to create named
sentinel objects to test this. <a class="reference internal" href=#unittest.mock.sentinel title=unittest.mock.sentinel><code class="xref py py-data docutils literal notranslate"><span class=pre>sentinel</span></code></a> provides a convenient way of
creating and testing the identity of objects like this.<p class="cyxy-trs-source cyxy-trs-target">有时，在测试时需要测试特定对象是否作为参数传递给另一个方法，或者是否返回。 通常可以创建命名的哨兵对象来测试这一点。 Sentinel 提供了一种方便的方法来创建和测试这样的对象的身份。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">In this example we monkey patch <code class="docutils literal notranslate"><span class=pre>method</span></code> to return <code class="docutils literal notranslate"><span class=pre>sentinel.some_object</span></code>:<p class="cyxy-trs-source cyxy-trs-target">在这个例子中，我们使用 monkey patch 方法返回 sentinel.some 对象:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>real</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"method"</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>some_object</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span> <span class=o>=</span> <span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>result</span> <span class=ow>is</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>some_object</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>sentinel</span><span class=o>.</span><span class=n>some_object</span>
<span class=go>sentinel.some_object</span>
</pre></div>
</div>
</div>
<div class=section id=default>
<h3 class=cyxy-trs-source>DEFAULT<font class=cyxy-trs-target> 默认</font><a class=headerlink href=#default title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.DEFAULT>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">DEFAULT</code><a class=headerlink href=#unittest.mock.DEFAULT title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">The <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> object is a pre-created sentinel (actually
<code class="docutils literal notranslate"><span class=pre>sentinel.DEFAULT</span></code>). It can be used by <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a>
functions to indicate that the normal return value should be used.<p class="cyxy-trs-source cyxy-trs-target">Default 对象是预先创建的哨兵(实际上是 sentinel.DEFAULT)。 它可以被副作用函数用来指示应该使用正常的返回值。</p>
</dl>
</div>
<div class=section id=call>
<h3 class=cyxy-trs-source>call<font class=cyxy-trs-target> 呼叫</font><a class=headerlink href=#call title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.call>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">call</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">*args<font class=cyxy-trs-target> * args</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.call title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-func docutils literal notranslate"><span class=pre>call()</span></code></a> is a helper object for making simpler assertions, for comparing with
<a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a>, <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a>,
<a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a>. <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-func docutils literal notranslate"><span class=pre>call()</span></code></a> can also be
used with <a class="reference internal" href=#unittest.mock.Mock.assert_has_calls title=unittest.mock.Mock.assert_has_calls><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_has_calls()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">Call ()是一个帮助器对象，用于进行更简单的断言，用于与调用 args、调用 args 列表、模拟调用和方法调用进行比较。 Call ()也可以与 assert has calls ()一起使用。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>a</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>call_args_list</span> <span class=o>==</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>a</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>),</span> <span class=n>call</span><span class=p>()]</span>
<span class=go>True</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.call.call_list>
<code class="sig-prename descclassname">call.</code><code class="sig-name descname">call_list</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.call.call_list title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">For a call object that represents multiple calls, <a class="reference internal" href=#unittest.mock.call.call_list title=unittest.mock.call.call_list><code class="xref py py-meth docutils literal notranslate"><span class=pre>call_list()</span></code></a>
returns a list of all the intermediate calls as well as the
final call.<p class="cyxy-trs-source cyxy-trs-target">对于表示多个调用的调用对象，调用 list ()返回所有中间调用以及最终调用的列表。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="docutils literal notranslate"><span class=pre>call_list</span></code> is particularly useful for making assertions on "chained calls". A
chained call is multiple calls on a single line of code. This results in
multiple entries in <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> on a mock. Manually constructing
the sequence of calls can be tedious.<p class="cyxy-trs-source cyxy-trs-target">呼叫清单对于在「连锁呼叫」上作出断言特别有用。 链式调用是在一行代码上的多个调用。 这将导致 mock 上的 mock 调用中出现多个条目。 手动构造调用序列可能非常繁琐。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.call.call_list title=unittest.mock.call.call_list><code class="xref py py-meth docutils literal notranslate"><span class=pre>call_list()</span></code></a> can construct the sequence of calls from the same
chained call:<p class="cyxy-trs-source cyxy-trs-target">调用列表()可以构造同一个链式调用的调用序列:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=n>arg</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span><span class=o>.</span><span class=n>other</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)(</span><span class=mf>2.0</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock().method().other()()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span> <span class=o>=</span> <span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=n>arg</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span><span class=o>.</span><span class=n>other</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)(</span><span class=mf>2.0</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=go>[call(1),</span>
<span class=go> call().method(arg='foo'),</span>
<span class=go> call().method().other('bar'),</span>
<span class=go> call().method().other()(2.0)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>kall</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
<p id=calls-as-tuples class="cyxy-trs-source cyxy-trs-source-ted">A <code class="docutils literal notranslate"><span class=pre>call</span></code> object is either a tuple of (positional args, keyword args) or
(name, positional args, keyword args) depending on how it was constructed. When
you construct them yourself this isn't particularly interesting, but the <code class="docutils literal notranslate"><span class=pre>call</span></code>
objects that are in the <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args</span></code></a>, <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args_list</span></code></a> and
<a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.mock_calls</span></code></a> attributes can be introspected to get at the individual
arguments they contain.<p id=calls-as-tuples class="cyxy-trs-source cyxy-trs-target">调用对象可以是元组(位置参数、关键字参数) ，也可以是元组(名称、位置参数、关键字参数) ，这取决于它是如何构造的。 当您自己构造它们时，这并不特别有趣，但是 Mock.call args，Mock.call args list and Mock.mock calls 属性可以自省以获得它们包含的单个参数。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <code class="docutils literal notranslate"><span class=pre>call</span></code> objects in <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args</span></code></a> and <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args_list</span></code></a>
are two-tuples of (positional args, keyword args) whereas the <code class="docutils literal notranslate"><span class=pre>call</span></code> objects
in <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.mock_calls</span></code></a>, along with ones you construct yourself, are
three-tuples of (name, positional args, keyword args).<p class="cyxy-trs-source cyxy-trs-target">在 Mock.call args 和 Mock.call args list 中的调用对象是(positional args，keyword args)的两个元组，而 Mock.mock 调用和您自己构建的调用对象是(name，positional args，keyword args)的三个元组。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can use their "tupleness" to pull out the individual arguments for more
complex introspection and assertions. The positional arguments are a tuple
(an empty tuple if there are no positional arguments) and the keyword
arguments are a dictionary:<p class="cyxy-trs-source cyxy-trs-target">您可以使用它们的“ tupleeness”提取单个参数，以进行更复杂的内省和断言。 位置参数是一个元组(如果没有位置参数则为空元组) ，关键字参数是一个字典:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'one'</span><span class=p>,</span> <span class=n>arg2</span><span class=o>=</span><span class=s1>'two'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>call_args</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>args</span>
<span class=go>(1, 2, 3)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>kwargs</span>
<span class=go>{'arg': 'one', 'arg2': 'two'}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>args</span> <span class=ow>is</span> <span class=n>kall</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>kwargs</span> <span class=ow>is</span> <span class=n>kall</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
<span class=go>True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>foo</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'two'</span><span class=p>,</span> <span class=n>arg2</span><span class=o>=</span><span class=s1>'three'</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock.foo()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>kwargs</span> <span class=o>=</span> <span class=n>kall</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span>
<span class=go>'foo'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>args</span>
<span class=go>(4, 5, 6)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kwargs</span>
<span class=go>{'arg': 'two', 'arg2': 'three'}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span> <span class=ow>is</span> <span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
<div class=section id=create-autospec>
<h3 class=cyxy-trs-source>create_autospec<font class=cyxy-trs-target> 创建 autospec</font><a class=headerlink href=#create-autospec title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.create_autospec>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">create_autospec</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">spec<font class=cyxy-trs-target> 规格</font></em>, <em class="sig-param cyxy-trs-source">spec_set=False<font class=cyxy-trs-target> 规格设置为 False</font></em>, <em class="sig-param cyxy-trs-source">instance=False<font class=cyxy-trs-target> 例如 False</font></em>, <em class="sig-param cyxy-trs-source">**kwargs<font class=cyxy-trs-target> 我们要找的是 kwargs</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.create_autospec title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Create a mock object using another object as a spec. Attributes on the
mock will use the corresponding attribute on the <em>spec</em> object as their
spec.<p class="cyxy-trs-source cyxy-trs-target">使用另一个对象作为 spec 创建一个模拟对象。 Mock 上的属性将使用 spec 对象上的相应属性作为它们的 spec。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Functions or methods being mocked will have their arguments checked to
ensure that they are called with the correct signature.<p class="cyxy-trs-source cyxy-trs-target">被嘲笑的函数或方法将检查它们的参数，以确保使用正确的签名调用它们。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If <em>spec_set</em> is <code class="docutils literal notranslate"><span class=pre>True</span></code> then attempting to set attributes that don't exist
on the spec object will raise an <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">如果 spec set 为 True，那么试图设置 spec 对象上不存在的属性将引发 AttributeError。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If a class is used as a spec then the return value of the mock (the
instance of the class) will have the same spec. You can use a class as the
spec for an instance object by passing <code class="docutils literal notranslate"><span class=pre>instance=True</span></code>. The returned mock
will only be callable if instances of the mock are callable.<p class="cyxy-trs-source cyxy-trs-target">如果一个类被用作 spec，那么模拟(类的实例)的返回值将具有相同的 spec。 您可以通过传递实例 True 来使用类作为实例对象的 spec。 只有在 mock 的实例可调用时，才能调用返回的 mock。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> also takes arbitrary keyword arguments that are passed to
the constructor of the created mock.<p class="cyxy-trs-source cyxy-trs-target">Create autospec ()还接受传递给已创建模拟的构造函数的任意关键字参数。</p>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">See <a class="reference internal" href=#auto-speccing><span class="std std-ref">Autospeccing</span></a> for examples of how to use auto-speccing with
<a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> and the <em>autospec</em> argument to <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">有关如何使用自动投射和创建 autospec ()以及 autospec 参数对 patch ()进行修补的示例，请参见 Autospeccing。</p>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> now returns an <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> if the target is
an async function.<p class="cyxy-trs-source cyxy-trs-target">如果目标是一个异步函数，那么 create autospec ()现在返回一个 AsyncMock。</p>
</div>
</div>
<div class=section id=any>
<h3 class=cyxy-trs-source>ANY<font class=cyxy-trs-target> 任何</font><a class=headerlink href=#any title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.ANY>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">ANY</code><a class=headerlink href=#unittest.mock.ANY title=永久链接至目标>¶</a></dt>
<dd></dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">Sometimes you may need to make assertions about <em>some</em> of the arguments in a
call to mock, but either not care about some of the arguments or want to pull
them individually out of <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a> and make more complex
assertions on them.<p class="cyxy-trs-source cyxy-trs-target">有时候，您可能需要在 mock 调用中对某些参数进行断言，但是要么不关心某些参数，要么希望从 args 调用中单独抽出这些参数，并对它们进行更复杂的断言。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">To ignore certain arguments you can pass in objects that compare equal to
<em>everything</em>. Calls to <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> and
<a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> will then succeed no matter what was
passed in.<p class="cyxy-trs-source cyxy-trs-target">若要忽略某些参数，可以传入与所有参数都相等的对象。 调用 assert 调用 with ()和 assert 调用一次 assert 调用 with ()就会成功，不管传入的是什么。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=nb>object</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=n>ANY</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.ANY title=unittest.mock.ANY><code class="xref py py-data docutils literal notranslate"><span class=pre>ANY</span></code></a> can also be used in comparisons with call lists like
<a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">Any 还可以用于与模拟调用之类的调用列表进行比较:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=nb>object</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=n>ANY</span><span class=p>]</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
<div class=section id=filter-dir>
<h3 class=cyxy-trs-source>FILTER_DIR<font class=cyxy-trs-target> 滤波器目录</font><a class=headerlink href=#filter-dir title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.FILTER_DIR>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">FILTER_DIR</code><a class=headerlink href=#unittest.mock.FILTER_DIR title=永久链接至目标>¶</a></dt>
<dd></dl>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.FILTER_DIR title=unittest.mock.FILTER_DIR><code class="xref py py-data docutils literal notranslate"><span class=pre>FILTER_DIR</span></code></a> is a module level variable that controls the way mock objects
respond to <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#dir title=dir><code class="xref py py-func docutils literal notranslate"><span class=pre>dir()</span></code></a> (only for Python 2.6 or more recent). The default is <code class="docutils literal notranslate"><span class=pre>True</span></code>,
which uses the filtering described below, to only show useful members. If you
dislike this filtering, or need to switch it off for diagnostic purposes, then
set <code class="docutils literal notranslate"><span class=pre>mock.FILTER_DIR</span> <span class=pre>=</span> <span class=pre>False</span></code>.<p class="cyxy-trs-source cyxy-trs-target">Filter dir 是一个模块级变量，用于控制模拟对象响应 dir ()的方式(仅适用于 Python 2.6或更新的版本)。 默认值为 True，它使用下面描述的过滤，只显示有用的成员。 如果您不喜欢这个过滤，或者为了诊断目的需要关闭它，那么设置 mock.FILTER DIR 为 False。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">With filtering on, <code class="docutils literal notranslate"><span class=pre>dir(some_mock)</span></code> shows only useful attributes and will
include any dynamically created attributes that wouldn't normally be shown.
If the mock was created with a <em>spec</em> (or <em>autospec</em> of course) then all the
attributes from the original are shown, even if they haven't been accessed
yet:<p class="cyxy-trs-source cyxy-trs-target">启用过滤后，dir (一些 mock)只显示有用的属性，并且包含通常不会显示的动态创建的属性。 如果 mock 是用 spec (当然是 autospec)创建的，那么原始文件中的所有属性都会显示出来，即使它们还没有被访问:</p>
<div class="highlight-pycon3 notranslate"><div class=highlight><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nb>dir</span><span class=p>(</span><span class=n>Mock</span><span class=p>())</span>
<span class=go>['assert_any_call',</span>
<span class=go> 'assert_called',</span>
<span class=go> 'assert_called_once',</span>
<span class=go> 'assert_called_once_with',</span>
<span class=go> 'assert_called_with',</span>
<span class=go> 'assert_has_calls',</span>
<span class=go> 'assert_not_called',</span>
<span class=go> 'attach_mock',</span>
<span class=go> ...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>dir</span><span class=p>(</span><span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>request</span><span class=p>))</span>
<span class=go>['AbstractBasicAuthHandler',</span>
<span class=go> 'AbstractDigestAuthHandler',</span>
<span class=go> 'AbstractHTTPHandler',</span>
<span class=go> 'BaseHandler',</span>
<span class=go> ...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Many of the not-very-useful (private to <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> rather than the thing being
mocked) underscore and double underscore prefixed attributes have been
filtered from the result of calling <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#dir title=dir><code class="xref py py-func docutils literal notranslate"><span class=pre>dir()</span></code></a> on a <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>. If you dislike this
behaviour you can switch it off by setting the module level switch
<a class="reference internal" href=#unittest.mock.FILTER_DIR title=unittest.mock.FILTER_DIR><code class="xref py py-data docutils literal notranslate"><span class=pre>FILTER_DIR</span></code></a>:<p class="cyxy-trs-source cyxy-trs-target">在 Mock 上调用 dir ()的结果中筛选了许多不太有用的(私有到 Mock 而不是被嘲弄的东西)下划线和双下划线前缀属性。 如果你不喜欢这种行为，你可以通过设置模块级开关 FILTER dir 来关闭它:</p>
<div class="highlight-pycon3 notranslate"><div class=highlight><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest</span> <span class=kn>import</span> <span class=n>mock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>FILTER_DIR</span> <span class=o>=</span> <span class=kc>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>dir</span><span class=p>(</span><span class=n>mock</span><span class=o>.</span><span class=n>Mock</span><span class=p>())</span>
<span class=go>['_NonCallableMock__get_return_value',</span>
<span class=go> '_NonCallableMock__get_side_effect',</span>
<span class=go> '_NonCallableMock__return_value_doc',</span>
<span class=go> '_NonCallableMock__set_return_value',</span>
<span class=go> '_NonCallableMock__set_side_effect',</span>
<span class=go> '__call__',</span>
<span class=go> '__class__',</span>
<span class=go> ...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Alternatively you can just use <code class="docutils literal notranslate"><span class=pre>vars(my_mock)</span></code> (instance members) and
<code class="docutils literal notranslate"><span class=pre>dir(type(my_mock))</span></code> (type members) to bypass the filtering irrespective of
<code class="xref py py-data docutils literal notranslate"><span class=pre>mock.FILTER_DIR</span></code>.<p class="cyxy-trs-source cyxy-trs-target">或者，您可以只使用 vars (my mock)(实例成员)和 DIR (类型(my mock))(类型成员)来绕过筛选，而与 mock.FILTER DIR 无关。</p>
</div>
<div class=section id=mock-open>
<h3 class=cyxy-trs-source>mock_open<font class=cyxy-trs-target> 模拟开启</font><a class=headerlink href=#mock-open title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.mock_open>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">mock_open</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">mock=None<font class=cyxy-trs-target> 嘲笑没有</font></em>, <em class="sig-param cyxy-trs-source">read_data=None<font class=cyxy-trs-target> 读取数据</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.mock_open title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">A helper function to create a mock to replace the use of <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a>. It works
for <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> called directly or used as a context manager.<p class="cyxy-trs-source cyxy-trs-target">一个 helper 函数，用于创建一个 mock 来替换 open ()的使用。 它适用于直接调用或用作上下文管理器的 open ()。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The <em>mock</em> argument is the mock object to configure. If <code class="docutils literal notranslate"><span class=pre>None</span></code> (the
default) then a <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> will be created for you, with the API limited
to methods or attributes available on standard file handles.<p class="cyxy-trs-source cyxy-trs-target">Mock 参数是要配置的模拟对象。 如果 None (默认值) ，那么将为您创建 MagicMock，其 API 仅限于标准文件句柄上可用的方法或属性。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><em>read_data</em> is a string for the <code class="xref py py-meth docutils literal notranslate"><span class=pre>read()</span></code>,
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/io.html#io.IOBase.readline title=io.IOBase.readline><code class="xref py py-meth docutils literal notranslate"><span class=pre>readline()</span></code></a>, and <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/io.html#io.IOBase.readlines title=io.IOBase.readlines><code class="xref py py-meth docutils literal notranslate"><span class=pre>readlines()</span></code></a> methods
of the file handle to return. Calls to those methods will take data from
<em>read_data</em> until it is depleted. The mock of these methods is pretty
simplistic: every time the <em>mock</em> is called, the <em>read_data</em> is rewound to
the start. If you need more control over the data that you are feeding to
the tested code you will need to customize this mock for yourself. When that
is insufficient, one of the in-memory filesystem packages on <a class="reference external" href=https://pypi.org/>PyPI</a> can offer a realistic filesystem for testing.<p class="cyxy-trs-source cyxy-trs-target">Read data 是要返回的文件句柄的 read ()、 readline ()和 readlines ()方法的字符串。 对这些方法的调用将从已读数据中获取数据，直到数据耗尽。 这些方法的 mock 非常简单: 每次调用 mock 时，读取的数据都会重新绕回到开始。 如果您需要对提供给测试代码的数据进行更多的控制，则需要为自己定制这个模拟。 当这还不够的时候，PyPI 上的一个内存中文件系统包可以提供一个实际的文件系统供测试。</p>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.4 版更改: </span>Added <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/io.html#io.IOBase.readline title=io.IOBase.readline><code class="xref py py-meth docutils literal notranslate"><span class=pre>readline()</span></code></a> and <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/io.html#io.IOBase.readlines title=io.IOBase.readlines><code class="xref py py-meth docutils literal notranslate"><span class=pre>readlines()</span></code></a> support.
The mock of <code class="xref py py-meth docutils literal notranslate"><span class=pre>read()</span></code> changed to consume <em>read_data</em> rather
than returning it on each call.<p class="cyxy-trs-source cyxy-trs-target">Something 3.4 something something: 增加了 readline ()和 readlines ()支持。 Read ()的模拟更改为使用已读数据，而不是在每次调用时返回数据。</p>
</div>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.5 版更改: </span><em>read_data</em> is now reset on each call to the <em>mock</em>.<p class="cyxy-trs-source cyxy-trs-target">3.5 something something: 读取数据现在在每次调用 mock 时重置。</p>
</div>
<div class=versionchanged>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified changed">在 3.8 版更改: </span>Added <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__iter__ title=object.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a> to implementation so that iteration (such as in for
loops) correctly consumes <em>read_data</em>.<p class="cyxy-trs-source cyxy-trs-target">Something 3.8 something something: 在实现中添加 iter () ，以便迭代(例如 in for 循环)正确地消耗读取的数据。</p>
</div>
</dl>
<p class="cyxy-trs-source cyxy-trs-source-ted">Using <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> as a context manager is a great way to ensure your file handles
are closed properly and is becoming common:<p class="cyxy-trs-source cyxy-trs-target">使用 open ()作为上下文管理器是确保正确关闭文件句柄的一个很好的方法，并且越来越普遍:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'/some/path'</span><span class=p>,</span> <span class=s1>'w'</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>'something'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The issue is that even if you mock out the call to <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> it is the
<em>returned object</em> that is used as a context manager (and has <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__enter__ title=object.__enter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__enter__()</span></code></a> and
<a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__exit__ title=object.__exit__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__exit__()</span></code></a> called).<p class="cyxy-trs-source cyxy-trs-target">问题在于，即使您模拟调用 open () ，返回的对象也被用作上下文管理器(并且调用了 enter ()和 exit ())。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Mocking context managers with a <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> is common enough and fiddly
enough that a helper function is useful.<p class="cyxy-trs-source cyxy-trs-target">使用 MagicMock 来模拟上下文管理器是很常见的，而且非常复杂，因此助手函数非常有用。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>mock_open</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.open'</span><span class=p>,</span> <span class=n>m</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=s1>'w'</span><span class=p>)</span> <span class=k>as</span> <span class=n>h</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>h</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>'some stuff'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call('foo', 'w'),</span>
<span class=go> call().__enter__(),</span>
<span class=go> call().write('some stuff'),</span>
<span class=go> call().__exit__(None, None, None)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=s1>'w'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>handle</span> <span class=o>=</span> <span class=n>m</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>handle</span><span class=o>.</span><span class=n>write</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'some stuff'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">And for reading files:<p class="cyxy-trs-source cyxy-trs-target">读取文件:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.open'</span><span class=p>,</span> <span class=n>mock_open</span><span class=p>(</span><span class=n>read_data</span><span class=o>=</span><span class=s1>'bibble'</span><span class=p>))</span> <span class=k>as</span> <span class=n>m</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span> <span class=k>as</span> <span class=n>h</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>result</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>result</span> <span class=o>==</span> <span class=s1>'bibble'</span>
</pre></div>
</div>
</div>
<div class=section id=autospeccing>
<span id=auto-speccing></span><h3 class=cyxy-trs-source>Autospeccing<font class=cyxy-trs-target> 自动投影</font><a class=headerlink href=#autospeccing title=永久链接至标题>¶</a></h3>
<p class="cyxy-trs-source cyxy-trs-source-ted">Autospeccing is based on the existing <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> feature of mock. It limits the
api of mocks to the api of an original object (the spec), but it is recursive
(implemented lazily) so that attributes of mocks only have the same api as
the attributes of the spec. In addition mocked functions / methods have the
same call signature as the original so they raise a <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/exceptions.html#TypeError title=TypeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>TypeError</span></code></a> if they are
called incorrectly.<p class="cyxy-trs-source cyxy-trs-target">自动投影是基于 mock 现有的规格特性。 它将 mock 的 api 限制为原始对象(spec)的 api，但是它是递归的(惰性实现的) ，因此 mock 的属性只有与 spec 的属性相同的 api。 此外，嘲弄函数 / 方法与原始函数 / 方法具有相同的调用签名，因此如果调用不正确，它们将引发 TypeError。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Before I explain how auto-speccing works, here's why it is needed.<p class="cyxy-trs-source cyxy-trs-target">在我解释自动喷涂是如何工作的之前，我先说明一下为什么需要这样做。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> is a very powerful and flexible object, but it suffers from two flaws
when used to mock out objects from a system under test. One of these flaws is
specific to the <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> api and the other is a more general problem with using
mock objects.<p class="cyxy-trs-source cyxy-trs-target">Mock 是一个非常强大和灵活的对象，但是在用于模拟测试系统中的对象时，它有两个缺陷。 其中一个缺陷是针对 Mock api 的，另一个缺陷是使用 Mock 对象时的一个更一般的问题。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">First the problem specific to <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a>. <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> has two assert methods that are
extremely handy: <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> and
<a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a>.<p class="cyxy-trs-source cyxy-trs-target">首先，Mock 特有的问题有两个非常方便的断言方法: assert 与()一起调用，assert 与()一起调用。</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'Thing'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'mock' to be called once. Called 2 times.</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Because mocks auto-create attributes on demand, and allow you to call them
with arbitrary arguments, if you misspell one of these assert methods then
your assertion is gone:<p class="cyxy-trs-source cyxy-trs-target">因为模拟程序可以根据需要自动创建属性，并允许您使用任意参数调用它们，所以如果拼错了其中一个 assert 方法，那么断言就消失了:</p>
<div class="highlight-pycon notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'Thing'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assret_called_once_with</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Your tests can pass silently and incorrectly because of the typo.<p class="cyxy-trs-source cyxy-trs-target">由于输入错误，您的测试可以无声地和不正确地通过。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">The second issue is more general to mocking. If you refactor some of your
code, rename members and so on, any tests for code that is still using the
<em>old api</em> but uses mocks instead of the real objects will still pass. This
means your tests can all pass even though your code is broken.<p class="cyxy-trs-source cyxy-trs-target">第二个问题更笼统地说是嘲弄。 如果您重构一些代码、重命名成员等等，那么仍在使用旧 api 但使用模拟而不是真正的对象的任何代码测试仍将通过。 这意味着即使代码中断，测试也可以全部通过。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Note that this is another reason why you need integration tests as well as
unit tests. Testing everything in isolation is all fine and dandy, but if you
don't test how your units are "wired together" there is still lots of room
for bugs that tests might have caught.<p class="cyxy-trs-source cyxy-trs-target">请注意，这是您需要集成测试和单元测试的另一个原因。 单独测试一切都很好，但是如果你不测试你的单元是如何“连接在一起”的，那么仍然有很多测试可能抓住的 bug 的空间。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="xref py py-mod docutils literal notranslate"><span class=pre>mock</span></code> already provides a feature to help with this, called speccing. If you
use a class or instance as the <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> for a mock then you can only access
attributes on the mock that exist on the real class:<p class="cyxy-trs-source cyxy-trs-target">Mock 已经提供了一个特性来帮助解决这个问题，叫做 speccing。 如果你使用类或者实例作为 mock 的规范，那么你只能访问实际类中存在的 mock 上的属性:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>request</span><span class=o>.</span><span class=n>Request</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assret_called_with</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'assret_called_with'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The spec only applies to the mock itself, so we still have the same issue
with any methods on the mock:<p class="cyxy-trs-source cyxy-trs-target">这个规范只适用于 mock 本身，所以对于 mock 上的任何方法，我们仍然存在同样的问题:</p>
<div class="highlight-pycon notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>has_data</span><span class=p>()</span>
<span class=go>&lt;mock.Mock object at 0x...&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>has_data</span><span class=o>.</span><span class=n>assret_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Auto-speccing solves this problem. You can either pass <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> to
<a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> / <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> or use the <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> function to create a
mock with a spec. If you use the <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> argument to <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> then the
object that is being replaced will be used as the spec object. Because the
speccing is done "lazily" (the spec is created as attributes on the mock are
accessed) you can use it with very complex or deeply nested objects (like
modules that import modules that import modules) without a big performance
hit.<p class="cyxy-trs-source cyxy-trs-target">自动喷涂解决了这个问题。 您可以将 autospec True 传递给 patch () / patch.object () ，或者使用 create autospec ()函数创建带有 spec 的模拟。 如果您使用 autospec True 参数来 patch () ，那么被替换的对象将被用作 spec 对象。 因为 speccing 是“懒惰地”完成的(spec 是在模拟上创建属性时访问的) ，所以可以在非常复杂或嵌套很深的对象(比如导入模块导入模块的模块)中使用它，而不会对性能造成很大影响。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">Here's an example of it in use:<p class="cyxy-trs-source cyxy-trs-target">下面是一个使用中的例子:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.request'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>request</span> <span class=ow>is</span> <span class=n>mock_request</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span><span class=o>.</span><span class=n>Request</span>
<span class=go>&lt;MagicMock name='request.Request' spec='Request' id='...'&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">You can see that <code class="xref py py-class docutils literal notranslate"><span class=pre>request.Request</span></code> has a spec. <code class="xref py py-class docutils literal notranslate"><span class=pre>request.Request</span></code> takes two
arguments in the constructor (one of which is <em>self</em>). Here's what happens if
we try to call it incorrectly:<p class="cyxy-trs-source cyxy-trs-target">你可以看到这个请求。 请求有一个规格。 请求。 Request 在构造函数中接受两个参数(其中一个是 self)。 如果我们不正确地称呼它，会发生以下情况:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>req</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>Request</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>TypeError</span><span>: </span><span class=n>&lt;lambda&gt;() takes at least 2 arguments (1 given)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">The spec also applies to instantiated classes (i.e. the return value of
specced mocks):<p class="cyxy-trs-source cyxy-trs-target">该规范还适用于实例化类(即 specced mock 的返回值) :</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>req</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>Request</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>req</span>
<span class=go>&lt;NonCallableMagicMock name='request.Request()' spec='Request' id='...'&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted"><code class="xref py py-class docutils literal notranslate"><span class=pre>Request</span></code> objects are not callable, so the return value of instantiating our
mocked out <code class="xref py py-class docutils literal notranslate"><span class=pre>request.Request</span></code> is a non-callable mock. With the spec in place
any typos in our asserts will raise the correct error:<p class="cyxy-trs-source cyxy-trs-target">请求对象是不可调用的，因此实例化我们的调用请求的返回值。 请求是不可调用的 mock。 如果规范就绪，我们断言中的任何错误都会引发正确的错误:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>req</span><span class=o>.</span><span class=n>add_header</span><span class=p>(</span><span class=s1>'spam'</span><span class=p>,</span> <span class=s1>'eggs'</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='request.Request().add_header()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>req</span><span class=o>.</span><span class=n>add_header</span><span class=o>.</span><span class=n>assret_called_with</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'assret_called_with'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>req</span><span class=o>.</span><span class=n>add_header</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=s1>'spam'</span><span class=p>,</span> <span class=s1>'eggs'</span><span class=p>)</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">In many cases you will just be able to add <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> to your existing
<a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> calls and then be protected against bugs due to typos and api
changes.<p class="cyxy-trs-source cyxy-trs-target">在许多情况下，您只需将 autospec True 添加到现有的补丁()调用中，然后就可以防止由于输入错误和 api 更改而出现的 bug。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">As well as using <em>autospec</em> through <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> there is a
<a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> for creating autospecced mocks directly:<p class="cyxy-trs-source cyxy-trs-target">除了通过 patch ()使用 autospec 外，还有一个 create autospec ()可以直接创建 autospecced mock:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span> <span class=o>=</span> <span class=n>create_autospec</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span><span class=o>.</span><span class=n>Request</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=s1>'bar'</span><span class=p>)</span>
<span class=go>&lt;NonCallableMagicMock name='mock.Request()' spec='Request' id='...'&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">This isn't without caveats and limitations however, which is why it is not
the default behaviour. In order to know what attributes are available on the
spec object, autospec has to introspect (access attributes) the spec. As you
traverse attributes on the mock a corresponding traversal of the original
object is happening under the hood. If any of your specced objects have
properties or descriptors that can trigger code execution then you may not be
able to use autospec. On the other hand it is much better to design your
objects so that introspection is safe <a class="footnote-reference brackets" href=#id12 id=id11>4</a>.<p class="cyxy-trs-source cyxy-trs-target">然而，这并非没有警告和限制，这就是为什么它不是默认行为。 为了了解 spec 对象上有哪些可用的属性，autospec 必须对 spec 进行内省(访问属性)。 当您遍历 mock 上的属性时，一个对应的原始对象的遍历正在引擎盖下进行。 如果您的任何 specced 对象具有可以触发代码执行的属性或描述符，那么您可能无法使用 autospec。 另一方面，更好的做法是设计您的对象，以便自省是安全的。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">A more serious problem is that it is common for instance attributes to be
created in the <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__init__ title=object.__init__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code></a> method and not to exist on the class at all.
<em>autospec</em> can't know about any dynamically created attributes and restricts
the api to visible attributes.<p class="cyxy-trs-source cyxy-trs-target">一个更严重的问题是，通常在 init ()方法中创建实例属性，而类中根本不存在实例属性。 Autospec 不能知道任何动态创建的属性，并将 api 限制为可见属性。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=bp>self</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>thing</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>thing</span><span class=o>.</span><span class=n>a</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'a'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">There are a few different ways of resolving this problem. The easiest, but
not necessarily the least annoying, way is to simply set the required
attributes on the mock after creation. Just because <em>autospec</em> doesn't allow
you to fetch attributes that don't exist on the spec it doesn't prevent you
setting them:<p class="cyxy-trs-source cyxy-trs-target">有几种不同的方法可以解决这个问题。 最简单，但不一定是最不烦人的方法是在创建模拟之后简单地设置所需的属性。 仅仅因为 autospec 不允许你获取规范中不存在的属性，并不妨碍你设置它们:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>thing</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>thing</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">There is a more aggressive version of both <em>spec</em> and <em>autospec</em> that <em>does</em>
prevent you setting non-existent attributes. This is useful if you want to
ensure your code only <em>sets</em> valid attributes too, but obviously it prevents
this particular scenario:<p class="cyxy-trs-source cyxy-trs-target">Spec 和 autospec 都有一个更加积极的版本，可以防止您设置不存在的属性。 如果你想确保你的代码也只设置有效的属性，这是很有用的，但是很明显它阻止了这个特殊的场景:</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>spec_set</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>thing</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>thing</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'a'</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">Probably the best way of solving the problem is to add class attributes as
default values for instance members initialised in <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__init__ title=object.__init__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code></a>. Note that if
you are only setting default attributes in <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/reference/datamodel.html#object.__init__ title=object.__init__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code></a> then providing them via
class attributes (shared between instances of course) is faster too. e.g.<p class="cyxy-trs-source cyxy-trs-target">也许解决这个问题的最佳方法是为在 init ()中初始化的实例成员添加类属性作为默认值。 注意，如果您只是在 init ()中设置默认属性，那么通过类属性(当然是在实例之间共享)提供它们也更快。 例如:。</p>
<div class="highlight-python notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
    <span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">This brings up another issue. It is relatively common to provide a default
value of <code class="docutils literal notranslate"><span class=pre>None</span></code> for members that will later be an object of a different type.
<code class="docutils literal notranslate"><span class=pre>None</span></code> would be useless as a spec because it wouldn't let you access <em>any</em>
attributes or methods on it. As <code class="docutils literal notranslate"><span class=pre>None</span></code> is <em>never</em> going to be useful as a
spec, and probably indicates a member that will normally of some other type,
autospec doesn't use a spec for members that are set to <code class="docutils literal notranslate"><span class=pre>None</span></code>. These will
just be ordinary mocks (well - MagicMocks):<p class="cyxy-trs-source cyxy-trs-target">这又带来了另一个问题。 为稍后将成为不同类型的对象的成员提供一个 None 的默认值是相对常见的。 没有一个规范是无用的，因为它不允许您访问它上面的任何属性或方法。 由于 None 从来不会作为一个规范有用，并且可能表示一个通常属于其他类型的成员，所以 autospec 不会为设置为 None 的成员使用规范。 这些只是普通的模拟(well-magicmock) :</p>
<div class="doctest highlight-default notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>member</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>create_autospec</span><span class=p>(</span><span class=n>Something</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>member</span><span class=o>.</span><span class=n>foo</span><span class=o>.</span><span class=n>bar</span><span class=o>.</span><span class=n>baz</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.member.foo.bar.baz()' id='...'&gt;</span>
</pre></div>
</div>
<p class="cyxy-trs-source cyxy-trs-source-ted">If modifying your production classes to add defaults isn't to your liking
then there are more options. One of these is simply to use an instance as the
spec rather than the class. The other is to create a subclass of the
production class and add the defaults to the subclass without affecting the
production class. Both of these require you to use an alternative object as
the spec. Thankfully <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> supports this - you can simply pass the
alternative object as the <em>autospec</em> argument:<p class="cyxy-trs-source cyxy-trs-target">如果您不喜欢修改生产类以添加默认值，那么还有更多的选项。 其中之一就是简单地使用一个实例作为 spec 而不是类。 另一种方法是创建产品类的子类，并在不影响产品类的情况下将缺省值添加到子类。 这两者都要求您使用另一个对象作为 spec。 值得庆幸的是，patch ()支持这一点——您可以简单地将替代对象作为 autospec 参数传递:</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=bp>self</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>SomethingForTest</span><span class=p>(</span><span class=n>Something</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>p</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=n>SomethingForTest</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>a</span>
<span class=go>&lt;NonCallableMagicMock name='Something.a' spec='int' id='...'&gt;</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class=label id=id12><span class=brackets><a class=fn-backref href=#id11>4</a></span></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">This only applies to classes or already instantiated objects. Calling
a mocked class to create a mock instance <em>does not</em> create a real instance.
It is only attribute lookups - along with calls to <a class="reference internal" href=https://docs.python.org/zh-cn/3.9/library/functions.html#dir title=dir><code class="xref py py-func docutils literal notranslate"><span class=pre>dir()</span></code></a> - that are done.<p class="cyxy-trs-source cyxy-trs-target">这只适用于类或已经实例化的对象。 调用调用类来创建模拟实例并不会创建真实的实例。 只有属性查找和对 dir ()的调用才能完成。</p>
</dd>
</dl>
</div>
<div class=section id=sealing-mocks>
<h3 class=cyxy-trs-source>Sealing mocks<font class=cyxy-trs-target> 密封模型</font><a class=headerlink href=#sealing-mocks title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.seal>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">seal</code><span class=sig-paren>(</span><em class="sig-param cyxy-trs-source">mock<font class=cyxy-trs-target> 嘲笑</font></em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.seal title=永久链接至目标>¶</a></dt>
<dd><p class="cyxy-trs-source cyxy-trs-source-ted">Seal will disable the automatic creation of mocks when accessing an attribute of
the mock being sealed or any of its attributes that are already mocks recursively.<p class="cyxy-trs-source cyxy-trs-target">Seal 将禁用在访问正在密封的 mock 的属性或者其任何已经递归地模拟的属性时自动创建模拟。</p>
<p class="cyxy-trs-source cyxy-trs-source-ted">If a mock instance with a name or a spec is assigned to an attribute
it won't be considered in the sealing chain. This allows one to prevent seal from
fixing part of the mock object.<p class="cyxy-trs-source cyxy-trs-target">如果一个带有名称或 spec 的模拟实例被分配给一个属性，那么它在密封链中就不会被考虑。 这样就可以防止密封固定模拟对象的一部分。</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class="copybutton cyxy-trs-source" title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>submock</span><span class=o>.</span><span class=n>attribute1</span> <span class=o>=</span> <span class=mi>2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>not_submock</span> <span class=o>=</span> <span class=n>mock</span><span class=o>.</span><span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"sample_name"</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>seal</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>new_attribute</span>  <span class=c1># This will raise AttributeError.</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>submock</span><span class=o>.</span><span class=n>attribute2</span>  <span class=c1># This will raise AttributeError.</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>not_submock</span><span class=o>.</span><span class=n>attribute2</span>  <span class=c1># This won't raise.</span>
</pre></div>
</div>
<div class=versionadded>
<p class="cyxy-trs-source cyxy-trs-source-ted"><span class="versionmodified added">3.7 新版功能.</span><p class="cyxy-trs-source cyxy-trs-target">New version 3.7 features.</p>
</div>
</dl>
</div>
</div>
</div>
 </div>
 </div>
 </div>
 <div class=sphinxsidebar role=navigation aria-label="main navigation">
 <div class=sphinxsidebarwrapper style=float:left;margin-right:0px;width:202px;top:62027.6px>
 <h3><a href=https://docs.python.org/zh-cn/3.9/contents.html class="cyxy-trs-source cyxy-trs-source-ted">目录<font class=cyxy-trs-target> Table of contents</font></a></h3>
 <ul>
<li><a class="reference internal cyxy-trs-source" href=#><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code> --- mock对象库<font class=cyxy-trs-target> -- Mock Object Library</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#quick-guide>快速上手<font class=cyxy-trs-target> Quick Start</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#the-mock-class>The Mock Class<font class=cyxy-trs-target> 模拟课程</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#calling>Calling<font class=cyxy-trs-target> 来电</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#deleting-attributes>Deleting Attributes<font class=cyxy-trs-target> 删除属性</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mock-names-and-the-name-attribute>Mock names and the name attribute<font class=cyxy-trs-target> 模拟名称和 name 属性</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#attaching-mocks-as-attributes>Attaching Mocks as Attributes<font class=cyxy-trs-target> 作为属性附加模拟</font></a></li>
</ul>
</li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#the-patchers>The patchers<font class=cyxy-trs-target> 修补者</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patch>patch<font class=cyxy-trs-target> 补丁</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patch-object>patch.object<font class=cyxy-trs-target> 补丁，对象</font></a></li>
<li><a class="reference internal" href=#patch-dict>patch.dict</a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patch-multiple>patch.multiple<font class=cyxy-trs-target> 拼凑，复合</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patch-methods-start-and-stop>patch methods: start and stop<font class=cyxy-trs-target> 补丁方法: 启动和停止</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patch-builtins>patch builtins<font class=cyxy-trs-target> 补丁内建物</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#test-prefix>TEST_PREFIX<font class=cyxy-trs-target> 测试前缀</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#nesting-patch-decorators>Nesting Patch Decorators<font class=cyxy-trs-target> 嵌套修补装饰器</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#where-to-patch>Where to patch<font class=cyxy-trs-target> 在哪里修补</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#patching-descriptors-and-proxy-objects>Patching Descriptors and Proxy Objects<font class=cyxy-trs-target> 修补描述符和代理对象</font></a></li>
</ul>
</li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#magicmock-and-magic-method-support>MagicMock and magic method support<font class=cyxy-trs-target> Magicmock 和 magic 方法支持</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mocking-magic-methods>Mocking Magic Methods<font class=cyxy-trs-target> 嘲笑魔法的方法</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#magic-mock>Magic Mock<font class=cyxy-trs-target> 魔术模拟</font></a></li>
</ul>
</li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#helpers>Helpers<font class=cyxy-trs-target> 助手</font></a><ul>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#sentinel>sentinel<font class=cyxy-trs-target> 哨兵</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#default>DEFAULT<font class=cyxy-trs-target> 默认</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#call>call<font class=cyxy-trs-target> 呼叫</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#create-autospec>create_autospec<font class=cyxy-trs-target> 创建 autospec</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#any>ANY<font class=cyxy-trs-target> 任何</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#filter-dir>FILTER_DIR<font class=cyxy-trs-target> 滤波器目录</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#mock-open>mock_open<font class=cyxy-trs-target> 模拟开启</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#autospeccing>Autospeccing<font class=cyxy-trs-target> 自动投影</font></a></li>
<li><a class="reference internal cyxy-trs-source cyxy-trs-source-ted" href=#sealing-mocks>Sealing mocks<font class=cyxy-trs-target> 密封模型</font></a></li>
</ul>
</li>
</ul>
</li>
</ul>
 <h4 class="cyxy-trs-source cyxy-trs-source-ted">上一个主题</h4><h4 class="cyxy-trs-source cyxy-trs-target">The last subject</h4>
 <p class="topless cyxy-trs-source cyxy-trs-source-ted"><a href=https://docs.python.org/zh-cn/3.9/library/unittest.html title=上一章><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code> --- 单元测试框架</a><p class="topless cyxy-trs-source cyxy-trs-target">UNITTEST ---unit test framework</p>
 <h4 class="cyxy-trs-source cyxy-trs-source-ted">下一个主题</h4><h4 class="cyxy-trs-source cyxy-trs-target">Next topic</h4>
 <p class="topless cyxy-trs-source cyxy-trs-source-ted"><a href=https://docs.python.org/zh-cn/3.9/library/unittest.mock-examples.html title=下一章><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code> 上手指南</a><p class="topless cyxy-trs-source cyxy-trs-target">Unit test. Mock hands-on guide</p>
 <div role=note aria-label="source link">
 <h3 class="cyxy-trs-source cyxy-trs-source-ted">本页</h3><h3 class="cyxy-trs-source cyxy-trs-target">This page</h3>
 <ul class=this-page-menu>
 <li><a href=https://docs.python.org/zh-cn/3.9/bugs.html class="cyxy-trs-source cyxy-trs-source-ted">提交 Bug<font class=cyxy-trs-target> Commit the Bug</font></a></li>
 <li>
 <a href=https://github.com/python/cpython/blob/master/Doc/library/unittest.mock.rst rel=nofollow class="cyxy-trs-source cyxy-trs-source-ted">显示源代码
 <font class=cyxy-trs-target> Display source code</font></a>
 </li>
 </ul>
 </div>
 </div>
 <div id=sidebarbutton title=折叠边栏 style="border-radius:0px 5px 5px 0px;color:#444444;background-color:#cccccc;font-size:1.2em;cursor:pointer;height:45887.6px;padding-top:1px;padding-left:1px;margin-left:218px"><span style=display:block;position:fixed;top:351px>«</span></div></div>
 <div class=clearer></div>
 </div> 
 <div class=related role=navigation aria-label="related navigation">
 <h3 class="cyxy-trs-source cyxy-trs-source-ted sf-hidden">导航</h3><h3 class="cyxy-trs-source cyxy-trs-target sf-hidden">Navigation</h3>
 <ul>
 <li class=right style=margin-right:10px>
 <a href=https://docs.python.org/zh-cn/3.9/genindex.html title=总目录 class="cyxy-trs-source cyxy-trs-source-ted">索引<font class=cyxy-trs-target> Index</font></a></li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/py-modindex.html title="Python 模块索引" class="cyxy-trs-source cyxy-trs-source-ted">模块<font class=cyxy-trs-target> Module</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/unittest.mock-examples.html title="unittest.mock 上手指南" class="cyxy-trs-source cyxy-trs-source-ted">下一页<font class=cyxy-trs-target> Next page</font></a> |</li>
 <li class=right>
 <a href=https://docs.python.org/zh-cn/3.9/library/unittest.html title="unittest --- 单元测试框架" class="cyxy-trs-source cyxy-trs-source-ted">上一页<font class=cyxy-trs-target> Previous</font></a> |</li>
 <li><img src='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><rect fill-opacity="0"/></svg>' alt style="vertical-align:middle;margin-top:-1px;background-blend-mode:normal!important;background-clip:content-box!important;background-position:50% 50%!important;background-color:rgba(0,0,0,0)!important;background-image:var(--sf-img-1)!important;background-size:100% 100%!important;background-origin:content-box!important;background-repeat:no-repeat!important"></li>
 <li><a href=https://www.python.org/ class="cyxy-trs-source cyxy-trs-source-ted">Python<font class=cyxy-trs-target> 巨蟒</font></a> »</li>
 
 <li>
 <span class=language_switcher_placeholder><select><option value=en>English<option value=fr>French<option value=ja>Japanese<option value=ko>Korean<option value=pt-br>Brazilian Portuguese<option value=zh-cn selected>Simplified Chinese</select></span>
 <span class=version_switcher_placeholder><select><option value=3.10>dev (3.10)<option value=3.9 selected>3.9.0b3<option value=3.8>3.8<option value=3.7>3.7<option value=3.6>3.6<option value=3.5>3.5<option value=2.7>2.7</select></span>
 <a href=https://docs.python.org/zh-cn/3.9/index.html class="cyxy-trs-source cyxy-trs-source-ted">文档<font class=cyxy-trs-target> Documents</font></a> »
 </li>
 <li class="nav-item nav-item-1"><a href=https://docs.python.org/zh-cn/3.9/library/index.html class="cyxy-trs-source cyxy-trs-source-ted">Python 标准库<font class=cyxy-trs-target> Python Standard Library</font></a> »</li>
 <li class="nav-item nav-item-2"><a href=https://docs.python.org/zh-cn/3.9/library/development.html class="cyxy-trs-source cyxy-trs-source-ted">开发工具<font class=cyxy-trs-target> Development tools</font></a> »</li>
 <li class=right>
 
 <div class=inline-search role=search>
 <form class=inline-search action=../search.html>
 <input placeholder=快速搜索 type=text name=q value>
 <input type=submit value=转向>
 
 
 </form>
 </div>
 
 |
 </li>
 </ul>
 </div> 
 <div class="footer cyxy-trs-source">
 © <a href=https://docs.python.org/zh-cn/3.9/copyright.html class="cyxy-trs-source cyxy-trs-source-ted">版权所有<font class=cyxy-trs-target> All rights reserved</font></a> 2001-2020, Python Software Foundation.
 <font class=cyxy-trs-target> 2001-2020年，Python软体基金会</font><br>
 The Python Software Foundation is a non-profit corporation.
<font class=cyxy-trs-target> Python软体基金会是一家非营利性公司</font><a href=https://www.python.org/psf/donations/ class="cyxy-trs-source cyxy-trs-source-ted">Please donate.<font class=cyxy-trs-target> 请捐款</font></a>
<br>
 <br>
 最后更新于 6月 17, 2020.
 <font class=cyxy-trs-target> Last updated on 17 June 2020</font><a href=https://docs.python.org/3/bugs.html class="cyxy-trs-source cyxy-trs-source-ted">Found a bug<font class=cyxy-trs-target> 发现了一个漏洞</font></a>?
 <br>
 Created using <font class=cyxy-trs-target> 创建使用</font><a href=https://www.sphinx-doc.org/ class="cyxy-trs-source cyxy-trs-source-ted">Sphinx<font class=cyxy-trs-target> 狮身人面像</font></a> 2.3.1.
 </div>
 
 <div class=cyxy-ctrl-wrapper>
 <div class=cyxy-ctrl-btn>
 <img class=cyxy-ctrl-img src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=chrome-extension://jmpepeebcbihafjjadogphmbgiffiajh/images/control.png>
 </div>
 <div class=cyxy-personal style=display:none>
 <a href=https://fanyi.caiyunapp.com/user/center/ target=_blank>
 
 </a>
 </div>
 <div class=cyxy-function style=display:none>
 <img class=cyxy-favorite-btn src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=https://caiyunapp.com/imgs/webtrs/fanyi-btn-hover.png>
 </div>
 <div class=cyxy-favorite style=display:none>
 <img id=cyxyFavoriteBtn class=cyxy-favorite-btn src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=https://caiyunapp.com/imgs/webtrs/favorite-btn.png>
 </div>
 <div class=cyxy-video-trans style=display:none>
 <img class=cyxy-video-trans-btn src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" data-single-file-origin-u-r-l=chrome-extension://jmpepeebcbihafjjadogphmbgiffiajh/images/fanyi-btn-subtitle.png>
 </div>
 <div class=cyxy-options-link style=display:none>
 <div class=cyxy-options-btn>
 
 </div>
 </div>
 </div> 
 <div class="cyxy-target-popup cyxy-trs-source" style=display:none><div style=margin:auto> </div></div><div class="cyxy-footer cyxy-trs-source" style=opacity:.88;display:none><div class=cyxy-footer-p>本网页由彩云小译翻译</div></div>