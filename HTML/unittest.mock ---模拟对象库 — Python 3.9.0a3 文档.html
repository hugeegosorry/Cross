<!DOCTYPE html> <html xmlns=http://www.w3.org/1999/xhtml lang=zh><!--
 Page saved with SingleFile 
 url: https://www.osgeo.cn/cpython/library/unittest.mock.html 
 saved date: Sun May 17 2020 20:47:43 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<title>unittest.mock ---模拟对象库 — Python 3.9.0a3 文档</title>
<style>div.body{min-width:450px;max-width:800px}div.body p,div.body dd,div.body li,div.body blockquote{-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto}a.headerlink{visibility:hidden}a.brackets:before,span.brackets>a:before{content:"["}a.brackets:after,span.brackets>a:after{content:"]"}h1:hover>a.headerlink,h2:hover>a.headerlink,h3:hover>a.headerlink,h4:hover>a.headerlink,h5:hover>a.headerlink,h6:hover>a.headerlink,dt:hover>a.headerlink,caption:hover>a.headerlink,p.caption:hover>a.headerlink,div.code-block-caption:hover>a.headerlink{visibility:visible}div.admonition{margin-top:10px;margin-bottom:10px;padding:7px}p.admonition-title{margin:0px 10px 5px 0px;font-weight:bold}li>p:first-child{margin-top:0px}li>p:last-child{margin-bottom:0px}dl.footnote>dt{float:left}dl.footnote>dd{margin-bottom:0em}dl.footnote>dd:after,dl.citation>dd:after{content:"";clear:both}dl{margin-bottom:15px}dd>p:first-child{margin-top:0px}dd ul{margin-bottom:10px}dd{margin-top:3px;margin-bottom:10px;margin-left:30px}dt:target,span.highlighted{background-color:#fbe54e}.sig-paren{font-size:larger}.versionmodified{font-style:italic}.footnote:target{background-color:#ffa}pre{overflow:auto;overflow-y:hidden}span.pre{-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;hyphens:none}code.descname{background-color:transparent;font-weight:bold}code.descclassname{background-color:transparent}code.xref{background-color:transparent}html{background-color:#fff}body{font-family:'Lucida Grande',Arial,sans-serif;font-size:100%;color:#000;margin:0;padding:0}div.document{background-color:white}div.documentwrapper{float:left;width:100%}div.bodywrapper{margin:0 0 0 230px}div.body{background-color:white;color:#222}a{text-decoration:none}a:visited{color:#00608f;text-decoration:none}a:hover{text-decoration:underline}div.body h1,div.body h2,div.body h3{font-family:'Lucida Grande',Arial,sans-serif;background-color:white;font-weight:normal;color:#1a1a1a;border-bottom:1px solid #ccc}div.body h1{margin-top:0;font-size:200%}div.body h2{font-size:160%}div.body h3{font-size:140%}a.headerlink{font-size:.8em;padding:0 4px 0 4px;text-decoration:none}a.headerlink:hover{background-color:#aaa;color:white}div.body p,div.body dd,div.body li,div.body blockquote{text-align:justify;line-height:130%}div.admonition p.admonition-title+p{display:inline}div.admonition p{margin-bottom:5px}div.admonition pre{margin-bottom:5px}div.note{background-color:#eee;border:1px solid #ccc}p.admonition-title{display:inline}p.admonition-title:after{content:":"}pre{padding:5px;background-color:#efc;color:#333;line-height:120%;border-left:0;border-right:0}code{background-color:#ecf0f3;padding:0 1px 0 1px}.note code{background:#d6d6d6}body{background-color:white;margin-left:1em;margin-right:1em}div.body{padding:0 0 0 1.2em}div.body p{line-height:140%}div.body h1,div.body h2,div.body h3{margin:0;border:0;padding:.3em 0}div.body hr{border:0;background-color:#ccc;height:1px}div.body pre{border-radius:3px;border:1px solid #ac9}div.body div.admonition{border-radius:3px}div.body a{color:#0072aa}div.body a:visited{color:#6363bb}div.body a:hover{color:#00b0e4}code,pre{font-family:monospace,sans-serif;font-size:96.5%}div.body code{border-radius:3px}div.body code.descname{font-size:120%}div.body code.xref{font-weight:normal}.highlight{background:none!important}dl>dt span~em{font-family:monospace,sans-serif}.highlight{background:#efc}.highlight .c{color:#408090;font-style:italic}.highlight .k{color:#007020;font-weight:bold}.highlight .o{color:#666}.highlight .c1{color:#408090;font-style:italic}.highlight .gr{color:red}.highlight .go{color:#333}.highlight .gp{color:#c65d09;font-weight:bold}.highlight .gt{color:#04d}.highlight .kc{color:#007020;font-weight:bold}.highlight .kn{color:#007020;font-weight:bold}.highlight .nb{color:#007020}.highlight .nc{color:#0e84b5;font-weight:bold}.highlight .nd{color:#555;font-weight:bold}.highlight .ne{color:#007020}.highlight .nf{color:#06287e}.highlight .nn{color:#0e84b5;font-weight:bold}.highlight .ow{color:#007020;font-weight:bold}.highlight .mf{color:#208050}.highlight .mi{color:#208050}.highlight .s2{color:#4070a0}.highlight .se{color:#4070a0;font-weight:bold}.highlight .s1{color:#4070a0}.highlight .bp{color:#007020}.highlight .fm{color:#06287e}.highlight .vm{color:#bb60d5}</style>
<link rel=search type=application/opensearchdescription+xml title="在 Python 3.9.0a3 文档 中搜索" href=https://www.osgeo.cn/cpython/_static/opensearch.xml>
<link rel=author title=关于这些文档 href=https://www.osgeo.cn/cpython/about.html>
<link rel=index title=索引 href=https://www.osgeo.cn/cpython/genindex.html>
<link rel=search title=搜索 href=https://www.osgeo.cn/cpython/search.html>
<link rel=copyright title=版权所有 href=https://www.osgeo.cn/cpython/copyright.html>
<link rel=next title="unittest.mock ---开始" href=https://www.osgeo.cn/cpython/library/unittest.mock-examples.html>
<link rel=prev title="unittest ——单元测试框架" href=https://www.osgeo.cn/cpython/library/unittest.html>
<link rel=canonical href=https://docs.python.org/3/library/unittest.mock.html>
<style>@media (pointer:coarse){@media only screen and (max-device-width:1024px){html{font-size:80%!important}}@media only screen and (max-device-width:414px){html{font-size:70%!important}}@media only screen and (max-device-width:320px){html{font-size:90%!important}}}@-webkit-keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes srFadeInUp{0%{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}to{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@keyframes srFadeInDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(100px);transform:translateY(100px)}}@-webkit-keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes fadeOutUp{0%{opacity:1}to{margin-top:0;padding:0;height:0;min-height:0;opacity:0;-webkit-transform:scaleY(0);transform:scaleY(0)}}@keyframes caretBlink{from{opacity:1.0}to{opacity:0.0}}@keyframes rotateSpinner{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gEGxE4IQYzJ14AAAI3SURBVDjLZZNPSFVBFIe/e9+zd3silBCl0SZoU4s2rVq0EB5tQip4UNvATVGu3QRBiyAi2iltWkgbF5EgRhFFRpiWtrWIzDIV1Pzz7p15M2fmtvDevOqBw8DM9zvnN8ycgF3R/eDtM2mac96ZdrFNxBikqbRV+vHH/ut9gAZczoe7C3gnF0f6au1OLM5avFi8d1Ea+JvAMSAq8nsKOGs5f2cYJ3Y7rc2PO4BqkS8DdD98f9tbe1ysCoxOBo1qlEXHJWcM4b5KPU19zleA0o4Clx99eO3EdqVewHsCoFRugUoVghJO7A6H6Vx9wdtYi27cr5x6dy/03nVtWTU7bWeZh6jNUcAiCaFTURl9A+gs56AviHzh3mnqtdPxm6knfQPLU7UaokASQq/agY7yDrG16Mba6Pz48NP56VdrgAApYObGaicPtkovToFLQBKA/WUxTe3FRk4san15aGKgd3Dj560rrdGJS6FT0X9YYvLuiMKL1kAQOpHZ3PqfyZfP41+9PW1VfzX0RXFSECfgNEmSTgImdDruF2O0E8vvqZG1auQubAsKooIYYHpGvwA2g+xndQBHgWa6cG0ih5cW/w6VvEq3nChwCoBvs+bL2Z7VceBHGTDAIrABpMVuhw+4OiLgLIglOLPYBTQAlfErIeCzjRVg1dtEb1kt5Omv+DTV2YssAN+zNdkzC42N9brV8WdvYp07seOdM2Of1F3AAknW0AJpwN6IgEPAEaANaMlcbmZdl7KRBuAfAb+v//yMAJoAAAAASUVORK5CYII="><body>
 
 <div class=related role=navigation aria-label="related navigation" style=display:none!important>
 
 
 </div> 
 <div class=document>
 <div class=documentwrapper>
 <div class=bodywrapper>
 <div class=body role=main>
 
 <div class=section id=module-unittest.mock>
<span id=unittest-mock-mock-object-library style=display:none!important></span><h1><a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> ---模拟对象库<a class=headerlink href=#module-unittest.mock title=永久链接至标题>¶</a></h1>
<div class=versionadded>
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<p><strong>源代码：</strong> <a class="reference external" href=https://github.com/python/cpython/tree/master/Lib/unittest/mock.py>Lib/unittest/mock.py</a></p>
<hr class=docutils>
<p><a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> 是一个在Python中测试的库。它允许您用模拟对象替换测试中的系统部分，并对它们的使用方式作出断言。</p>
<p><a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> 提供核心 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 类删除了在整个测试套件中创建大量存根的需要。在执行操作之后，您可以断言使用了哪些方法/属性以及调用它们的参数。您还可以指定返回值并以正常方式设置所需的属性。</p>
<p>此外，mock还提供了 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 在测试范围内处理修补模块和类级属性的装饰器，以及 <a class="reference internal" href=#unittest.mock.sentinel title=unittest.mock.sentinel><code class="xref py py-const docutils literal notranslate"><span class=pre>sentinel</span></code></a> 用于创建唯一对象。查看 <a class="reference internal" href=#quick-guide>quick guide</a> 例如如何使用 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> ， <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 和 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> .</p>
<p>mock非常容易使用，设计用于 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/unittest.html#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> . 模拟是基于“操作-&gt;断言”模式，而不是许多模拟框架使用的“记录-&gt;重播”。</p>
<p>有一个反向端口 <a class="reference internal" href=#module-unittest.mock title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest.mock</span></code></a> 对于早期版本的python，可用作 <a class="reference external" href=https://pypi.org/project/mock>mock on PyPI</a> .</p>
<div class=section id=quick-guide>
<h2>快速指南<a class=headerlink href=#quick-guide title=永久链接至标题>¶</a></h2>
<p><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 和 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 对象在您访问它们时创建所有属性和方法，并存储它们的使用细节。您可以配置它们，指定返回值或限制哪些属性可用，然后就它们的使用方式作出断言：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>MagicMock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=o>.</span><span class=n>method</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'value'</span><span class=p>)</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'value'</span><span class=p>)</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 允许您执行副作用，包括在调用模拟时引发异常：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>KeyError</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>KeyError</span><span>: </span><span class=n>'foo'</span>
</pre></div>
</div>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>values</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'a'</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=n>arg</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>values</span><span class=p>[</span><span class=n>arg</span><span class=p>]</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'a'</span><span class=p>),</span> <span class=n>mock</span><span class=p>(</span><span class=s1>'b'</span><span class=p>),</span> <span class=n>mock</span><span class=p>(</span><span class=s1>'c'</span><span class=p>)</span>
<span class=go>(1, 2, 3)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>()</span>
<span class=go>(5, 4, 3)</span>
</pre></div>
</div>
<p>mock有许多其他的方法，您可以配置它并控制它的行为。例如 <em>spec</em> 参数将mock配置为从另一个对象获取其规范。尝试访问规范中不存在的模拟上的属性或方法将失败，原因是 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .</p>
<p>这个 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorator/context manager使模拟测试模块中的类或对象变得容易。您指定的对象将在测试期间替换为模拟对象（或其他对象），并在测试结束时还原：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>patch</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'module.ClassName2'</span><span class=p>)</span>
<span class=gp>... </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'module.ClassName1'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>MockClass1</span><span class=p>,</span> <span class=n>MockClass2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>module</span><span class=o>.</span><span class=n>ClassName1</span><span class=p>()</span>
<span class=gp>... </span>    <span class=n>module</span><span class=o>.</span><span class=n>ClassName2</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass1</span> <span class=ow>is</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName1</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass2</span> <span class=ow>is</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName2</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass1</span><span class=o>.</span><span class=n>called</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>MockClass2</span><span class=o>.</span><span class=n>called</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>当嵌套修补程序装饰器时，模拟将按它们应用的相同顺序传入装饰函数（正常 <em>Python</em> 命令应用装饰器）。这意味着从下到上，因此在上面的示例中， <code class="docutils literal notranslate"><span class=pre>module.ClassName1</span></code> 先通过。</p>
<p>用 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 在查找对象的名称空间中修补对象很重要。这通常很简单，但为了快速阅读 <a class="reference internal" href=#where-to-patch><span class="std std-ref">where to patch</span></a> .</p>
</div>
<p>以及装饰师 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 可以用作WITH语句中的上下文管理器：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>ProductionClass</span><span class=p>,</span> <span class=s1>'method'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_method</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>thing</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>... </span>    <span class=n>thing</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_method</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p>也有 <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 仅在作用域期间在字典中设置值，并在测试结束时将字典恢复到原始状态：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'key'</span><span class=p>:</span> <span class=s1>'value'</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>foo</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>},</span> <span class=n>clear</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=n>original</span>
</pre></div>
</div>
<p>mock支持对python的模拟 <a class="reference internal" href=#magic-methods><span class="std std-ref">magic methods</span></a> . 使用魔法方法的最简单方法是 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 类。它允许您执行以下操作：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'foobarbaz'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'foobarbaz'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p>mock允许您将函数（或其他mock实例）分配给magic方法，它们将被适当地调用。这个 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 类只是一个模拟变量，它有为您预先创建的所有魔术方法（好吧，不管怎样，所有有用的方法）。</p>
<p>下面是一个将魔术方法用于普通模拟类的示例：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=s1>'wheeeeee'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'wheeeeee'</span>
</pre></div>
</div>
<p>为了确保测试中的模拟对象与它们要替换的对象具有相同的API，可以使用 <a class="reference internal" href=#auto-speccing><span class="std std-ref">auto-speccing</span></a> . 可以通过 <em>AutoPoC</em> patch的参数，或 <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 功能。自动规范创建的模拟对象具有与其替换的对象相同的属性和方法，并且任何函数和方法（包括构造函数）都具有与真实对象相同的调用签名。</p>
<p>这样可以确保模拟在错误使用时会以与生产代码相同的方式失败：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>create_autospec</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>function</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span> <span class=o>=</span> <span class=n>create_autospec</span><span class=p>(</span><span class=n>function</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=s1>'fishy'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=go>'fishy'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_function</span><span class=p>(</span><span class=s1>'wrong arguments'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>TypeError</span><span>: </span><span class=n>&lt;lambda&gt;() takes exactly 3 arguments (1 given)</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 也可以在类上使用，在类中复制 <code class="docutils literal notranslate"><span class=pre>__init__</span></code> 方法，以及在可调用对象上复制 <code class="docutils literal notranslate"><span class=pre>__call__</span></code> 方法。</p>
</div>
<div class=section id=the-mock-class>
<h2>模拟课堂<a class=headerlink href=#the-mock-class title=永久链接至标题>¶</a></h2>
<p><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 是一个灵活的模拟对象，用于在整个代码中替换存根和测试双精度的使用。mock是可调用的，访问它们时创建属性作为新的mock <a class="footnote-reference brackets" href=#id3 id=id1>1</a>. 访问相同的属性将始终返回相同的模拟。模拟记录了您如何使用它们，允许您对代码对它们所做的操作作出断言。</p>
<p><a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> is a subclass of <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> with all the magic methods
pre-created and ready to use. There are also non-callable variants, useful
when you are mocking out objects that aren't callable:
<a class="reference internal" href=#unittest.mock.NonCallableMock title=unittest.mock.NonCallableMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMock</span></code></a> and <a class="reference internal" href=#unittest.mock.NonCallableMagicMock title=unittest.mock.NonCallableMagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMagicMock</span></code></a></p>
<p>这个 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorator使得用 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 对象。默认 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 将创建一个 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 为你。您可以指定 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 使用 <em>new_callable</em> 参数 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> .</p>
<dl class=class>
<dt id=unittest.mock.Mock>
<em class=property>class </em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">Mock</code><span class=sig-paren>(</span><em class=sig-param>spec=None</em>, <em class=sig-param>side_effect=None</em>, <em class=sig-param>return_value=DEFAULT</em>, <em class=sig-param>wraps=None</em>, <em class=sig-param>name=None</em>, <em class=sig-param>spec_set=None</em>, <em class=sig-param>unsafe=False</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock title=永久链接至目标>¶</a></dt>
<dd><p>创建新的 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 对象。 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 采用几个指定模拟对象行为的可选参数：</p>
<ul>
<li><p><em>spec</em> ：这可以是字符串列表，也可以是作为模拟对象规范的现有对象（类或实例）。如果传入一个对象，则通过对该对象调用dir（不包括不受支持的magic属性和方法）来形成字符串列表。访问不在此列表中的任何属性将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .</p>
<p>如果 <em>spec</em> 是一个对象（而不是字符串列表），然后 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/stdtypes.html#instance.__class__ title=instance.__class__><code class="xref py py-attr docutils literal notranslate"><span class=pre>__class__</span></code></a> 返回spec对象的类。这允许模拟通过 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> 测验。</p>
</li>
<li><p><em>spec_set</em> ：更严格的变体 <em>spec</em> . 如果使用，尝试 <em>set</em> 或者获取不在作为 <em>spec_set</em> 将提高 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .</p></li>
<li><p><em>side_effect</em> ：每当调用模拟时要调用的函数。见 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 属性。用于引发异常或动态更改返回值。使用与mock相同的参数调用函数，除非它返回 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> ，此函数的返回值用作返回值。</p>
<p>替代地 <em>side_effect</em> 可以是异常类或实例。在这种情况下，调用模拟时将引发异常。</p>
<p>如果 <em>side_effect</em> 是ITerable，则对mock的每个调用都将从ITerable返回下一个值。</p>
<p>A <em>side_effect</em> 可以通过将其设置为 <code class="docutils literal notranslate"><span class=pre>None</span></code> .</p>
</li>
<li><p><em>return_value</em> ：调用模拟时返回的值。默认情况下，这是一个新的模拟（在第一次访问时创建）。见 <a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> 属性。</p></li>
<li><p><em>不安全的</em> ：默认情况下，如果任何属性以开头 <em>断言</em> 或 <em>阿斯瑞特</em> 将提高 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .经过 <code class="docutils literal notranslate"><span class=pre>unsafe=True</span></code> 将允许访问这些属性。</p>
<div class=versionadded>
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</li>
<li><p><em>包裹</em> ：要封装模拟对象的项。如果 <em>包裹</em> 不是 <code class="docutils literal notranslate"><span class=pre>None</span></code> 然后调用mock将把调用传递给被封装的对象（返回实际结果）。mock上的属性访问将返回一个mock对象，该对象封装所封装对象的相应属性（因此尝试访问不存在的属性将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> ）</p>
<p>如果模拟有明确的 <em>return_value</em> set then调用不会传递给封装的对象， <em>return_value</em> 而是返回。</p>
</li>
<li><p><em>name</em> ：如果模型有名称，则将在模型的报告中使用。这对于调试很有用。该名称将传播到子模拟。</p></li>
</ul>
<p>模拟也可以用任意关键字参数调用。这些将用于在创建模拟后在其上设置属性。见 <a class="reference internal" href=#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a> 详细信息的方法。</p>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called>
<code class="sig-name descname">assert_called</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called title=永久链接至目标>¶</a></dt>
<dd><p>断言至少调用了一次模拟。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called</span><span class=p>()</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called_once>
<code class="sig-name descname">assert_called_once</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called_once title=永久链接至目标>¶</a></dt>
<dd><p>断言模拟调用了一次。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_once</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_once</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'method' to have been called once. Called 2 times.</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.6 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called_with>
<code class="sig-name descname">assert_called_with</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called_with title=永久链接至目标>¶</a></dt>
<dd><p>此方法是断言最后一次调用是以特定方式进行的一种方便的方法：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=o>=</span><span class=s1>'wow'</span><span class=p>)</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=o>=</span><span class=s1>'wow'</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_called_once_with>
<code class="sig-name descname">assert_called_once_with</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_called_once_with title=永久链接至目标>¶</a></dt>
<dd><p>断言该模拟调用了一次，并且该调用使用了指定的参数。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'baz'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'baz'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'other'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'values'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'other'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'values'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'mock' to be called once. Called 2 times.</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_any_call>
<code class="sig-name descname">assert_any_call</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_any_call title=永久链接至目标>¶</a></dt>
<dd><p>断言已使用指定的参数调用了模拟。</p>
<p>如果模拟具有 <em>ever</em> 被称为，不像 <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> 只有当调用是最新的，并且 <a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> 也必须是唯一的调用。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'thing'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'some'</span><span class=p>,</span> <span class=s1>'thing'</span><span class=p>,</span> <span class=s1>'else'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_any_call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'thing'</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_has_calls>
<code class="sig-name descname">assert_has_calls</code><span class=sig-paren>(</span><em class=sig-param>calls</em>, <em class=sig-param>any_order=False</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_has_calls title=永久链接至目标>¶</a></dt>
<dd><p>断言已使用指定的调用调用模拟。这个 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 检查通话列表。</p>
<p>如果 <em>any_order</em> 如果为false，则调用必须是连续的。在指定的调用之前或之后可以有额外的调用。</p>
<p>如果 <em>any_order</em> 如果为真，则调用可以是任何顺序，但它们必须全部出现在 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_calls</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>4</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_calls</span><span class=p>(</span><span class=n>calls</span><span class=p>,</span> <span class=n>any_order</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.assert_not_called>
<code class="sig-name descname">assert_not_called</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.assert_not_called title=永久链接至目标>¶</a></dt>
<dd><p>断言从未调用模拟。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>hello</span><span class=o>.</span><span class=n>assert_not_called</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>obj</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>hello</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>hello</span><span class=o>.</span><span class=n>assert_not_called</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'hello' to not have been called. Called 1 times.</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.reset_mock>
<code class="sig-name descname">reset_mock</code><span class=sig-paren>(</span><em class=sig-param>*</em>, <em class=sig-param>return_value=False</em>, <em class=sig-param>side_effect=False</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.reset_mock title=永久链接至目标>¶</a></dt>
<dd><p>重置模拟方法重置模拟对象上的所有调用属性：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'hello'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>reset_mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>False</span>
</pre></div>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.6 版更改: </span>向reset_mock函数添加了两个只包含关键字的参数。</p>
</div>
<p>当您想要创建一系列重用同一对象的断言时，这可能很有用。注意 <a class="reference internal" href=#unittest.mock.Mock.reset_mock title=unittest.mock.Mock.reset_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>reset_mock()</span></code></a> <em>不</em> 清除返回值， <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 或者默认情况下使用普通赋值设置的任何子属性。如果你想重置 <em>return_value</em> 或 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> ，然后将相应的参数传递为 <code class="docutils literal notranslate"><span class=pre>True</span></code> . 子模拟和返回值模拟（如果有的话）也被重置。</p>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p><em>return_value</em> 和 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 只有关键字参数。</p>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.mock_add_spec>
<code class="sig-name descname">mock_add_spec</code><span class=sig-paren>(</span><em class=sig-param>spec</em>, <em class=sig-param>spec_set=False</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.mock_add_spec title=永久链接至目标>¶</a></dt>
<dd><p>向模型添加规范。 <em>spec</em> 可以是对象或字符串列表。只有上的属性 <em>spec</em> 可以从模拟中作为属性获取。</p>
<p>如果 <em>spec_set</em> 为true，则只能设置规范上的属性。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.attach_mock>
<code class="sig-name descname">attach_mock</code><span class=sig-paren>(</span><em class=sig-param>mock</em>, <em class=sig-param>attribute</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.attach_mock title=永久链接至目标>¶</a></dt>
<dd><p>附加一个mock作为这个mock的属性，替换它的名称和父级。对所附模型的调用将记录在 <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 这个的属性。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.configure_mock>
<code class="sig-name descname">configure_mock</code><span class=sig-paren>(</span><em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.configure_mock title=永久链接至目标>¶</a></dt>
<dd><p>在模拟关键字参数上设置属性。</p>
<p>属性加上返回值和副作用可以在子mock上使用标准点表示法设置，并在方法调用中解包字典：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>attrs</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>configure_mock</span><span class=p>(</span><span class=o>**</span><span class=n>attrs</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p>同样的事情也可以在构造函数调用mocks中实现：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>attrs</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>some_attribute</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>,</span> <span class=o>**</span><span class=n>attrs</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>some_attribute</span>
<span class=go>'eggs'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a> 这样做是为了在创建模拟之后更容易进行配置。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock.__dir__>
<code class="sig-name descname">__dir__</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock.__dir__ title=永久链接至目标>¶</a></dt>
<dd><p><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 对象限制的结果 <code class="docutils literal notranslate"><span class=pre>dir(some_mock)</span></code> 为了有用的结果。对于一个 <em>spec</em> 这包括模拟的所有允许属性。</p>
<p>见 <a class="reference internal" href=#unittest.mock.FILTER_DIR title=unittest.mock.FILTER_DIR><code class="xref py py-data docutils literal notranslate"><span class=pre>FILTER_DIR</span></code></a> 了解这个过滤的作用，以及如何关闭它。</p>
</dl>
<dl class=method>
<dt id=unittest.mock.Mock._get_child_mock>
<code class="sig-name descname">_get_child_mock</code><span class=sig-paren>(</span><em class=sig-param>**kw</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.Mock._get_child_mock title=永久链接至目标>¶</a></dt>
<dd><p>为属性和返回值创建子模拟。默认情况下，子模拟与父模拟的类型相同。mock的子类可能想要重写这个来定制子mock的生成方式。</p>
<p>对于不可调用模拟，将使用可调用变量（而不是任何自定义子类）。</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.called>
<code class="sig-name descname">called</code><a class=headerlink href=#unittest.mock.Mock.called title=永久链接至目标>¶</a></dt>
<dd><p>表示是否调用模拟对象的布尔值：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>True</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.call_count>
<code class="sig-name descname">call_count</code><a class=headerlink href=#unittest.mock.Mock.call_count title=永久链接至目标>¶</a></dt>
<dd><p>一个整数，告诉您模拟对象被调用的次数：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_count</span>
<span class=go>0</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_count</span>
<span class=go>2</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.return_value>
<code class="sig-name descname">return_value</code><a class=headerlink href=#unittest.mock.Mock.return_value title=永久链接至目标>¶</a></dt>
<dd><p>设置此值以配置通过调用模拟返回的值：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>'fish'</span>
</pre></div>
</div>
<p>默认返回值是一个模拟对象，您可以按常规方式配置它：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>attribute</span> <span class=o>=</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>Attribute</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock()()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> 也可以在构造函数中设置：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>return_value</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.side_effect>
<code class="sig-name descname">side_effect</code><a class=headerlink href=#unittest.mock.Mock.side_effect title=永久链接至目标>¶</a></dt>
<dd><p>这可以是调用模拟时要调用的函数、可ITerable或要引发的异常（类或实例）。</p>
<p>如果传入一个函数，将使用与mock相同的参数调用它，除非函数返回 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> 对mock的调用将返回函数返回的任何内容。如果函数返回 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> 然后模拟将返回其正常值（从 <a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> ）</p>
<p>如果传入一个iterable，它将用于检索迭代器，该迭代器必须在每次调用时生成一个值。该值可以是要引发的异常实例，也可以是从调用mock返回的值。 (<a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> 处理与功能案例相同）。</p>
<p>引发异常的模拟示例（用于测试API的异常处理）：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=ne>Exception</span><span class=p>(</span><span class=s1>'Boom!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>Exception</span><span>: </span><span class=n>Boom!</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 要返回值序列，请执行以下操作：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>(),</span> <span class=n>mock</span><span class=p>()</span>
<span class=go>(3, 2, 1)</span>
</pre></div>
</div>
<p>使用可调用：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>DEFAULT</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 不能在构造函数中设置。下面是一个示例，它将mock的值加上一个，并返回它：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>side_effect</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>value</span><span class=p>:</span> <span class=n>value</span> <span class=o>+</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>side_effect</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=go>4</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=o>-</span><span class=mi>8</span><span class=p>)</span>
<span class=go>-7</span>
</pre></div>
</div>
<p>设置 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 到 <code class="docutils literal notranslate"><span class=pre>None</span></code> 清除它：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>KeyError</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>KeyError</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.call_args>
<code class="sig-name descname">call_args</code><a class=headerlink href=#unittest.mock.Mock.call_args title=永久链接至目标>¶</a></dt>
<dd><p>这也不是 <code class="docutils literal notranslate"><span class=pre>None</span></code> （如果尚未调用模拟），或上次调用模拟时使用的参数。这将以元组的形式出现：第一个成员，也可以通过 <code class="docutils literal notranslate"><span class=pre>args</span></code> 属性，是用（或空元组）和第二个成员调用模拟的任何有序参数，也可以通过 <code class="docutils literal notranslate"><span class=pre>kwargs</span></code> 属性，是任何关键字参数（或空字典）。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>print</span><span class=p>(</span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=p>)</span>
<span class=go>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span> <span class=o>==</span> <span class=p>()</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call(3, 4)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span> <span class=o>==</span> <span class=p>((</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>),)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>args</span>
<span class=go>(3, 4)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>kwargs</span>
<span class=go>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=s1>'fish'</span><span class=p>,</span> <span class=nb>next</span><span class=o>=</span><span class=s1>'w00t!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span>
<span class=go>call(3, 4, 5, key='fish', next='w00t!')</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>args</span>
<span class=go>(3, 4, 5)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args</span><span class=o>.</span><span class=n>kwargs</span>
<span class=go>{'key': 'fish', 'next': 'w00t!'}</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a> 以及列表中的成员 <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a> ， <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 是 <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> 物体。这些是元组，因此可以对它们进行解包，以获取单个参数并做出更复杂的断言。见 <a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a> .</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.call_args_list>
<code class="sig-name descname">call_args_list</code><a class=headerlink href=#unittest.mock.Mock.call_args_list title=永久链接至目标>¶</a></dt>
<dd><p>这是按顺序对模拟对象进行的所有调用的列表（因此列表的长度是调用的次数）。在进行任何调用之前，它是一个空列表。这个 <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> 对象可用于方便地构造调用列表，以便与 <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=s1>'fish'</span><span class=p>,</span> <span class=nb>next</span><span class=o>=</span><span class=s1>'w00t!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args_list</span>
<span class=go>[call(), call(3, 4), call(key='fish', next='w00t!')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=p>[(),</span> <span class=p>((</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>),),</span> <span class=p>({</span><span class=s1>'key'</span><span class=p>:</span> <span class=s1>'fish'</span><span class=p>,</span> <span class=s1>'next'</span><span class=p>:</span> <span class=s1>'w00t!'</span><span class=p>},)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>call_args_list</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
<p>成员 <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a> 是 <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> 物体。可以将这些解包为元组以获取各个参数。见 <a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a> .</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.method_calls>
<code class="sig-name descname">method_calls</code><a class=headerlink href=#unittest.mock.Mock.method_calls title=永久链接至目标>¶</a></dt>
<dd><p>除了跟踪对自身的调用，mock还跟踪对方法和属性的调用，以及 <em>他们的</em> 方法和属性：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.method()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>property</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>attribute</span><span class=p>()</span>
<span class=go>&lt;Mock name='mock.property.method.attribute()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method_calls</span>
<span class=go>[call.method(), call.property.method.attribute()]</span>
</pre></div>
</div>
<p>成员 <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> 是 <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> 物体。可以将这些解包为元组以获取各个参数。见 <a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a> .</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.mock_calls>
<code class="sig-name descname">mock_calls</code><a class=headerlink href=#unittest.mock.Mock.mock_calls title=永久链接至目标>¶</a></dt>
<dd><p><a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 记录 <em>all</em> 调用模拟对象、其方法、魔力方法 <em>and</em> 返回值模拟。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span> <span class=o>=</span> <span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>first</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock.first()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>second</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.second()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>int</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock()()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>expected</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>call</span><span class=o>.</span><span class=n>first</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>),</span> <span class=n>call</span><span class=o>.</span><span class=n>second</span><span class=p>(),</span>
<span class=gp>... </span><span class=n>call</span><span class=o>.</span><span class=fm>__int__</span><span class=p>(),</span> <span class=n>call</span><span class=p>()(</span><span class=mi>1</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>expected</span>
<span class=go>True</span>
</pre></div>
</div>
<p>成员 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 是 <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-data docutils literal notranslate"><span class=pre>call</span></code></a> 物体。可以将这些解包为元组以获取各个参数。见 <a class="reference internal" href=#calls-as-tuples><span class="std std-ref">calls as tuples</span></a> .</p>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>路 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 记录是指在进行嵌套调用的情况下，不记录祖先调用的参数，因此始终比较相等：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>top</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span><span class=o>.</span><span class=n>bottom</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.top().bottom()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.top(a=3), call.top().bottom()]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>call</span><span class=o>.</span><span class=n>top</span><span class=p>(</span><span class=n>a</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>bottom</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.Mock.__class__>
<code class="sig-name descname">__class__</code><a class=headerlink href=#unittest.mock.Mock.__class__ title=永久链接至目标>¶</a></dt>
<dd><p>通常 <a class="reference internal" href=#unittest.mock.Mock.__class__ title=unittest.mock.Mock.__class__><code class="xref py py-attr docutils literal notranslate"><span class=pre>__class__</span></code></a> 对象的属性将返回其类型。对于一个模拟对象 <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> ， <code class="docutils literal notranslate"><span class=pre>__class__</span></code> 返回spec类。这允许模拟对象通过 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> 测试他们正在替换/伪装的对象为：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=nb>int</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.Mock.__class__ title=unittest.mock.Mock.__class__><code class="xref py py-attr docutils literal notranslate"><span class=pre>__class__</span></code></a> 可分配给，这允许模拟通过 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> 检查而不强制使用规范：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=vm>__class__</span> <span class=o>=</span> <span class=nb>dict</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=nb>dict</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
</dl>
</dl>
<dl class=class>
<dt id=unittest.mock.NonCallableMock>
<em class=property>class </em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">NonCallableMock</code><span class=sig-paren>(</span><em class=sig-param>spec=None</em>, <em class=sig-param>wraps=None</em>, <em class=sig-param>name=None</em>, <em class=sig-param>spec_set=None</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.NonCallableMock title=永久链接至目标>¶</a></dt>
<dd><p>不可调用的版本 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> . 构造函数参数的含义与 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> ，除了 <em>return_value</em> 和 <em>side_effect</em> 这对不可调用的模拟没有意义。</p>
</dl>
<p>将类或实例用作 <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> 或 <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec_set</span></code> 能够通过 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#isinstance title=isinstance><code class="xref py py-func docutils literal notranslate"><span class=pre>isinstance()</span></code></a> 测验：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>SomeClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=n>SomeClass</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec_set</span><span class=o>=</span><span class=n>SomeClass</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=n>SomeClass</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
<p>这个 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 类支持模拟魔术方法。见 <a class="reference internal" href=#magic-methods><span class="std std-ref">magic methods</span></a> 详细信息。</p>
<p>模拟课和 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 修饰符都采用任意关键字参数进行配置。对于 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> decorator将关键字传递给正在创建的模拟的构造函数。关键字参数用于配置模拟的属性：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>attribute</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=s1>'fish'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>attribute</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>other</span>
<span class=go>'fish'</span>
</pre></div>
</div>
<p>子模拟的返回值和副作用可以用同样的方式设置，使用点符号。由于不能在调用中直接使用点式名称，因此必须创建字典并使用 <code class="docutils literal notranslate"><span class=pre>**</span></code> ：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>attrs</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>some_attribute</span><span class=o>=</span><span class=s1>'eggs'</span><span class=p>,</span> <span class=o>**</span><span class=n>attrs</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>some_attribute</span>
<span class=go>'eggs'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p>一个可调用的模拟 <em>spec</em> （或） <em>spec_set</em> ）将在匹配对模拟的调用时自省规范对象的签名。因此，它可以匹配实际调用的参数，而不管它们是按位置传递的还是按名称传递的：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span> <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>f</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>c</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=go>&lt;Mock name='mock()' id='140161580456576'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>c</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</pre></div>
</div>
<p>这适用于 <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> ， <a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> ， <a class="reference internal" href=#unittest.mock.Mock.assert_has_calls title=unittest.mock.Mock.assert_has_calls><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_has_calls()</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.assert_any_call title=unittest.mock.Mock.assert_any_call><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_any_call()</span></code></a> .什么时候？ <a class="reference internal" href=#auto-speccing><span class="std std-ref">自聚焦</span></a> 它还将应用于模拟对象上的方法调用。</p>
<blockquote>
<div><div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>在指定和自动指定的模拟对象上添加了签名自省。</p>
</div>
</div></blockquote>
<dl class=class>
<dt id=unittest.mock.PropertyMock>
<em class=property>class </em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">PropertyMock</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.PropertyMock title=永久链接至目标>¶</a></dt>
<dd><p>拟用作类上的属性或其他描述符的模拟。 <a class="reference internal" href=#unittest.mock.PropertyMock title=unittest.mock.PropertyMock><code class="xref py py-class docutils literal notranslate"><span class=pre>PropertyMock</span></code></a> 提供 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__get__ title=object.__get__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__get__()</span></code></a> 和 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__set__ title=object.__set__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__set__()</span></code></a> 方法，以便在提取时指定返回值。</p>
<p>取A <a class="reference internal" href=#unittest.mock.PropertyMock title=unittest.mock.PropertyMock><code class="xref py py-class docutils literal notranslate"><span class=pre>PropertyMock</span></code></a> 来自对象的实例调用模拟，不带参数。设置它调用具有所设置值的模拟。：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=nd>@property</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=s1>'something'</span>
<span class=gp>... </span>    <span class=nd>@foo</span><span class=o>.</span><span class=n>setter</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Foo.foo'</span><span class=p>,</span> <span class=n>new_callable</span><span class=o>=</span><span class=n>PropertyMock</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>mock_foo</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'mockity-mock'</span>
<span class=gp>... </span>    <span class=n>this_foo</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>()</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=n>this_foo</span><span class=o>.</span><span class=n>foo</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>this_foo</span><span class=o>.</span><span class=n>foo</span> <span class=o>=</span> <span class=mi>6</span>
<span class=gp>...</span>
<span class=go>mockity-mock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_foo</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(), call(6)]</span>
</pre></div>
</div>
</dl>
<p>由于模拟属性的存储方式，您不能直接附加 <a class="reference internal" href=#unittest.mock.PropertyMock title=unittest.mock.PropertyMock><code class="xref py py-class docutils literal notranslate"><span class=pre>PropertyMock</span></code></a> 模拟对象。相反，您可以将其附加到模拟类型对象：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>p</span> <span class=o>=</span> <span class=n>PropertyMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=n>m</span><span class=p>)</span><span class=o>.</span><span class=n>foo</span> <span class=o>=</span> <span class=n>p</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>foo</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>p</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>()</span>
</pre></div>
</div>
<dl class=class>
<dt id=unittest.mock.AsyncMock>
<em class=property>class </em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">AsyncMock</code><span class=sig-paren>(</span><em class=sig-param>spec=None</em>, <em class=sig-param>side_effect=None</em>, <em class=sig-param>return_value=DEFAULT</em>, <em class=sig-param>wraps=None</em>, <em class=sig-param>name=None</em>, <em class=sig-param>spec_set=None</em>, <em class=sig-param>unsafe=False</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock title=永久链接至目标>¶</a></dt>
<dd><p>的异步版本 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> . 这个 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 对象的行为将使对象被识别为异步函数，并且调用的结果是可等待的。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>iscoroutinefunction</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>inspect</span><span class=o>.</span><span class=n>isawaitable</span><span class=p>(</span><span class=n>mock</span><span class=p>())</span>  
<span class=go>True</span>
</pre></div>
</div>
<p>结果 <code class="docutils literal notranslate"><span class=pre>mock()</span></code> 是一个异步函数，其结果为 <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> 或 <code class="docutils literal notranslate"><span class=pre>return_value</span></code> 在等待之后：</p>
<ul class=simple>
<li><p>如果 <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> 是一个函数，异步函数将返回该函数的结果，</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> 是异常，异步函数将引发异常，</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> 是iterable，async函数将返回iterable的下一个值，但是，如果结果序列已用完， <code class="docutils literal notranslate"><span class=pre>StopAsyncIteration</span></code> 立即升起，</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class=pre>side_effect</span></code> 未定义，异步函数将返回 <code class="docutils literal notranslate"><span class=pre>return_value</span></code> 因此，在默认情况下，异步函数返回一个新的 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 对象。</p></li>
</ul>
<p>设置 <em>spec</em> A的 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 或 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 到异步函数将导致调用后返回协程对象。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>async_func</span><span class=p>():</span> <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>async_func</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span>
<span class=go>&lt;MagicMock spec='function' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>()</span>  
<span class=go>&lt;coroutine object AsyncMockMixin._mock_call at ...&gt;</span>
</pre></div>
</div>
<p>设置 <em>spec</em> A的 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> ， <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 或 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 对于具有异步和同步函数的类，将自动检测同步函数并将其设置为 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> （如果父模拟是 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 或 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 或 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> （如果父模拟是 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> ). 所有异步函数将 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>ExampleClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>sync_foo</span><span class=p>():</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>... </span>    <span class=k>async</span> <span class=k>def</span> <span class=nf>async_foo</span><span class=p>():</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>a_mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>(</span><span class=n>ExampleClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>a_mock</span><span class=o>.</span><span class=n>sync_foo</span>
<span class=go>&lt;MagicMock name='mock.sync_foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>a_mock</span><span class=o>.</span><span class=n>async_foo</span>
<span class=go>&lt;AsyncMock name='mock.async_foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>ExampleClass</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>sync_foo</span>
<span class=go>&lt;Mock name='mock.sync_foo' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>async_foo</span>
<span class=go>&lt;AsyncMock name='mock.async_foo' id='...'&gt;</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited>
<code class="sig-name descname">assert_awaited</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited title=永久链接至目标>¶</a></dt>
<dd><p>断言至少等待了一次模拟。注意，这与已调用的对象 <code class="docutils literal notranslate"><span class=pre>await</span></code> 必须使用关键字：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=n>coroutine_mock</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>coroutine_mock</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>coroutine_mock</span> <span class=o>=</span> <span class=n>mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>called</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected mock to have been awaited.</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=n>coroutine_mock</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited</span><span class=p>()</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited_once>
<code class="sig-name descname">assert_awaited_once</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited_once title=永久链接至目标>¶</a></dt>
<dd><p>断言模拟模型正等着一次。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_once</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>assert_awaited_once</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected mock to have been awaited once. Awaited 2 times.</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited_with>
<code class="sig-name descname">assert_awaited_with</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited_with title=永久链接至目标>¶</a></dt>
<dd><p>断言最后一个等待是带有指定参数的。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_with</span><span class=p>(</span><span class=s1>'other'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>expected call not found.</span>
<span class=go>Expected: mock('other')</span>
<span class=go>Actual: mock('foo', bar='bar')</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_awaited_once_with>
<code class="sig-name descname">assert_awaited_once_with</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_awaited_once_with title=永久链接至目标>¶</a></dt>
<dd><p>断言模拟正等待一次，并使用指定的参数。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_awaited_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected mock to have been awaited once. Awaited 2 times.</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_any_await>
<code class="sig-name descname">assert_any_await</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_any_await title=永久链接至目标>¶</a></dt>
<dd><p>断言已使用指定的参数等待模拟。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'hello'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_any_await</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_any_await</span><span class=p>(</span><span class=s1>'other'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>mock('other') await not found</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_has_awaits>
<code class="sig-name descname">assert_has_awaits</code><span class=sig-paren>(</span><em class=sig-param>calls</em>, <em class=sig-param>any_order=False</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_has_awaits title=永久链接至目标>¶</a></dt>
<dd><p>断言模拟已通过指定的调用等待。这个 <a class="reference internal" href=#unittest.mock.AsyncMock.await_args_list title=unittest.mock.AsyncMock.await_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args_list</span></code></a> 检查列表是否有等待。</p>
<p>如果 <em>any_order</em> 如果为false，则等待必须是连续的。在指定的等待之前或之后可以有额外的呼叫。</p>
<p>如果 <em>any_order</em> 是真的，那么等待可以按任何顺序进行，但它们必须都出现在 <a class="reference internal" href=#unittest.mock.AsyncMock.await_args_list title=unittest.mock.AsyncMock.await_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args_list</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>calls</span> <span class=o>=</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=s2>"foo"</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=s2>"bar"</span><span class=p>)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_awaits</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
<span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Awaits not found.</span>
<span class=go>Expected: [call('foo'), call('bar')]</span>
<span class=go>Actual: []</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_has_awaits</span><span class=p>(</span><span class=n>calls</span><span class=p>)</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.assert_not_awaited>
<code class="sig-name descname">assert_not_awaited</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.assert_not_awaited title=永久链接至目标>¶</a></dt>
<dd><p>断言这个模拟从未被等待过。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_not_awaited</span><span class=p>()</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.AsyncMock.reset_mock>
<code class="sig-name descname">reset_mock</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.AsyncMock.reset_mock title=永久链接至目标>¶</a></dt>
<dd><p>见 <a class="reference internal" href=#unittest.mock.Mock.reset_mock title=unittest.mock.Mock.reset_mock><code class="xref py py-func docutils literal notranslate"><span class=pre>Mock.reset_mock()</span></code></a> . 同时设置 <a class="reference internal" href=#unittest.mock.AsyncMock.await_count title=unittest.mock.AsyncMock.await_count><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_count</span></code></a> 到0， <a class="reference internal" href=#unittest.mock.AsyncMock.await_args title=unittest.mock.AsyncMock.await_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args</span></code></a> 到无，并清除 <a class="reference internal" href=#unittest.mock.AsyncMock.await_args_list title=unittest.mock.AsyncMock.await_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>await_args_list</span></code></a> .</p>
</dl>
<dl class=attribute>
<dt id=unittest.mock.AsyncMock.await_count>
<code class="sig-name descname">await_count</code><a class=headerlink href=#unittest.mock.AsyncMock.await_count title=永久链接至目标>¶</a></dt>
<dd><p>一个整数，用于跟踪模拟对象等待的次数。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_count</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_count</span>
<span class=go>2</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.AsyncMock.await_args>
<code class="sig-name descname">await_args</code><a class=headerlink href=#unittest.mock.AsyncMock.await_args title=永久链接至目标>¶</a></dt>
<dd><p>这也不是 <code class="docutils literal notranslate"><span class=pre>None</span></code> （如果没有等待模拟），或模拟最后等待的论点。功能与 <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args</span>
<span class=go>call('foo')</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args</span>
<span class=go>call('bar')</span>
</pre></div>
</div>
</dl>
<dl class=attribute>
<dt id=unittest.mock.AsyncMock.await_args_list>
<code class="sig-name descname">await_args_list</code><a class=headerlink href=#unittest.mock.AsyncMock.await_args_list title=永久链接至目标>¶</a></dt>
<dd><p>这是按顺序对模拟对象进行的所有等待的列表（因此列表的长度是等待的次数）。在等待之前，它是一个空列表。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>AsyncMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>await</span> <span class=n>mock</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args_list</span>
<span class=go>[]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args_list</span>
<span class=go>[call('foo')]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>await_args_list</span>
<span class=go>[call('foo'), call('bar')]</span>
</pre></div>
</div>
</dl>
</dl>
<div class=section id=calling>
<h3>调用<a class=headerlink href=#calling title=永久链接至标题>¶</a></h3>
<p>模拟对象是可调用的。调用将返回设置为 <a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> 属性。默认的返回值是一个新的模拟对象；它是在第一次访问返回值时创建的（显式地或通过调用模拟对象），但它是存储的，并且每次返回相同的值。</p>
<p>对对象的调用将记录在以下属性中 <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a> .</p>
<p>如果 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 如果设置了，则会在记录调用后调用，因此如果 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 引发异常调用仍被记录。</p>
<p>使模拟在调用时引发异常的最简单方法是 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 异常类或实例：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=ne>IndexError</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>IndexError</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(1, 2, 3)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=ne>KeyError</span><span class=p>(</span><span class=s1>'Bang!'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=s1>'two'</span><span class=p>,</span> <span class=s1>'three'</span><span class=p>,</span> <span class=s1>'four'</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span><span>: </span><span class=n>'Bang!'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(1, 2, 3), call('two', 'three', 'four')]</span>
</pre></div>
</div>
<p>如果 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 是一个函数，那么该函数返回的是对模拟返回的调用。这个 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 使用与mock相同的参数调用函数。这允许您根据输入动态更改调用的返回值：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=n>value</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>value</span> <span class=o>+</span> <span class=mi>1</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>side_effect</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=go>2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call(1), call(2)]</span>
</pre></div>
</div>
<p>如果您希望mock仍然返回默认的返回值（一个新的mock），或者任何设置的返回值，那么有两种方法可以做到这一点。要么返回 <code class="xref py py-attr docutils literal notranslate"><span class=pre>mock.return_value</span></code> 从内部 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 或返回 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> ：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>m</span><span class=o>.</span><span class=n>return_value</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=mi>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>DEFAULT</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
</pre></div>
</div>
<p>删除一个 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> ，并返回默认行为，设置 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 到 <code class="docutils literal notranslate"><span class=pre>None</span></code> ：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=mi>6</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>side_effect</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=mi>3</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=n>side_effect</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>side_effect</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>6</span>
</pre></div>
</div>
<p>这个 <code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code> 也可以是任何无法识别的对象。对mock的重复调用将从iterable返回值（直到iterable耗尽并且 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#StopIteration title=StopIteration><code class="xref py py-exc docutils literal notranslate"><span class=pre>StopIteration</span></code></a> 提出：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>StopIteration</span>
</pre></div>
</div>
<p>如果iterable的任何成员是异常，则将引发这些成员而不是返回：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>iterable</span> <span class=o>=</span> <span class=p>(</span><span class=mi>33</span><span class=p>,</span> <span class=ne>ValueError</span><span class=p>,</span> <span class=mi>66</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>side_effect</span><span class=o>=</span><span class=n>iterable</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>33</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>ValueError</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=go>66</span>
</pre></div>
</div>
</div>
<div class=section id=deleting-attributes>
<span id=id2></span><h3>删除属性<a class=headerlink href=#deleting-attributes title=永久链接至标题>¶</a></h3>
<p>模拟对象根据需要创建属性。这允许它们假装成任何类型的对象。</p>
<p>您可能需要一个模拟对象返回 <code class="docutils literal notranslate"><span class=pre>False</span></code> 到A <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#hasattr title=hasattr><code class="xref py py-func docutils literal notranslate"><span class=pre>hasattr()</span></code></a> 调用或提出 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> 获取属性时。您可以通过将对象作为 <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> 但这并不总是方便的。</p>
<p>通过删除属性来“阻塞”它们。一旦删除，访问属性将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=s1>'m'</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>del</span> <span class=n>mock</span><span class=o>.</span><span class=n>m</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>mock</span><span class=p>,</span> <span class=s1>'m'</span><span class=p>)</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>del</span> <span class=n>mock</span><span class=o>.</span><span class=n>f</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>f</span>
<span class=gt>Traceback (most recent call last):</span>
    <span class=o>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>f</span>
</pre></div>
</div>
</div>
<div class=section id=mock-names-and-the-name-attribute>
<h3>模拟名称和名称属性<a class=headerlink href=#mock-names-and-the-name-attribute title=永久链接至标题>¶</a></h3>
<p>因为“name”是 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 构造函数，如果您希望模拟对象具有“name”属性，则不能在创建时将其传入。有两种选择。一种选择是使用 <a class="reference internal" href=#unittest.mock.Mock.configure_mock title=unittest.mock.Mock.configure_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>configure_mock()</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>configure_mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'my_name'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>name</span>
<span class=go>'my_name'</span>
</pre></div>
</div>
<p>一个更简单的选项是在模拟创建之后简单地设置“name”属性：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=s2>"foo"</span>
</pre></div>
</div>
</div>
<div class=section id=attaching-mocks-as-attributes>
<h3>将模拟附加为属性<a class=headerlink href=#attaching-mocks-as-attributes title=永久链接至标题>¶</a></h3>
<p>当您将一个mock附加为另一个mock的属性（或作为返回值）时，它将成为该mock的“子级”。对子项的调用记录在 <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 父级的属性。这对于配置子模拟，然后将它们附加到父模拟，或将模拟附加到记录所有对子模拟的调用并允许您对模拟之间的调用顺序作出断言的父模拟很有用：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child1</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child2</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>child1</span> <span class=o>=</span> <span class=n>child1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>child2</span> <span class=o>=</span> <span class=n>child2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child1</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>child2</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.child1(1), call.child2(2)]</span>
</pre></div>
</div>
<p>例外情况是，如果模拟模型有一个名称。如果出于某种原因你不想这样做的话，这就允许你阻止“养育”。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>not_a_child</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'not-a-child'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>attribute</span> <span class=o>=</span> <span class=n>not_a_child</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>attribute</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='not-a-child()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[]</span>
</pre></div>
</div>
<p>为您创建的模拟 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 自动命名。要将具有名称的模拟附加到父级，请使用 <a class="reference internal" href=#unittest.mock.Mock.attach_mock title=unittest.mock.Mock.attach_mock><code class="xref py py-meth docutils literal notranslate"><span class=pre>attach_mock()</span></code></a> 方法：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>thing1</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing2</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing1'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=k>as</span> <span class=n>child1</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing2'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span> <span class=k>as</span> <span class=n>child2</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>parent</span><span class=o>.</span><span class=n>attach_mock</span><span class=p>(</span><span class=n>child1</span><span class=p>,</span> <span class=s1>'child1'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>parent</span><span class=o>.</span><span class=n>attach_mock</span><span class=p>(</span><span class=n>child2</span><span class=p>,</span> <span class=s1>'child2'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>child1</span><span class=p>(</span><span class=s1>'one'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=n>child2</span><span class=p>(</span><span class=s1>'two'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>parent</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call.child1('one'), call.child2('two')]</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class=label id=id3><span class=brackets><a class=fn-backref href=#id1>1</a></span></dt>
<dd><p>唯一的例外是magic方法和属性（那些具有前导和尾随双下划线的方法和属性）。mock不创建这些，而是引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> . 这是因为解释器通常会隐式地请求这些方法，并 <em>very</em> 当一个新的模拟对象需要一个魔法方法时，它会感到困惑。如果您需要魔法方法支持，请参阅 <a class="reference internal" href=#magic-methods><span class="std std-ref">magic methods</span></a> .</p>
</dd>
</dl>
</div>
</div>
<div class=section id=the-patchers>
<h2>补丁程序<a class=headerlink href=#the-patchers title=永久链接至标题>¶</a></h2>
<p>补丁装饰器仅用于在对象装饰的功能范围内修补对象。即使出现异常，它们也会自动为您处理解锁。所有这些函数也可以在WITH语句中使用，或者作为类修饰符使用。</p>
<div class=section id=patch>
<h3>补丁<a class=headerlink href=#patch title=永久链接至标题>¶</a></h3>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>关键是在正确的命名空间中进行修补。见章节 <a class="reference internal" href=#id6>where to patch</a> .</p>
</div>
<dl class=function>
<dt id=unittest.mock.patch>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">patch</code><span class=sig-paren>(</span><em class=sig-param>target</em>, <em class=sig-param>new=DEFAULT</em>, <em class=sig-param>spec=None</em>, <em class=sig-param>create=False</em>, <em class=sig-param>spec_set=None</em>, <em class=sig-param>autospec=None</em>, <em class=sig-param>new_callable=None</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch title=永久链接至目标>¶</a></dt>
<dd><p><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 充当函数修饰器、类修饰器或上下文管理器。在函数体或WITH语句中， <em>目标</em> 用一个 <em>new</em> 对象。当函数/WITH语句退出时，修补程序将撤消。</p>
<p>如果 <em>new</em> 忽略，则目标替换为 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 如果修补对象是异步函数或 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 否则。如果 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 用作装饰和 <em>new</em> 如果省略，则创建的mock作为附加参数传递给修饰函数。如果 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 用作上下文管理器，创建的模拟由上下文管理器返回。</p>
<p><em>目标</em> 应为窗体中的字符串 <code class="docutils literal notranslate"><span class=pre>'package.module.ClassName'</span></code> . 这个 <em>目标</em> 被导入，指定的对象替换为 <em>new</em> 对象，所以 <em>目标</em> 必须能够从您调用的环境中导入 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 从。目标在执行修饰函数时导入，而不是在修饰时导入。</p>
<p>这个 <em>spec</em> 和 <em>spec_set</em> 关键字参数传递给 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 如果补丁程序正在为您创建一个。</p>
<p>另外你可以通过 <code class="docutils literal notranslate"><span class=pre>spec=True</span></code> 或 <code class="docutils literal notranslate"><span class=pre>spec_set=True</span></code> ，这将导致修补程序传入被模拟为spec/spec_set对象的对象。</p>
<p><em>new_callable</em> 允许您指定将被调用以创建 <em>new</em> 对象。默认 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 用于异步函数和 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 剩下的。</p>
<p>一种更强大的 <em>spec</em> 是 <em>AutoPoC</em> . 如果你设置 <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> 然后将使用替换对象的规范创建模拟。模拟的所有属性也将具有被替换对象的相应属性的规范。模拟的方法和函数将检查其参数，并将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#TypeError title=TypeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>TypeError</span></code></a> 如果用错误的签名调用他们。对于替换类的模拟，它们的返回值（“instance”）将具有与类相同的规范。见 <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 功能和 <a class="reference internal" href=#auto-speccing><span class="std std-ref">自聚焦</span></a> .</p>
<p>而不是 <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> 你可以通过 <code class="docutils literal notranslate"><span class=pre>autospec=some_object</span></code> 使用任意对象作为规范，而不是被替换的对象。</p>
<p>默认情况下 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 将无法替换不存在的属性。如果你通过 <code class="docutils literal notranslate"><span class=pre>create=True</span></code> 如果属性不存在，则在调用修补函数时，patch将为您创建该属性，并在修补函数退出后再次将其删除。这对于根据生产代码在运行时创建的属性编写测试很有用。默认情况下它是关闭的，因为它可能很危险。打开它之后，您就可以针对实际不存在的API编写通过的测试了！</p>
<div class="admonition note">
<p class=admonition-title>注解</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span>如果您正在修补模块中的内置组件，则无需通过 <code class="docutils literal notranslate"><span class=pre>create=True</span></code> ，将默认添加。</p>
</div>
</div>
<p>补丁可以用作 <code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code> 类修饰器。它通过修饰类中的每个测试方法来工作。当测试方法共享一个公共补丁集时，这会减少样板代码。 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 通过查找以开头的方法名查找测试 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> . 默认情况下，这是 <code class="docutils literal notranslate"><span class=pre>'test'</span></code> ，与之匹配 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/unittest.html#module-unittest title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class=pre>unittest</span></code></a> 查找测试。您可以通过设置指定可选前缀 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> .</p>
<p>修补程序可以用作上下文管理器，带有WITH语句。这里的修补应用于WITH语句后面的缩进块。如果使用“as”，则修补后的对象将绑定到“as”后面的名称；如果 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 正在为您创建模拟对象。</p>
<p><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 接受任意关键字参数。这些将传递给 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 如果修补对象是异步的，则 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 否则或 <em>new_callable</em> 如果指定。</p>
<p><code class="docutils literal notranslate"><span class=pre>patch.dict(...)</span></code> ， <code class="docutils literal notranslate"><span class=pre>patch.multiple(...)</span></code> 和 <code class="docutils literal notranslate"><span class=pre>patch.object(...)</span></code> 可用于其他用例。</p>
</dl>
<p><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 作为函数修饰器，为您创建模拟并将其传递到修饰函数：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'__main__.SomeClass'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>function</span><span class=p>(</span><span class=n>normal_argument</span><span class=p>,</span> <span class=n>mock_class</span><span class=p>):</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=n>mock_class</span> <span class=ow>is</span> <span class=n>SomeClass</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>function</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>
<span class=go>True</span>
</pre></div>
</div>
<p>修补类将类替换为 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> <em>实例</em> . 如果类在被测试的代码中被实例化，那么它将是 <a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> 将要使用的模拟。</p>
<p>如果类被实例化多次，则可以使用 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 每次返回一个新的模拟。或者，您可以设置 <em>return_value</em> 做你想做的任何事。</p>
<p>配置的方法的返回值 <em>实例</em> 在修补类上，您必须在 <code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code> . 例如：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Class</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Class'</span><span class=p>)</span> <span class=k>as</span> <span class=n>MockClass</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>instance</span> <span class=o>=</span> <span class=n>MockClass</span><span class=o>.</span><span class=n>return_value</span>
<span class=gp>... </span>    <span class=n>instance</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'foo'</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>Class</span><span class=p>()</span> <span class=ow>is</span> <span class=n>instance</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>Class</span><span class=p>()</span><span class=o>.</span><span class=n>method</span><span class=p>()</span> <span class=o>==</span> <span class=s1>'foo'</span>
<span class=gp>...</span>
</pre></div>
</div>
<p>如果你使用 <em>spec</em> 或 <em>spec_set</em> 和 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 正在替换 <em>classes</em> ，则创建的模拟的返回值将具有相同的规范：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>Original</span> <span class=o>=</span> <span class=n>Class</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Class'</span><span class=p>,</span> <span class=n>spec</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MockClass</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>instance</span> <span class=o>=</span> <span class=n>MockClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>instance</span><span class=p>,</span> <span class=n>Original</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
</pre></div>
</div>
<p>这个 <em>new_callable</em> 如果要使用默认的替代类，参数非常有用 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 为创建的模拟。例如，如果你想要 <a class="reference internal" href=#unittest.mock.NonCallableMock title=unittest.mock.NonCallableMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMock</span></code></a> 使用：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing'</span><span class=p>,</span> <span class=n>new_callable</span><span class=o>=</span><span class=n>NonCallableMock</span><span class=p>)</span> <span class=k>as</span> <span class=n>mock_thing</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>thing</span> <span class=ow>is</span> <span class=n>mock_thing</span>
<span class=gp>... </span>    <span class=n>thing</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>TypeError</span><span>: </span><span class=n>'NonCallableMock' object is not callable</span>
</pre></div>
</div>
<p>另一个用例可能是用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/io.html#io.StringIO title=io.StringIO><code class="xref py py-class docutils literal notranslate"><span class=pre>io.StringIO</span></code></a> 实例：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>io</span> <span class=kn>import</span> <span class=n>StringIO</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>foo</span><span class=p>():</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=s1>'Something'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.stdout'</span><span class=p>,</span> <span class=n>new_callable</span><span class=o>=</span><span class=n>StringIO</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_stdout</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>foo</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>mock_stdout</span><span class=o>.</span><span class=n>getvalue</span><span class=p>()</span> <span class=o>==</span> <span class=s1>'Something</span><span class=se>\n</span><span class=s1>'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<p>什么时候？ <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 正在为您创建一个模拟，通常您需要做的第一件事是配置模拟。其中一些配置可以在调用修补程序时完成。您传递到调用中的任意关键字将用于在创建的模拟上设置属性：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing'</span><span class=p>,</span> <span class=n>first</span><span class=o>=</span><span class=s1>'one'</span><span class=p>,</span> <span class=n>second</span><span class=o>=</span><span class=s1>'two'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>first</span>
<span class=go>'one'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>second</span>
<span class=go>'two'</span>
</pre></div>
</div>
<p>以及创建的模拟属性上的属性，如 <a class="reference internal" href=#unittest.mock.Mock.return_value title=unittest.mock.Mock.return_value><code class="xref py py-attr docutils literal notranslate"><span class=pre>return_value</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> ，也可以配置子模拟的。这些作为关键字参数直接传递在语法上是无效的，但是使用这些作为关键字的字典仍然可以扩展为 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 调用使用 <code class="docutils literal notranslate"><span class=pre>**</span></code> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>config</span> <span class=o>=</span> <span class=p>{</span><span class=s1>'method.return_value'</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>'other.side_effect'</span><span class=p>:</span> <span class=ne>KeyError</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.thing'</span><span class=p>,</span> <span class=o>**</span><span class=n>config</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=go>3</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_thing</span><span class=o>.</span><span class=n>other</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>KeyError</span>
</pre></div>
</div>
<p>默认情况下，尝试修补不存在的模块（或类中的方法或属性）中的函数将失败 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.non_existing_attribute'</span><span class=p>,</span> <span class=mi>42</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>sys</span><span class=o>.</span><span class=n>non_existing_attribute</span> <span class=o>==</span> <span class=mi>42</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>&lt;module 'sys' (built-in)&gt; does not have the attribute 'non_existing'</span>
</pre></div>
</div>
<p>但加入 <code class="docutils literal notranslate"><span class=pre>create=True</span></code> 在召唤 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 将使前面的示例按预期工作：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.non_existing_attribute'</span><span class=p>,</span> <span class=mi>42</span><span class=p>,</span> <span class=n>create</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_stdout</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>sys</span><span class=o>.</span><span class=n>non_existing_attribute</span> <span class=o>==</span> <span class=mi>42</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 现在返回一个 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 如果目标是异步函数。</p>
</div>
</div>
<div class=section id=patch-object>
<h3>patch.object<a class=headerlink href=#patch-object title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.patch.object>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">object</code><span class=sig-paren>(</span><em class=sig-param>target</em>, <em class=sig-param>attribute</em>, <em class=sig-param>new=DEFAULT</em>, <em class=sig-param>spec=None</em>, <em class=sig-param>create=False</em>, <em class=sig-param>spec_set=None</em>, <em class=sig-param>autospec=None</em>, <em class=sig-param>new_callable=None</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.object title=永久链接至目标>¶</a></dt>
<dd><p>修补命名成员（ <em>属性</em> ）在一个物体上（ <em>目标</em> ）模拟物体。</p>
<p><a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 可以用作修饰器、类修饰器或上下文管理器。参数 <em>new</em> ， <em>spec</em> ， <em>创造</em> ， <em>spec_set</em> ， <em>AutoPoC</em> 和 <em>new_callable</em> 含义与 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> . 类似于 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> ， <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 采用任意关键字参数来配置它创建的模拟对象。</p>
<p>当用作类修饰器时 <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 荣誉称号 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> 选择要封装的方法。</p>
</dl>
<p>你可以打任何一个调用 <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 有三个或两个参数。三参数形式包括要修补的对象、属性名和要用其替换属性的对象。</p>
<p>使用两个参数形式调用时，省略替换对象，并为您创建一个模拟，并作为附加参数传递给修饰函数：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'class_method'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_method</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>SomeClass</span><span class=o>.</span><span class=n>class_method</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>mock_method</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
</pre></div>
</div>
<p><em>spec</em> ， <em>创造</em> 其他的参数 <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 与它们的含义相同 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> .</p>
</div>
<div class=section id=patch-dict>
<h3>patch.dict<a class=headerlink href=#patch-dict title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.patch.dict>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">dict</code><span class=sig-paren>(</span><em class=sig-param>in_dict</em>, <em class=sig-param>values=()</em>, <em class=sig-param>clear=False</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.dict title=永久链接至目标>¶</a></dt>
<dd><p>修补字典或类似字典的对象，并在测试后将字典恢复到原始状态。</p>
<p><em>in_dict</em> 可以是字典或类似于映射的容器。如果它是一个映射，那么它必须至少支持获取、设置和删除项以及遍历键。</p>
<p><em>in_dict</em> 也可以是一个指定字典名称的字符串，然后通过导入它来获取该名称。</p>
<p><em>价值观</em> 可以是要在字典中设置的值的字典。 <em>价值观</em> 也可以是 <code class="docutils literal notranslate"><span class=pre>(key,</span> <span class=pre>value)</span></code> 对。</p>
<p>如果 <em>清楚的</em> 如果为true，则在设置新值之前将清除字典。</p>
<p><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 也可以使用任意关键字参数调用以在字典中设置值。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 现在返回作为上下文管理器使用的修补字典。</p>
</div>
</dl>
<p><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 可以用作上下文管理器、装饰器或类装饰器：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>})</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{}</span>
</pre></div>
</div>
<p>当用作类修饰器时 <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 荣誉称号 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> （默认为 <code class="docutils literal notranslate"><span class=pre>'test'</span></code> )选择要包装的方法：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>os</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>unittest</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest.mock</span> <span class=kn>import</span> <span class=n>patch</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'os.environ'</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>})</span>
<span class=gp>... </span><span class=k>class</span> <span class=nc>TestSample</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_sample</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>assertEqual</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s1>'newkey'</span><span class=p>],</span> <span class=s1>'newvalue'</span><span class=p>)</span>
</pre></div>
</div>
<p>如果要在测试中使用不同的前缀，可以通过设置将不同的前缀通知修补程序 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> . 有关如何更改see值的详细信息 <a class="reference internal" href=#test-prefix><span class="std std-ref">TEST_PREFIX</span></a> .</p>
<p><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 可以用于向字典中添加成员，也可以简单地让测试更改字典，并确保在测试结束时还原字典。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=p>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>foo</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>})</span> <span class=k>as</span> <span class=n>patched_foo</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>patched_foo</span> <span class=o>==</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}</span>
<span class=gp>... </span>    <span class=c1># You can add, update or delete keys of foo (or patched_foo, it's the same dict)</span>
<span class=gp>... </span>    <span class=n>patched_foo</span><span class=p>[</span><span class=s1>'spam'</span><span class=p>]</span> <span class=o>=</span> <span class=s1>'eggs'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>foo</span> <span class=o>==</span> <span class=p>{}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>patched_foo</span> <span class=o>==</span> <span class=p>{}</span>
</pre></div>
</div>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>import</span> <span class=nn>os</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'os.environ'</span><span class=p>,</span> <span class=p>{</span><span class=s1>'newkey'</span><span class=p>:</span> <span class=s1>'newvalue'</span><span class=p>}):</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=p>[</span><span class=s1>'newkey'</span><span class=p>])</span>
<span class=gp>...</span>
<span class=go>newvalue</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=s1>'newkey'</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span>
</pre></div>
</div>
<p>关键字可用于 <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 调用以设置字典中的值：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mymodule</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mymodule</span><span class=o>.</span><span class=n>function</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=s1>'sys.modules'</span><span class=p>,</span> <span class=n>mymodule</span><span class=o>=</span><span class=n>mymodule</span><span class=p>):</span>
<span class=gp>... </span>    <span class=kn>import</span> <span class=nn>mymodule</span>
<span class=gp>... </span>    <span class=n>mymodule</span><span class=o>.</span><span class=n>function</span><span class=p>(</span><span class=s1>'some'</span><span class=p>,</span> <span class=s1>'args'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=go>'fish'</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 可以与实际上不是字典的类似字典的对象一起使用。它们至少必须支持项目获取、设置、删除以及迭代或成员资格测试。这对应于魔法方法 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__getitem__ title=object.__getitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__getitem__()</span></code></a> ， <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__setitem__ title=object.__setitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__setitem__()</span></code></a> ， <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__delitem__ title=object.__delitem__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__delitem__()</span></code></a> 而且 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__iter__ title=object.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a> 或 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__contains__ title=object.__contains__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__contains__()</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Container</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>values</span> <span class=o>=</span> <span class=p>{}</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>[</span><span class=n>name</span><span class=p>]</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__setitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>[</span><span class=n>name</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__delitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>[</span><span class=n>name</span><span class=p>]</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>iter</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>values</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=n>Container</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span><span class=p>[</span><span class=s1>'one'</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>dict</span><span class=p>(</span><span class=n>thing</span><span class=p>,</span> <span class=n>one</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>two</span><span class=o>=</span><span class=mi>3</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>thing</span><span class=p>[</span><span class=s1>'one'</span><span class=p>]</span> <span class=o>==</span> <span class=mi>2</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>thing</span><span class=p>[</span><span class=s1>'two'</span><span class=p>]</span> <span class=o>==</span> <span class=mi>3</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>thing</span><span class=p>[</span><span class=s1>'one'</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=nb>list</span><span class=p>(</span><span class=n>thing</span><span class=p>)</span> <span class=o>==</span> <span class=p>[</span><span class=s1>'one'</span><span class=p>]</span>
</pre></div>
</div>
</div>
<div class=section id=patch-multiple>
<h3>patch.multiple<a class=headerlink href=#patch-multiple title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.patch.multiple>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">multiple</code><span class=sig-paren>(</span><em class=sig-param>target</em>, <em class=sig-param>spec=None</em>, <em class=sig-param>create=False</em>, <em class=sig-param>spec_set=None</em>, <em class=sig-param>autospec=None</em>, <em class=sig-param>new_callable=None</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.multiple title=永久链接至目标>¶</a></dt>
<dd><p>在一次调用中执行多个修补程序。它将要修补的对象（作为对象或通过导入获取对象的字符串）和修补程序的关键字参数：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=n>settings</span><span class=p>,</span> <span class=n>FIRST_PATCH</span><span class=o>=</span><span class=s1>'one'</span><span class=p>,</span> <span class=n>SECOND_PATCH</span><span class=o>=</span><span class=s1>'two'</span><span class=p>):</span>
    <span class=o>...</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> 如果你想要的话，作为价值 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 为您创建模拟。在这种情况下，创建的mock通过关键字传递到修饰函数，当 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 用作上下文管理器。</p>
<p><a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 可以用作修饰器、类修饰器或上下文管理器。参数 <em>spec</em> ， <em>spec_set</em> ， <em>创造</em> ， <em>AutoPoC</em> 和 <em>new_callable</em> 含义与 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> . 这些参数将应用于 <em>all</em> 补丁通过 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> .</p>
<p>当用作类修饰器时 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 荣誉称号 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> 选择要封装的方法。</p>
</dl>
<p>如果你想要 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 要为您创建模拟，则可以使用 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> 作为价值。如果你使用 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 作为一个装饰器，然后创建的模拟通过关键字传递到装饰函数中。：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>thing</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>other</span> <span class=o>=</span> <span class=nb>object</span><span class=p>()</span>

<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=s1>'__main__'</span><span class=p>,</span> <span class=n>thing</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test_function</span><span class=p>(</span><span class=n>thing</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>thing</span><span class=p>,</span> <span class=n>MagicMock</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>other</span><span class=p>,</span> <span class=n>MagicMock</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test_function</span><span class=p>()</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 可以与其他 <code class="docutils literal notranslate"><span class=pre>patch</span></code> 修饰符，但放入关键字传递的参数 <em>之后</em> 由创建的任何标准参数 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'sys.exit'</span><span class=p>)</span>
<span class=gp>... </span><span class=nd>@patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=s1>'__main__'</span><span class=p>,</span> <span class=n>thing</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test_function</span><span class=p>(</span><span class=n>mock_exit</span><span class=p>,</span> <span class=n>other</span><span class=p>,</span> <span class=n>thing</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'other'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>other</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'thing'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>thing</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'exit'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>mock_exit</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test_function</span><span class=p>()</span>
</pre></div>
</div>
<p>如果 <a class="reference internal" href=#unittest.mock.patch.multiple title=unittest.mock.patch.multiple><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.multiple()</span></code></a> 用作上下文管理器，上下文管理器返回的值是一个字典，其中创建的mock按名称键控：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=o>.</span><span class=n>multiple</span><span class=p>(</span><span class=s1>'__main__'</span><span class=p>,</span> <span class=n>thing</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>other</span><span class=o>=</span><span class=n>DEFAULT</span><span class=p>)</span> <span class=k>as</span> <span class=n>values</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'other'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=s1>'other'</span><span class=p>])</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=s1>'thing'</span> <span class=ow>in</span> <span class=nb>repr</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=s1>'thing'</span><span class=p>])</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>values</span><span class=p>[</span><span class=s1>'thing'</span><span class=p>]</span> <span class=ow>is</span> <span class=n>thing</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>values</span><span class=p>[</span><span class=s1>'other'</span><span class=p>]</span> <span class=ow>is</span> <span class=n>other</span>
<span class=gp>...</span>
</pre></div>
</div>
</div>
<div class=section id=patch-methods-start-and-stop>
<span id=start-and-stop></span><h3>修补方法：启动和停止<a class=headerlink href=#patch-methods-start-and-stop title=永久链接至标题>¶</a></h3>
<p>所有的补丁都有 <code class="xref py py-meth docutils literal notranslate"><span class=pre>start()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code> 方法。这些使修补变得更简单 <code class="docutils literal notranslate"><span class=pre>setUp</span></code> 方法或希望在不嵌套装饰器或不使用语句的情况下执行多个修补程序的位置。</p>
<p>使用它们调用 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> ， <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 或 <a class="reference internal" href=#unittest.mock.patch.dict title=unittest.mock.patch.dict><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.dict()</span></code></a> 和正常情况一样，并保持对返回的 <code class="docutils literal notranslate"><span class=pre>patcher</span></code> 对象。然后你可以调用 <code class="xref py py-meth docutils literal notranslate"><span class=pre>start()</span></code> 把补丁放好 <code class="xref py py-meth docutils literal notranslate"><span class=pre>stop()</span></code> 解开它。</p>
<p>如果您正在使用 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 若要为您创建模拟，则将通过调用返回到 <code class="docutils literal notranslate"><span class=pre>patcher.start</span></code> . ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.ClassName'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>package</span> <span class=kn>import</span> <span class=n>module</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>original</span> <span class=o>=</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>new_mock</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>original</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=n>new_mock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=n>original</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>module</span><span class=o>.</span><span class=n>ClassName</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>new_mock</span>
</pre></div>
</div>
<p>这方面的一个典型用例可能是在 <code class="docutils literal notranslate"><span class=pre>setUp</span></code> A方法 <code class="xref py py-class docutils literal notranslate"><span class=pre>TestCase</span></code> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher1</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.Class1'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher2</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.Class2'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>MockClass1</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patcher1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>MockClass2</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>patcher2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>tearDown</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher1</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>patcher2</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>Class1</span> <span class=ow>is</span> <span class=bp>self</span><span class=o>.</span><span class=n>MockClass1</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>Class2</span> <span class=ow>is</span> <span class=bp>self</span><span class=o>.</span><span class=n>MockClass2</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyTest</span><span class=p>(</span><span class=s1>'test_something'</span><span class=p>)</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</pre></div>
</div>
<div class="admonition caution">
<p class=admonition-title>警告</p>
<p>如果使用此技术，则必须通过调用 <code class="docutils literal notranslate"><span class=pre>stop</span></code> . 这可能比您想象的更麻烦，因为如果在 <code class="docutils literal notranslate"><span class=pre>setUp</span></code> 然后 <code class="docutils literal notranslate"><span class=pre>tearDown</span></code> 不被调用。 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/unittest.html#unittest.TestCase.addCleanup title=unittest.TestCase.addCleanup><code class="xref py py-meth docutils literal notranslate"><span class=pre>unittest.TestCase.addCleanup()</span></code></a> 使这更容易：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>MyTest</span><span class=p>(</span><span class=n>unittest</span><span class=o>.</span><span class=n>TestCase</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>setUp</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'package.module.Class'</span><span class=p>)</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>MockClass</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>addCleanup</span><span class=p>(</span><span class=n>patcher</span><span class=o>.</span><span class=n>stop</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>test_something</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>assert</span> <span class=n>package</span><span class=o>.</span><span class=n>module</span><span class=o>.</span><span class=n>Class</span> <span class=ow>is</span> <span class=bp>self</span><span class=o>.</span><span class=n>MockClass</span>
<span class=gp>...</span>
</pre></div>
</div>
<p>作为额外的奖励，您不再需要参考 <code class="docutils literal notranslate"><span class=pre>patcher</span></code> 对象。</p>
</div>
<p>也可以通过使用 <a class="reference internal" href=#unittest.mock.patch.stopall title=unittest.mock.patch.stopall><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.stopall()</span></code></a> .</p>
<dl class=function>
<dt id=unittest.mock.patch.stopall>
<code class="sig-prename descclassname">patch.</code><code class="sig-name descname">stopall</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.patch.stopall title=永久链接至目标>¶</a></dt>
<dd><p>停止所有活动修补程序。仅停止以开始的修补程序 <code class="docutils literal notranslate"><span class=pre>start</span></code> .</p>
</dl>
</div>
<div class=section id=patch-builtins>
<span id=id4></span><h3>补丁构建<a class=headerlink href=#patch-builtins title=永久链接至标题>¶</a></h3>
<p>您可以修补模块中的任何内置组件。下面的示例补丁内置 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#ord title=ord><code class="xref py py-func docutils literal notranslate"><span class=pre>ord()</span></code></a> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'__main__.ord'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock_ord</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>mock_ord</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=mi>101</span>
<span class=gp>... </span>    <span class=nb>print</span><span class=p>(</span><span class=nb>ord</span><span class=p>(</span><span class=s1>'c'</span><span class=p>))</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>test</span><span class=p>()</span>
<span class=go>101</span>
</pre></div>
</div>
</div>
<div class=section id=test-prefix>
<span id=id5></span><h3>TEST_PREFIX<a class=headerlink href=#test-prefix title=永久链接至标题>¶</a></h3>
<p>所有补丁都可以用作类装饰。当以这种方式使用时，它们封装类上的每个测试方法。补丁程序识别从 <code class="docutils literal notranslate"><span class=pre>'test'</span></code> 作为测试方法。这与 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/unittest.html#unittest.TestLoader title=unittest.TestLoader><code class="xref py py-class docutils literal notranslate"><span class=pre>unittest.TestLoader</span></code></a> 默认情况下查找测试方法。</p>
<p>您可能希望为测试使用不同的前缀。您可以通过设置不同的前缀通知修补程序 <code class="docutils literal notranslate"><span class=pre>patch.TEST_PREFIX</span></code> ：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>patch</span><span class=o>.</span><span class=n>TEST_PREFIX</span> <span class=o>=</span> <span class=s1>'foo'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>value</span> <span class=o>=</span> <span class=mi>3</span>
<span class=go>&gt;&gt;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'__main__.value'</span><span class=p>,</span> <span class=s1>'not three'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>class</span> <span class=nc>Thing</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo_one</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>foo_two</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
<span class=gp>...</span>
<span class=go>&gt;&gt;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Thing</span><span class=p>()</span><span class=o>.</span><span class=n>foo_one</span><span class=p>()</span>
<span class=go>not three</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Thing</span><span class=p>()</span><span class=o>.</span><span class=n>foo_two</span><span class=p>()</span>
<span class=go>not three</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>value</span>
<span class=go>3</span>
</pre></div>
</div>
</div>
<div class=section id=nesting-patch-decorators>
<h3>嵌套修补程序装饰器<a class=headerlink href=#nesting-patch-decorators title=永久链接至标题>¶</a></h3>
<p>如果您想执行多个补丁，那么您可以简单地堆叠装饰器。</p>
<p>可以使用此模式堆叠多个修补程序装饰器：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'class_method'</span><span class=p>)</span>
<span class=gp>... </span><span class=nd>@patch</span><span class=o>.</span><span class=n>object</span><span class=p>(</span><span class=n>SomeClass</span><span class=p>,</span> <span class=s1>'static_method'</span><span class=p>)</span>
<span class=gp>... </span><span class=k>def</span> <span class=nf>test</span><span class=p>(</span><span class=n>mock1</span><span class=p>,</span> <span class=n>mock2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>static_method</span> <span class=ow>is</span> <span class=n>mock1</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>SomeClass</span><span class=o>.</span><span class=n>class_method</span> <span class=ow>is</span> <span class=n>mock2</span>
<span class=gp>... </span>    <span class=n>SomeClass</span><span class=o>.</span><span class=n>static_method</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=n>SomeClass</span><span class=o>.</span><span class=n>class_method</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=n>mock1</span><span class=p>,</span> <span class=n>mock2</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock1</span><span class=p>,</span> <span class=n>mock2</span> <span class=o>=</span> <span class=n>test</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock1</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock2</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)</span>
</pre></div>
</div>
<p>请注意，装饰器是从底部向上应用的。这是Python应用装饰器的标准方法。传递到测试函数中的已创建模拟的顺序与此顺序匹配。</p>
</div>
<div class=section id=where-to-patch>
<span id=id6></span><h3>贴补何处<a class=headerlink href=#where-to-patch title=永久链接至标题>¶</a></h3>
<p><a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 通过（临时）更改 <em>name</em> 指向另一个。可以有许多名称指向任何单个对象，因此要使修补工作正常，必须确保修补被测系统使用的名称。</p>
<p>基本原则是你修补一个物体的位置 <em>抬起头</em> 不一定与定义地点相同。几个例子将有助于澄清这一点。</p>
<p>假设我们有一个项目要用以下结构进行测试：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=n>a</span><span class=o>.</span><span class=n>py</span>
    <span class=o>-&gt;</span> <span class=n>Defines</span> <span class=n>SomeClass</span>

<span class=n>b</span><span class=o>.</span><span class=n>py</span>
    <span class=o>-&gt;</span> <span class=kn>from</span> <span class=nn>a</span> <span class=kn>import</span> <span class=n>SomeClass</span>
    <span class=o>-&gt;</span> <span class=n>some_function</span> <span class=n>instantiates</span> <span class=n>SomeClass</span>
</pre></div>
</div>
<p>现在我们要测试 <code class="docutils literal notranslate"><span class=pre>some_function</span></code> 但我们想模拟一下 <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> 使用 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> . 问题是，当我们导入模块B时，必须先导入模块B，然后再导入模块B <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> 来自模块A。如果我们使用 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 嘲弄 <code class="docutils literal notranslate"><span class=pre>a.SomeClass</span></code> 那么它对我们的测试没有影响；模块B已经引用了 <em>real</em> <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> 看起来我们的修补没有效果。</p>
<p>关键是修补 <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> 使用地点（或查找地点）。在这种情况下 <code class="docutils literal notranslate"><span class=pre>some_function</span></code> 会查到的 <code class="docutils literal notranslate"><span class=pre>SomeClass</span></code> 在模块B中，我们已经导入了它。修补应如下所示：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'b.SomeClass'</span><span class=p>)</span>
</pre></div>
</div>
<p>但是，考虑另一种方案，其中 <code class="docutils literal notranslate"><span class=pre>from</span> <span class=pre>a</span> <span class=pre>import</span> <span class=pre>SomeClass</span></code> 模块B <code class="docutils literal notranslate"><span class=pre>import</span> <span class=pre>a</span></code> 和 <code class="docutils literal notranslate"><span class=pre>some_function</span></code> 使用 <code class="docutils literal notranslate"><span class=pre>a.SomeClass</span></code> .这两种输入形式都很常见。在这种情况下，我们要修补的类在模块中被查找，因此我们必须修补 <code class="docutils literal notranslate"><span class=pre>a.SomeClass</span></code> 取而代之的是：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=nd>@patch</span><span class=p>(</span><span class=s1>'a.SomeClass'</span><span class=p>)</span>
</pre></div>
</div>
</div>
<div class=section id=patching-descriptors-and-proxy-objects>
<h3>修补描述符和代理对象<a class=headerlink href=#patching-descriptors-and-proxy-objects title=永久链接至标题>¶</a></h3>
<p>两个 <a class="reference internal" href=#patch>patch</a> 和 <a class="reference internal" href=#patch-object>patch.object</a> 正确地修补和恢复描述符：类方法、静态方法和属性。你应该把这些贴在 <em>classes</em> 而不是实例。他们也与 <em>some</em> 代理属性访问的对象，如 <a class="reference external" href=http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>django settings object</a> .</p>
</div>
</div>
<div class=section id=magicmock-and-magic-method-support>
<h2>magicMock和magic方法支持<a class=headerlink href=#magicmock-and-magic-method-support title=永久链接至标题>¶</a></h2>
<div class=section id=mocking-magic-methods>
<span id=magic-methods></span><h3>模仿魔术的方法<a class=headerlink href=#mocking-magic-methods title=永久链接至标题>¶</a></h3>
<p><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 支持模拟Python协议方法，也称为“魔力方法”。这允许模拟对象替换容器或其他实现Python协议的对象。</p>
<p>因为魔术的方法和普通的方法是不同的 <a class="footnote-reference brackets" href=#id9 id=id7>2</a>, 这项支持已得到特别实施。这意味着只支持特定的魔力方法。支持的列表包括 <em>几乎</em> 所有这些。如果您需要什么，请告诉我们。</p>
<p>通过将感兴趣的方法设置为函数或模拟实例，可以模拟魔术方法。如果您使用的是函数，那么它 <em>must</em> 拿 <code class="docutils literal notranslate"><span class=pre>self</span></code> 作为第一个参数 <a class="footnote-reference brackets" href=#id10 id=id8>3</a>.</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>return</span> <span class=s1>'fooble'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span> <span class=o>=</span> <span class=fm>__str__</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'fooble'</span>
</pre></div>
</div>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__str__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'fooble'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>str</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>'fooble'</span>
</pre></div>
</div>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__iter__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=nb>iter</span><span class=p>([]))</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>[]</span>
</pre></div>
</div>
<p>这方面的一个用例是模拟用作 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/compound_stmts.html#with><code class="xref std std-keyword docutils literal notranslate"><span class=pre>with</span></code></a> 声明：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__enter__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__exit__</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>mock</span> <span class=k>as</span> <span class=n>m</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>assert</span> <span class=n>m</span> <span class=o>==</span> <span class=s1>'foo'</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__enter__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__exit__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</pre></div>
</div>
<p>对magic方法的调用不会出现在 <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> ，但它们被记录在 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> .</p>
<div class="admonition note">
<p class=admonition-title>注解</p>
<p>如果您使用 <em>spec</em> 创建模拟的关键字参数，然后尝试设置不在规范中的magic方法将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .</p>
</div>
<p>支持的魔术方法的完整列表是：</p>
<ul class=simple>
<li><p><code class="docutils literal notranslate"><span class=pre>__hash__</span></code>, <code class="docutils literal notranslate"><span class=pre>__sizeof__</span></code>, <code class="docutils literal notranslate"><span class=pre>__repr__</span></code> and <code class="docutils literal notranslate"><span class=pre>__str__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__dir__</span></code>, <code class="docutils literal notranslate"><span class=pre>__format__</span></code> and <code class="docutils literal notranslate"><span class=pre>__subclasses__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__round__</span></code>, <code class="docutils literal notranslate"><span class=pre>__floor__</span></code>, <code class="docutils literal notranslate"><span class=pre>__trunc__</span></code> and <code class="docutils literal notranslate"><span class=pre>__ceil__</span></code></p></li>
<li><p>比较： <code class="docutils literal notranslate"><span class=pre>__lt__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__gt__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__le__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__ge__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__eq__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__ne__</span></code></p></li>
<li><p>容器方法： <code class="docutils literal notranslate"><span class=pre>__getitem__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__setitem__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__delitem__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__contains__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__len__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__iter__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__reversed__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__missing__</span></code></p></li>
<li><p>上下文管理器： <code class="docutils literal notranslate"><span class=pre>__enter__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__exit__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__aenter__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__aexit__</span></code></p></li>
<li><p>一元数值方法： <code class="docutils literal notranslate"><span class=pre>__neg__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__pos__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__invert__</span></code></p></li>
<li><p>数字方法（包括右侧和就地变量）： <code class="docutils literal notranslate"><span class=pre>__add__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__sub__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__mul__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__matmul__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__div__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__truediv__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__floordiv__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__mod__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__divmod__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__lshift__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__rshift__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__and__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__xor__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__or__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__pow__</span></code></p></li>
<li><p>数字转换方法： <code class="docutils literal notranslate"><span class=pre>__complex__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__int__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__float__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__index__</span></code></p></li>
<li><p>描述符方法： <code class="docutils literal notranslate"><span class=pre>__get__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__set__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__delete__</span></code></p></li>
<li><p>腌渍： <code class="docutils literal notranslate"><span class=pre>__reduce__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__reduce_ex__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__getinitargs__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__getnewargs__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__getstate__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__setstate__</span></code></p></li>
<li><p>文件系统路径表示： <code class="docutils literal notranslate"><span class=pre>__fspath__</span></code></p></li>
<li><p>异步迭代方法： <code class="docutils literal notranslate"><span class=pre>__aiter__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__anext__</span></code></p></li>
</ul>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.8 版更改: </span>为添加了支持 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/os.html#os.PathLike.__fspath__ title=os.PathLike.__fspath__><code class="xref py py-func docutils literal notranslate"><span class=pre>os.PathLike.__fspath__()</span></code></a> .</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.8 版更改: </span>为添加了支持 <code class="docutils literal notranslate"><span class=pre>__aenter__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__aexit__</span></code> ， <code class="docutils literal notranslate"><span class=pre>__aiter__</span></code> 和 <code class="docutils literal notranslate"><span class=pre>__anext__</span></code> .</p>
</div>
<p>以下方法存在，但 <em>not</em> 由于它们正在被mock使用，无法动态设置，或者可能导致问题：</p>
<ul class=simple>
<li><p><code class="docutils literal notranslate"><span class=pre>__getattr__</span></code>, <code class="docutils literal notranslate"><span class=pre>__setattr__</span></code>, <code class="docutils literal notranslate"><span class=pre>__init__</span></code> and <code class="docutils literal notranslate"><span class=pre>__new__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__prepare__</span></code>, <code class="docutils literal notranslate"><span class=pre>__instancecheck__</span></code>, <code class="docutils literal notranslate"><span class=pre>__subclasscheck__</span></code>, <code class="docutils literal notranslate"><span class=pre>__del__</span></code></p></li>
</ul>
</div>
<div class=section id=magic-mock>
<h3>魔术模拟<a class=headerlink href=#magic-mock title=永久链接至标题>¶</a></h3>
<p>有两个 <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> 变体： <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 和 <a class="reference internal" href=#unittest.mock.NonCallableMagicMock title=unittest.mock.NonCallableMagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>NonCallableMagicMock</span></code></a> .</p>
<dl class=class>
<dt id=unittest.mock.MagicMock>
<em class=property>class </em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">MagicMock</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kw</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.MagicMock title=永久链接至目标>¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> 是的子类 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 使用大多数magic方法的默认实现。你可以用 <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> 不用自己配置魔法方法。</p>
<p>构造函数参数的含义与 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> .</p>
<p>如果您使用 <em>spec</em> 或 <em>spec_set</em> 然后参数 <em>only</em> 将创建规范中存在的魔力方法。</p>
</dl>
<dl class=class>
<dt id=unittest.mock.NonCallableMagicMock>
<em class=property>class </em><code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">NonCallableMagicMock</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kw</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.NonCallableMagicMock title=永久链接至目标>¶</a></dt>
<dd><p>不可调用的版本 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> .</p>
<p>构造函数参数的含义与 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> ，除了 <em>return_value</em> 和 <em>side_effect</em> 这对不可调用的模拟没有意义。</p>
</dl>
<p>魔法方法是用 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 对象，以便您可以按常规方式配置和使用它们：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=s1>'fish'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__setitem__</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s1>'fish'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__getitem__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=s1>'result'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
<span class=go>'result'</span>
</pre></div>
</div>
<p>默认情况下，返回特定类型的对象需要许多协议方法。这些方法预先配置了一个默认的返回值，这样，如果您对返回值不感兴趣，可以不用做任何事情就可以使用它们。你仍然可以 <em>set</em> 如果要更改默认值，则手动返回值。</p>
<p>方法及其默认值：</p>
<ul class=simple>
<li><p><code class="docutils literal notranslate"><span class=pre>__lt__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__gt__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__le__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__ge__</span></code>: <code class="docutils literal notranslate"><span class=pre>NotImplemented</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__int__</span></code>: <code class="docutils literal notranslate"><span class=pre>1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__contains__</span></code>: <code class="docutils literal notranslate"><span class=pre>False</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__len__</span></code>: <code class="docutils literal notranslate"><span class=pre>0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__iter__</span></code>: <code class="docutils literal notranslate"><span class=pre>iter([])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__exit__</span></code>: <code class="docutils literal notranslate"><span class=pre>False</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__aexit__</span></code>: <code class="docutils literal notranslate"><span class=pre>False</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__complex__</span></code>: <code class="docutils literal notranslate"><span class=pre>1j</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__float__</span></code>: <code class="docutils literal notranslate"><span class=pre>1.0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__bool__</span></code>: <code class="docutils literal notranslate"><span class=pre>True</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__index__</span></code>: <code class="docutils literal notranslate"><span class=pre>1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__hash__</span></code> ：模拟的默认hash</p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__str__</span></code> ：模拟的默认str</p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__sizeof__</span></code> ：模拟的默认sizeof</p></li>
</ul>
<p>例如：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>int</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>len</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>0</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>[]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>object</span><span class=p>()</span> <span class=ow>in</span> <span class=n>mock</span>
<span class=go>False</span>
</pre></div>
</div>
<p>两种平等方法， <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__eq__ title=object.__eq__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__eq__()</span></code></a> 和 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__ne__ title=object.__ne__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__ne__()</span></code></a> ，是特殊的。它们对标识执行默认的相等比较，使用 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 属性，除非您更改其返回值以返回其他内容：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>MagicMock</span><span class=p>()</span> <span class=o>==</span> <span class=mi>3</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MagicMock</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>3</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__eq__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=kc>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>==</span> <span class=mi>3</span>
<span class=go>True</span>
</pre></div>
</div>
<p>的返回值 <code class="xref py py-meth docutils literal notranslate"><span class=pre>MagicMock.__iter__()</span></code> 可以是任何可Iterable对象，不需要是迭代器：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__iter__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=p>[</span><span class=s1>'a'</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>['a', 'b', 'c']</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>['a', 'b', 'c']</span>
</pre></div>
</div>
<p>如果返回值 <em>is</em> 一个迭代器，然后在它上面迭代一次，将使用它，随后的迭代将导致一个空列表：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=fm>__iter__</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=nb>iter</span><span class=p>([</span><span class=s1>'a'</span><span class=p>,</span> <span class=s1>'b'</span><span class=p>,</span> <span class=s1>'c'</span><span class=p>])</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>['a', 'b', 'c']</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>list</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=go>[]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> 除了一些模糊和过时的方法外，配置了所有支持的魔力方法。如果你想的话，你仍然可以设置这些。</p>
<p>默认情况下不支持的Magic方法 <code class="docutils literal notranslate"><span class=pre>MagicMock</span></code> 是：</p>
<ul class=simple>
<li><p><code class="docutils literal notranslate"><span class=pre>__subclasses__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__dir__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__format__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__get__</span></code>, <code class="docutils literal notranslate"><span class=pre>__set__</span></code> and <code class="docutils literal notranslate"><span class=pre>__delete__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__reversed__</span></code> and <code class="docutils literal notranslate"><span class=pre>__missing__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__reduce__</span></code>, <code class="docutils literal notranslate"><span class=pre>__reduce_ex__</span></code>, <code class="docutils literal notranslate"><span class=pre>__getinitargs__</span></code>, <code class="docutils literal notranslate"><span class=pre>__getnewargs__</span></code>,
<code class="docutils literal notranslate"><span class=pre>__getstate__</span></code> and <code class="docutils literal notranslate"><span class=pre>__setstate__</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class=pre>__getformat__</span></code> and <code class="docutils literal notranslate"><span class=pre>__setformat__</span></code></p></li>
</ul>
<dl class="footnote brackets">
<dt class=label id=id9><span class=brackets><a class=fn-backref href=#id7>2</a></span></dt>
<dd><p>魔术方法 <em>应该</em> 在类上而不是实例上查找。关于应用此规则，不同版本的python不一致。支持的协议方法应该与所有支持的Python版本一起工作。</p>
</dd>
<dt class=label id=id10><span class=brackets><a class=fn-backref href=#id8>3</a></span></dt>
<dd><p>函数基本上与类挂钩，但是 <code class="docutils literal notranslate"><span class=pre>Mock</span></code> 实例与其他实例保持隔离。</p>
</dd>
</dl>
</div>
</div>
<div class=section id=helpers>
<h2>帮手<a class=headerlink href=#helpers title=永久链接至标题>¶</a></h2>
<div class=section id=sentinel>
<h3>哨兵<a class=headerlink href=#sentinel title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.sentinel>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">sentinel</code><a class=headerlink href=#unittest.mock.sentinel title=永久链接至目标>¶</a></dt>
<dd><p>这个 <code class="docutils literal notranslate"><span class=pre>sentinel</span></code> 对象提供了为测试提供独特对象的方便方法。</p>
<p>当您按名称访问属性时，它们是按需创建的。访问同一属性将始终返回同一对象。返回的对象具有合理的repr，因此测试失败消息是可读的。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.7 版更改: </span>这个 <code class="docutils literal notranslate"><span class=pre>sentinel</span></code> 属性现在保留它们的身份 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/copy.html#module-copy title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class=pre>copied</span></code></a> 或 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/pickle.html#module-pickle title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class=pre>pickled</span></code></a> .</p>
</div>
</dl>
<p>有时，当测试时，您需要测试特定对象是否作为参数传递给另一个方法，或者返回。创建命名的sentinel对象来测试这一点很常见。 <a class="reference internal" href=#unittest.mock.sentinel title=unittest.mock.sentinel><code class="xref py py-data docutils literal notranslate"><span class=pre>sentinel</span></code></a> 提供了一种创建和测试类似对象标识的方便方法。</p>
<p>在这个例子中，我们猴子补丁 <code class="docutils literal notranslate"><span class=pre>method</span></code> 归来 <code class="docutils literal notranslate"><span class=pre>sentinel.some_object</span></code> ：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>real</span> <span class=o>=</span> <span class=n>ProductionClass</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"method"</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=o>.</span><span class=n>return_value</span> <span class=o>=</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>some_object</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>result</span> <span class=o>=</span> <span class=n>real</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>result</span> <span class=ow>is</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>some_object</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>sentinel</span><span class=o>.</span><span class=n>some_object</span>
<span class=go>sentinel.some_object</span>
</pre></div>
</div>
</div>
<div class=section id=default>
<h3>DEFAULT<a class=headerlink href=#default title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.DEFAULT>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">DEFAULT</code><a class=headerlink href=#unittest.mock.DEFAULT title=永久链接至目标>¶</a></dt>
<dd><p>这个 <a class="reference internal" href=#unittest.mock.DEFAULT title=unittest.mock.DEFAULT><code class="xref py py-data docutils literal notranslate"><span class=pre>DEFAULT</span></code></a> 对象是预先创建的sentinel（实际上 <code class="docutils literal notranslate"><span class=pre>sentinel.DEFAULT</span></code> ）它可以被 <a class="reference internal" href=#unittest.mock.Mock.side_effect title=unittest.mock.Mock.side_effect><code class="xref py py-attr docutils literal notranslate"><span class=pre>side_effect</span></code></a> 用于指示应使用正常返回值的函数。</p>
</dl>
</div>
<div class=section id=call>
<h3>调用<a class=headerlink href=#call title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.call>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">call</code><span class=sig-paren>(</span><em class=sig-param>*args</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.call title=永久链接至目标>¶</a></dt>
<dd><p><a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-func docutils literal notranslate"><span class=pre>call()</span></code></a> 是用于生成简单断言的辅助对象，用于与 <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a> ， <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args_list</span></code></a> ， <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.method_calls title=unittest.mock.Mock.method_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>method_calls</span></code></a> . <a class="reference internal" href=#unittest.mock.call title=unittest.mock.call><code class="xref py py-func docutils literal notranslate"><span class=pre>call()</span></code></a> 也可用于 <a class="reference internal" href=#unittest.mock.Mock.assert_has_calls title=unittest.mock.Mock.assert_has_calls><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_has_calls()</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>a</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>call_args_list</span> <span class=o>==</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>a</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=s1>'bar'</span><span class=p>),</span> <span class=n>call</span><span class=p>()]</span>
<span class=go>True</span>
</pre></div>
</div>
</dl>
<dl class=method>
<dt id=unittest.mock.call.call_list>
<code class="sig-prename descclassname">call.</code><code class="sig-name descname">call_list</code><span class=sig-paren>(</span><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.call.call_list title=永久链接至目标>¶</a></dt>
<dd><p>对于表示多个调用的调用对象， <a class="reference internal" href=#unittest.mock.call.call_list title=unittest.mock.call.call_list><code class="xref py py-meth docutils literal notranslate"><span class=pre>call_list()</span></code></a> 返回所有中间调用和最终调用的列表。</p>
</dl>
<p><code class="docutils literal notranslate"><span class=pre>call_list</span></code> 对于对“链接调用”进行断言特别有用。链接调用是在一行代码上进行的多个调用。这将导致在 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> 嘲弄手动构造调用序列可能很麻烦。</p>
<p><a class="reference internal" href=#unittest.mock.call.call_list title=unittest.mock.call.call_list><code class="xref py py-meth docutils literal notranslate"><span class=pre>call_list()</span></code></a> 无法从同一个链接调用构造调用序列：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=n>arg</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span><span class=o>.</span><span class=n>other</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)(</span><span class=mf>2.0</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock().method().other()()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span> <span class=o>=</span> <span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>method</span><span class=p>(</span><span class=n>arg</span><span class=o>=</span><span class=s1>'foo'</span><span class=p>)</span><span class=o>.</span><span class=n>other</span><span class=p>(</span><span class=s1>'bar'</span><span class=p>)(</span><span class=mf>2.0</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=go>[call(1),</span>
<span class=go> call().method(arg='foo'),</span>
<span class=go> call().method().other('bar'),</span>
<span class=go> call().method().other()(2.0)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=n>kall</span><span class=o>.</span><span class=n>call_list</span><span class=p>()</span>
<span class=go>True</span>
</pre></div>
</div>
<p id=calls-as-tuples>A <code class="docutils literal notranslate"><span class=pre>call</span></code> 对象是（位置参数、关键字参数）或（名称、位置参数、关键字参数）的元组，具体取决于其构造方式。当你自己构建它们的时候，这并不特别有趣，但是 <code class="docutils literal notranslate"><span class=pre>call</span></code> 中的对象 <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args</span></code></a> ， <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args_list</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.mock_calls</span></code></a> 可以对属性进行内省，以获得它们所包含的各个参数。</p>
<p>这个 <code class="docutils literal notranslate"><span class=pre>call</span></code> 中的对象 <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.call_args_list title=unittest.mock.Mock.call_args_list><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.call_args_list</span></code></a> 是（位置参数、关键字参数）的两个元组，而 <code class="docutils literal notranslate"><span class=pre>call</span></code> 中的对象 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>Mock.mock_calls</span></code></a> 与您自己构造的元组一起，有三个元组（name、positional args、keyword args）。</p>
<p>您可以使用它们的“tupesity”为更复杂的内省和断言提取单独的参数。位置参数是一个元组（如果没有位置参数，则为空元组），关键字参数是一个字典：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'one'</span><span class=p>,</span> <span class=n>arg2</span><span class=o>=</span><span class=s1>'two'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>call_args</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>args</span>
<span class=go>(1, 2, 3)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>kwargs</span>
<span class=go>{'arg': 'one', 'arg2': 'two'}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>args</span> <span class=ow>is</span> <span class=n>kall</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span><span class=o>.</span><span class=n>kwargs</span> <span class=ow>is</span> <span class=n>kall</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
<span class=go>True</span>
</pre></div>
</div>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>foo</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>arg</span><span class=o>=</span><span class=s1>'two'</span><span class=p>,</span> <span class=n>arg2</span><span class=o>=</span><span class=s1>'three'</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='mock.foo()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kall</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>kwargs</span> <span class=o>=</span> <span class=n>kall</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span>
<span class=go>'foo'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>args</span>
<span class=go>(4, 5, 6)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>kwargs</span>
<span class=go>{'arg': 'two', 'arg2': 'three'}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span> <span class=ow>is</span> <span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
<div class=section id=create-autospec>
<h3>create_autospec<a class=headerlink href=#create-autospec title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.create_autospec>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">create_autospec</code><span class=sig-paren>(</span><em class=sig-param>spec</em>, <em class=sig-param>spec_set=False</em>, <em class=sig-param>instance=False</em>, <em class=sig-param>**kwargs</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.create_autospec title=永久链接至目标>¶</a></dt>
<dd><p>使用另一个对象作为规范创建模拟对象。模拟上的属性将使用 <em>spec</em> 对象作为其规范。</p>
<p>被模拟的函数或方法将检查其参数，以确保使用正确的签名调用它们。</p>
<p>如果 <em>spec_set</em> 是 <code class="docutils literal notranslate"><span class=pre>True</span></code> 然后尝试设置spec对象上不存在的属性将引发 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#AttributeError title=AttributeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>AttributeError</span></code></a> .</p>
<p>如果一个类被用作规范，那么mock（类的实例）的返回值将具有相同的规范。通过传递 <code class="docutils literal notranslate"><span class=pre>instance=True</span></code> . 仅当模拟的实例可调用时，返回的模拟才可调用。</p>
<p><a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 还接受传递给所创建模拟的构造函数的任意关键字参数。</p>
</dl>
<p>见 <a class="reference internal" href=#auto-speccing><span class="std std-ref">自聚焦</span></a> 有关如何使用自动规格化的示例 <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 以及 <em>AutoPoC</em> 参数 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> .</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.8 版更改: </span><a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 现在返回一个 <a class="reference internal" href=#unittest.mock.AsyncMock title=unittest.mock.AsyncMock><code class="xref py py-class docutils literal notranslate"><span class=pre>AsyncMock</span></code></a> 如果目标是异步函数。</p>
</div>
</div>
<div class=section id=any>
<h3>ANY<a class=headerlink href=#any title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.ANY>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">ANY</code><a class=headerlink href=#unittest.mock.ANY title=永久链接至目标>¶</a></dt>
<dd></dl>
<p>有时你可能需要对 <em>some</em> 调用mock时的参数，但要么不关心某些参数，要么希望将它们从 <a class="reference internal" href=#unittest.mock.Mock.call_args title=unittest.mock.Mock.call_args><code class="xref py py-attr docutils literal notranslate"><span class=pre>call_args</span></code></a> 对它们做出更复杂的断言。</p>
<p>若要忽略某些参数，可以传入比较等于 <em>一切</em> . 呼吁 <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> 然后，不管传入什么，都会成功。</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=nb>object</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=n>bar</span><span class=o>=</span><span class=n>ANY</span><span class=p>)</span>
</pre></div>
</div>
<p><a class="reference internal" href=#unittest.mock.ANY title=unittest.mock.ANY><code class="xref py py-data docutils literal notranslate"><span class=pre>ANY</span></code></a> 也可用于与调用列表进行比较，如 <a class="reference internal" href=#unittest.mock.Mock.mock_calls title=unittest.mock.Mock.mock_calls><code class="xref py py-attr docutils literal notranslate"><span class=pre>mock_calls</span></code></a> ：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>MagicMock</span><span class=p>(</span><span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=p>(</span><span class=nb>object</span><span class=p>())</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span> <span class=o>==</span> <span class=p>[</span><span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=n>call</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=n>ANY</span><span class=p>]</span>
<span class=go>True</span>
</pre></div>
</div>
</div>
<div class=section id=filter-dir>
<h3>FILTER_DIR<a class=headerlink href=#filter-dir title=永久链接至标题>¶</a></h3>
<dl class=data>
<dt id=unittest.mock.FILTER_DIR>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">FILTER_DIR</code><a class=headerlink href=#unittest.mock.FILTER_DIR title=永久链接至目标>¶</a></dt>
<dd></dl>
<p><a class="reference internal" href=#unittest.mock.FILTER_DIR title=unittest.mock.FILTER_DIR><code class="xref py py-data docutils literal notranslate"><span class=pre>FILTER_DIR</span></code></a> 是控制模拟对象响应方式的模块级变量 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#dir title=dir><code class="xref py py-func docutils literal notranslate"><span class=pre>dir()</span></code></a> （仅适用于python 2.6或更高版本）。默认值为 <code class="docutils literal notranslate"><span class=pre>True</span></code> 它使用下面描述的筛选，只显示有用的成员。如果您不类似于此筛选，或者需要出于诊断目的将其关闭，请设置 <code class="docutils literal notranslate"><span class=pre>mock.FILTER_DIR</span> <span class=pre>=</span> <span class=pre>False</span></code> .</p>
<p>过滤打开时， <code class="docutils literal notranslate"><span class=pre>dir(some_mock)</span></code> 只显示有用的属性，并将包括通常不会显示的任何动态创建的属性。如果模型是用 <em>spec</em> （或） <em>AutoPoC</em> 当然）然后显示原始属性的所有属性，即使它们尚未被访问：</p>
<div class="highlight-pycon3 notranslate"><div class=highlight><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nb>dir</span><span class=p>(</span><span class=n>Mock</span><span class=p>())</span>
<span class=go>['assert_any_call',</span>
<span class=go> 'assert_called',</span>
<span class=go> 'assert_called_once',</span>
<span class=go> 'assert_called_once_with',</span>
<span class=go> 'assert_called_with',</span>
<span class=go> 'assert_has_calls',</span>
<span class=go> 'assert_not_called',</span>
<span class=go> 'attach_mock',</span>
<span class=go> ...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>dir</span><span class=p>(</span><span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>request</span><span class=p>))</span>
<span class=go>['AbstractBasicAuthHandler',</span>
<span class=go> 'AbstractDigestAuthHandler',</span>
<span class=go> 'AbstractHTTPHandler',</span>
<span class=go> 'BaseHandler',</span>
<span class=go> ...</span>
</pre></div>
</div>
<p>很多不是很有用的（私人的 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 而不是模拟的东西）下划线和双下划线前缀属性已从调用的结果中筛选出来。 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#dir title=dir><code class="xref py py-func docutils literal notranslate"><span class=pre>dir()</span></code></a> 在一 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> .如果您不类似于这种行为，可以通过设置模块级开关将其关闭。 <a class="reference internal" href=#unittest.mock.FILTER_DIR title=unittest.mock.FILTER_DIR><code class="xref py py-data docutils literal notranslate"><span class=pre>FILTER_DIR</span></code></a> ：</p>
<div class="highlight-pycon3 notranslate"><div class=highlight><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>unittest</span> <span class=kn>import</span> <span class=n>mock</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>FILTER_DIR</span> <span class=o>=</span> <span class=kc>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>dir</span><span class=p>(</span><span class=n>mock</span><span class=o>.</span><span class=n>Mock</span><span class=p>())</span>
<span class=go>['_NonCallableMock__get_return_value',</span>
<span class=go> '_NonCallableMock__get_side_effect',</span>
<span class=go> '_NonCallableMock__return_value_doc',</span>
<span class=go> '_NonCallableMock__set_return_value',</span>
<span class=go> '_NonCallableMock__set_side_effect',</span>
<span class=go> '__call__',</span>
<span class=go> '__class__',</span>
<span class=go> ...</span>
</pre></div>
</div>
<p>或者你也可以用 <code class="docutils literal notranslate"><span class=pre>vars(my_mock)</span></code> （实例成员）和 <code class="docutils literal notranslate"><span class=pre>dir(type(my_mock))</span></code> （类型成员）忽略筛选 <code class="xref py py-data docutils literal notranslate"><span class=pre>mock.FILTER_DIR</span></code> .</p>
</div>
<div class=section id=mock-open>
<h3>mock_open<a class=headerlink href=#mock-open title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.mock_open>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">mock_open</code><span class=sig-paren>(</span><em class=sig-param>mock=None</em>, <em class=sig-param>read_data=None</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.mock_open title=永久链接至目标>¶</a></dt>
<dd><p>用于创建模拟以替换 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> . 它适用于 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> 直接调用或用作上下文管理器。</p>
<p>这个 <em>mock</em> 参数是要配置的模拟对象。如果 <code class="docutils literal notranslate"><span class=pre>None</span></code> （默认）然后 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 将为您创建，API仅限于标准文件句柄上可用的方法或属性。</p>
<p><em>read_data</em> 是一个字符串 <code class="xref py py-meth docutils literal notranslate"><span class=pre>read()</span></code> ， <a class="reference internal" href=https://www.osgeo.cn/cpython/library/io.html#io.IOBase.readline title=io.IOBase.readline><code class="xref py py-meth docutils literal notranslate"><span class=pre>readline()</span></code></a> 和 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/io.html#io.IOBase.readlines title=io.IOBase.readlines><code class="xref py py-meth docutils literal notranslate"><span class=pre>readlines()</span></code></a> 要返回的文件句柄的方法。对这些方法的调用将从 <em>read_data</em> 直到耗尽。这些方法的模拟相当简单：每次 <em>mock</em> 被称为 <em>read_data</em> 重新回到起点。如果您需要更多的控制您正在向测试代码提供的数据，您将需要为自己定制这个模拟。当这还不够时，内存中的一个文件系统包 <a class="reference external" href=https://pypi.org/>PyPI</a> 可以为测试提供一个真实的文件系统。</p>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.4 版更改: </span>补充 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/io.html#io.IOBase.readline title=io.IOBase.readline><code class="xref py py-meth docutils literal notranslate"><span class=pre>readline()</span></code></a> 和 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/io.html#io.IOBase.readlines title=io.IOBase.readlines><code class="xref py py-meth docutils literal notranslate"><span class=pre>readlines()</span></code></a> 支持。嘲弄 <code class="xref py py-meth docutils literal notranslate"><span class=pre>read()</span></code> 改为消费 <em>read_data</em> 而不是每次通话都返回。</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.5 版更改: </span><em>read_data</em> 现在在每次调用时重置为 <em>mock</em> .</p>
</div>
<div class=versionchanged>
<p><span class="versionmodified changed">在 3.8 版更改: </span>补充 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__iter__ title=object.__iter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__iter__()</span></code></a> 使迭代（如for循环）正确地消耗 <em>read_data</em> .</p>
</div>
</dl>
<p>使用 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> 作为一个上下文管理器，是确保文件句柄正确关闭的一个很好的方法，并且越来越常见：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'/some/path'</span><span class=p>,</span> <span class=s1>'w'</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>'something'</span><span class=p>)</span>
</pre></div>
</div>
<p>问题是，即使你假装调用给 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#open title=open><code class="xref py py-func docutils literal notranslate"><span class=pre>open()</span></code></a> 它是 <em>返回对象</em> 用作上下文管理器的 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__enter__ title=object.__enter__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__enter__()</span></code></a> 和 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__exit__ title=object.__exit__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__exit__()</span></code></a> 叫）</p>
<p>模拟上下文管理器 <a class="reference internal" href=#unittest.mock.MagicMock title=unittest.mock.MagicMock><code class="xref py py-class docutils literal notranslate"><span class=pre>MagicMock</span></code></a> 足够普通和精细，帮助函数是有用的。：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>m</span> <span class=o>=</span> <span class=n>mock_open</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.open'</span><span class=p>,</span> <span class=n>m</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=s1>'w'</span><span class=p>)</span> <span class=k>as</span> <span class=n>h</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>h</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>'some stuff'</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>mock_calls</span>
<span class=go>[call('foo', 'w'),</span>
<span class=go> call().__enter__(),</span>
<span class=go> call().write('some stuff'),</span>
<span class=go> call().__exit__(None, None, None)]</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=s1>'w'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>handle</span> <span class=o>=</span> <span class=n>m</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>handle</span><span class=o>.</span><span class=n>write</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'some stuff'</span><span class=p>)</span>
</pre></div>
</div>
<p>对于读取文件：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.open'</span><span class=p>,</span> <span class=n>mock_open</span><span class=p>(</span><span class=n>read_data</span><span class=o>=</span><span class=s1>'bibble'</span><span class=p>))</span> <span class=k>as</span> <span class=n>m</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span> <span class=k>as</span> <span class=n>h</span><span class=p>:</span>
<span class=gp>... </span>        <span class=n>result</span> <span class=o>=</span> <span class=n>h</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>m</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>assert</span> <span class=n>result</span> <span class=o>==</span> <span class=s1>'bibble'</span>
</pre></div>
</div>
</div>
<div class=section id=autospeccing>
<span id=auto-speccing></span><h3>自聚焦<a class=headerlink href=#autospeccing title=永久链接至标题>¶</a></h3>
<p>自动排序基于现有 <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> 模拟的特征。它将mock的api限制为原始对象（spec）的api，但它是递归的（延迟实现的），因此mock的属性与spec的属性只有相同的api。此外，mock的函数/方法与原始函数/方法具有相同的调用签名，因此它们引发了 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/exceptions.html#TypeError title=TypeError><code class="xref py py-exc docutils literal notranslate"><span class=pre>TypeError</span></code></a> 如果调用错误。</p>
<p>在我解释自动规范如何工作之前，这里是需要它的原因。</p>
<p><a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 是一个非常强大和灵活的对象，但当用于模拟测试系统中的对象时，它会遇到两个缺陷。其中一个缺陷是特定于 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> API和另一个更常见的问题是使用模拟对象。</p>
<p>首先是特定于 <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> . <a class="reference internal" href=#unittest.mock.Mock title=unittest.mock.Mock><code class="xref py py-class docutils literal notranslate"><span class=pre>Mock</span></code></a> 有两个非常方便的断言方法： <a class="reference internal" href=#unittest.mock.Mock.assert_called_with title=unittest.mock.Mock.assert_called_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_with()</span></code></a> 和 <a class="reference internal" href=#unittest.mock.Mock.assert_called_once_with title=unittest.mock.Mock.assert_called_once_with><code class="xref py py-meth docutils literal notranslate"><span class=pre>assert_called_once_with()</span></code></a> .</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'Thing'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assert_called_once_with</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AssertionError</span><span>: </span><span class=n>Expected 'mock' to be called once. Called 2 times.</span>
</pre></div>
</div>
<p>因为mocks会根据需要自动创建属性，并允许您使用任意参数调用它们，如果您拼写错误了这些断言方法之一，那么您的断言就消失了：</p>
<div class="highlight-pycon notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>'Thing'</span><span class=p>,</span> <span class=n>return_value</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assret_called_once_with</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</pre></div>
</div>
<p>由于打字错误，您的测试可能会无声且错误地通过。</p>
<p>第二个问题对嘲弄更为普遍。如果重构某些代码、重命名成员等，则对仍在使用 <em>旧API</em> 但使用模拟而不是真正的对象仍然会通过。这意味着即使您的代码被破坏，您的测试也可以全部通过。</p>
<p>请注意，这是您需要集成测试和单元测试的另一个原因。单独测试所有的东西都很好，而且很花哨，但是如果你不测试你的单元是如何“连接在一起”的，那么测试中仍然有很多可能会发现的错误空间。</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class=pre>mock</span></code> 已经提供了一个功能来帮助实现这一点，称为speccing。如果使用类或实例作为 <code class="xref py py-attr docutils literal notranslate"><span class=pre>spec</span></code> 对于模拟，则只能访问实体类上存在的模拟的属性：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>(</span><span class=n>spec</span><span class=o>=</span><span class=n>request</span><span class=o>.</span><span class=n>Request</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>assret_called_with</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'assret_called_with'</span>
</pre></div>
</div>
<p>规范只适用于模拟本身，因此我们仍然对模拟上的任何方法有相同的问题：</p>
<div class="highlight-pycon notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>has_data</span><span class=p>()</span>
<span class=go>&lt;mock.Mock object at 0x...&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>has_data</span><span class=o>.</span><span class=n>assret_called_with</span><span class=p>()</span>
</pre></div>
</div>
<p>自动规范解决了这个问题。你也可以通过 <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> 到 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> / <a class="reference internal" href=#unittest.mock.patch.object title=unittest.mock.patch.object><code class="xref py py-func docutils literal notranslate"><span class=pre>patch.object()</span></code></a> 或者使用 <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 函数创建具有规范的模拟。如果使用 <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> 参数 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 然后将替换的对象用作spec对象。因为规范化是“懒洋洋地”完成的（规范是作为对mock上的属性进行访问而创建的），所以您可以将它与非常复杂或深度嵌套的对象（如导入导入模块的模块）一起使用，而不会对性能造成重大影响。</p>
<p>下面是一个使用中的示例：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>patcher</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.request'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span> <span class=o>=</span> <span class=n>patcher</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>request</span> <span class=ow>is</span> <span class=n>mock_request</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span><span class=o>.</span><span class=n>Request</span>
<span class=go>&lt;MagicMock name='request.Request' spec='Request' id='...'&gt;</span>
</pre></div>
</div>
<p>你可以看到 <code class="xref py py-class docutils literal notranslate"><span class=pre>request.Request</span></code> 有规格 <code class="xref py py-class docutils literal notranslate"><span class=pre>request.Request</span></code> 在构造函数中接受两个参数（其中一个是 <em>self</em> ）如果我们不正确地称呼它，会发生以下情况：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>req</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>Request</span><span class=p>()</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>TypeError</span><span>: </span><span class=n>&lt;lambda&gt;() takes at least 2 arguments (1 given)</span>
</pre></div>
</div>
<p>规范还适用于实例化类（即规范化mock的返回值）：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>req</span> <span class=o>=</span> <span class=n>request</span><span class=o>.</span><span class=n>Request</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>req</span>
<span class=go>&lt;NonCallableMagicMock name='request.Request()' spec='Request' id='...'&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class=pre>Request</span></code> 对象不可调用，因此实例化模拟对象的返回值 <code class="xref py py-class docutils literal notranslate"><span class=pre>request.Request</span></code> 是不可调用的模拟。规范就位后，断言中的任何拼写错误都将引发正确的错误：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>req</span><span class=o>.</span><span class=n>add_header</span><span class=p>(</span><span class=s1>'spam'</span><span class=p>,</span> <span class=s1>'eggs'</span><span class=p>)</span>
<span class=go>&lt;MagicMock name='request.Request().add_header()' id='...'&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>req</span><span class=o>.</span><span class=n>add_header</span><span class=o>.</span><span class=n>assret_called_with</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'assret_called_with'</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>req</span><span class=o>.</span><span class=n>add_header</span><span class=o>.</span><span class=n>assert_called_with</span><span class=p>(</span><span class=s1>'spam'</span><span class=p>,</span> <span class=s1>'eggs'</span><span class=p>)</span>
</pre></div>
</div>
<p>在许多情况下，您可以添加 <code class="docutils literal notranslate"><span class=pre>autospec=True</span></code> 到你现有的 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 调用，然后防止由于拼写错误和API更改而导致的错误。</p>
<p>以及使用 <em>AutoPoC</em> 通过 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 有一个 <a class="reference internal" href=#unittest.mock.create_autospec title=unittest.mock.create_autospec><code class="xref py py-func docutils literal notranslate"><span class=pre>create_autospec()</span></code></a> 对于直接创建自动指定的模拟：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=kn>from</span> <span class=nn>urllib</span> <span class=kn>import</span> <span class=n>request</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span> <span class=o>=</span> <span class=n>create_autospec</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock_request</span><span class=o>.</span><span class=n>Request</span><span class=p>(</span><span class=s1>'foo'</span><span class=p>,</span> <span class=s1>'bar'</span><span class=p>)</span>
<span class=go>&lt;NonCallableMagicMock name='mock.Request()' spec='Request' id='...'&gt;</span>
</pre></div>
</div>
<p>然而，这并非没有警告和限制，这就是为什么它不是默认行为。为了知道spec对象上可用的属性，autospec必须对spec进行内省（访问属性）。当您在mock上遍历属性时，原始对象的相应遍历将发生在hood下。如果任何指定的对象具有可以触发代码执行的属性或描述符，那么您可能无法使用autospec。另一方面，更好的方法是设计你的对象，这样内省是安全的。 <a class="footnote-reference brackets" href=#id12 id=id11>4</a>.</p>
<p>更严重的问题是，在 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__init__ title=object.__init__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code></a> 方法，并且根本不存在于类中。 <em>AutoPoC</em> 无法了解任何动态创建的属性，并将API限制为可见属性。地址：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=bp>self</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>thing</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>thing</span><span class=o>.</span><span class=n>a</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
  <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'a'</span>
</pre></div>
</div>
<p>有几种不同的方法来解决这个问题。最简单但不一定是最麻烦的方法是在创建后简单地在模拟上设置所需的属性。只是因为 <em>AutoPoC</em> 不允许您获取规范中不存在的属性，但不会阻止您设置这些属性：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>thing</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>thing</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
</pre></div>
</div>
<p>两者都有更激进的版本 <em>spec</em> 和 <em>AutoPoC</em> 那个 <em>does</em> 防止设置不存在的属性。如果您只想确保您的代码 <em>sets</em> 同样有效的属性，但显然它阻止了这种特定的场景：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>with</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>spec_set</span><span class=o>=</span><span class=kc>True</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>thing</span> <span class=o>=</span> <span class=n>Something</span><span class=p>()</span>
<span class=gp>... </span>  <span class=n>thing</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
 <span class=c>...</span>
<span class=gr>AttributeError</span><span>: </span><span class=n>Mock object has no attribute 'a'</span>
</pre></div>
</div>
<p>解决这个问题的最好方法可能是添加类属性作为初始化实例成员的默认值。 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__init__ title=object.__init__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code></a> . 请注意，如果只在中设置默认属性 <a class="reference internal" href=https://www.osgeo.cn/cpython/reference/datamodel.html#object.__init__ title=object.__init__><code class="xref py py-meth docutils literal notranslate"><span class=pre>__init__()</span></code></a> 然后通过类属性（当然是在实例之间共享）提供它们也会更快。例如</p>
<div class="highlight-python notranslate" style=position:relative><div class=highlight><pre><span></span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
    <span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
</pre></div>
</div>
<p>这带来了另一个问题。提供默认值是比较常见的 <code class="docutils literal notranslate"><span class=pre>None</span></code> 对于以后将成为不同类型对象的成员。 <code class="docutils literal notranslate"><span class=pre>None</span></code> 作为一个规范是没用的，因为它不允许你访问 <em>any</em> 属性或方法。AS <code class="docutils literal notranslate"><span class=pre>None</span></code> 是 <em>从未</em> 作为规范很有用，并且可能指示通常属于其他类型的成员，autospec不为设置为的成员使用规范。 <code class="docutils literal notranslate"><span class=pre>None</span></code> .这些将只是普通的模拟（嗯-魔术师模拟）：</p>
<div class="highlight-default notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>    <span class=n>member</span> <span class=o>=</span> <span class=kc>None</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>create_autospec</span><span class=p>(</span><span class=n>Something</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>member</span><span class=o>.</span><span class=n>foo</span><span class=o>.</span><span class=n>bar</span><span class=o>.</span><span class=n>baz</span><span class=p>()</span>
<span class=go>&lt;MagicMock name='mock.member.foo.bar.baz()' id='...'&gt;</span>
</pre></div>
</div>
<p>如果修改生产类以添加默认值不符合您的喜好，那么还有更多的选项。其中之一就是使用实例作为规范，而不是类。另一种方法是创建生产类的子类，并在不影响生产类的情况下将默认值添加到子类中。谢天谢地，这两种方法都要求您使用另一个对象作为规范。 <a class="reference internal" href=#unittest.mock.patch title=unittest.mock.patch><code class="xref py py-func docutils literal notranslate"><span class=pre>patch()</span></code></a> 支持这一点-您可以简单地将替代对象作为 <em>AutoPoC</em> 参数：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Something</span><span class=p>:</span>
<span class=gp>... </span>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=bp>self</span><span class=o>.</span><span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>SomethingForTest</span><span class=p>(</span><span class=n>Something</span><span class=p>):</span>
<span class=gp>... </span>  <span class=n>a</span> <span class=o>=</span> <span class=mi>33</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>p</span> <span class=o>=</span> <span class=n>patch</span><span class=p>(</span><span class=s1>'__main__.Something'</span><span class=p>,</span> <span class=n>autospec</span><span class=o>=</span><span class=n>SomethingForTest</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>a</span>
<span class=go>&lt;NonCallableMagicMock name='Something.a' spec='int' id='...'&gt;</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class=label id=id12><span class=brackets><a class=fn-backref href=#id11>4</a></span></dt>
<dd><p>这只适用于类或已经实例化的对象。调用模拟类以创建模拟实例 <em>不</em> 创建真实实例。它只是属性查找-以及对 <a class="reference internal" href=https://www.osgeo.cn/cpython/library/functions.html#dir title=dir><code class="xref py py-func docutils literal notranslate"><span class=pre>dir()</span></code></a> -完成了。</p>
</dd>
</dl>
</div>
<div class=section id=sealing-mocks>
<h3>密封模拟<a class=headerlink href=#sealing-mocks title=永久链接至标题>¶</a></h3>
<dl class=function>
<dt id=unittest.mock.seal>
<code class="sig-prename descclassname">unittest.mock.</code><code class="sig-name descname">seal</code><span class=sig-paren>(</span><em class=sig-param>mock</em><span class=sig-paren>)</span><a class=headerlink href=#unittest.mock.seal title=永久链接至目标>¶</a></dt>
<dd><p>当访问被密封的模拟的属性或已经递归模拟的任何属性时，seal将禁用模拟的自动创建。</p>
<p>如果一个具有名称或规格的模拟实例被分配给一个属性，那么它将不会在密封链中被考虑。这样可以防止密封件固定模拟对象的一部分。：：</p>
<div class="highlight-python3 notranslate" style=position:relative><div class=highlight><span class=copybutton title="Hide the prompts and output" style="cursor:pointer;position:absolute;top:0px;right:0px;border-color:#aacc99;border-style:solid;border-width:1px;color:#aacc99;font-family:monospace;padding-left:.2em;padding-right:.2em;border-radius:0px 3px 0px 0px">&gt;&gt;&gt;</span><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span> <span class=o>=</span> <span class=n>Mock</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>submock</span><span class=o>.</span><span class=n>attribute1</span> <span class=o>=</span> <span class=mi>2</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>not_submock</span> <span class=o>=</span> <span class=n>mock</span><span class=o>.</span><span class=n>Mock</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"sample_name"</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>seal</span><span class=p>(</span><span class=n>mock</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>new_attribute</span>  <span class=c1># This will raise AttributeError.</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>submock</span><span class=o>.</span><span class=n>attribute2</span>  <span class=c1># This will raise AttributeError.</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>mock</span><span class=o>.</span><span class=n>not_submock</span><span class=o>.</span><span class=n>attribute2</span>  <span class=c1># This won't raise.</span>
</pre></div>
</div>
<div class=versionadded>
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dl>
</div>
</div>
</div>
 </div>
 </div>
 </div>
 
 
 </div> 
 
 
 
<div id=saladict-saladbowl-root class="saladict-div saladict-external" style=display:none!important><div class=saladict-external style=display:none!important><template shadowmode=open style=display:none!important><div style=animation:initial;transition:initial;color:initial;font:initial;font-feature-settings:initial;font-kerning:initial;font-optical-sizing:initial;font-variation-settings:initial;text-orientation:initial;text-rendering:initial;-webkit-font-smoothing:initial;-webkit-locale:initial;-webkit-text-orientation:initial;-webkit-writing-mode:initial;writing-mode:initial;zoom:initial;place-content:initial;place-items:initial;place-self:initial;alignment-baseline:initial;backdrop-filter:initial;backface-visibility:initial;background:initial;background-blend-mode:initial;baseline-shift:initial;block-size:initial;border-block-end:initial;border-block-start:initial;border:initial;border-radius:initial;border-collapse:initial;border-inline-end:initial;border-inline-start:initial;bottom:initial;box-shadow:initial;box-sizing:initial;break-after:initial;break-before:initial;break-inside:initial;buffered-rendering:initial;caption-side:initial;caret-color:initial;clear:initial;clip:initial;clip-path:initial;clip-rule:initial;color-interpolation:initial;color-interpolation-filters:initial;color-rendering:initial;columns:initial;column-fill:initial;gap:initial;column-rule:initial;column-span:initial;contain:initial;content:initial;counter-increment:initial;counter-reset:initial;cursor:initial;cx:initial;cy:initial;d:initial;display:none!important;dominant-baseline:initial;empty-cells:initial;fill:initial;fill-opacity:initial;fill-rule:initial;filter:initial;flex:initial;flex-flow:initial;float:initial;flood-color:initial;flood-opacity:initial;grid:initial;grid-area:initial;height:initial;hyphens:initial;image-rendering:initial;inline-size:initial;isolation:initial;left:initial;letter-spacing:initial;lighting-color:initial;line-break:initial;list-style:initial;margin-block-end:initial;margin-block-start:initial;margin:initial;margin-inline-end:initial;margin-inline-start:initial;marker:initial;mask:initial;mask-type:initial;max-block-size:initial;max-height:initial;max-inline-size:initial;max-width:initial;min-block-size:initial;min-height:initial;min-inline-size:initial;min-width:initial;mix-blend-mode:initial;object-fit:initial;object-position:initial;offset:initial;opacity:initial;order:initial;orphans:initial;outline:initial;outline-offset:initial;overflow-anchor:initial;overflow-wrap:initial;overflow:initial;overscroll-behavior-block:initial;overscroll-behavior-inline:initial;overscroll-behavior:initial;padding-block-end:initial;padding-block-start:initial;padding:initial;padding-inline-end:initial;padding-inline-start:initial;page:initial;paint-order:initial;perspective:initial;perspective-origin:initial;pointer-events:initial;position:initial;quotes:initial;r:initial;resize:initial;right:initial;rx:initial;ry:initial;scroll-behavior:initial;scroll-margin-block:initial;scroll-margin:initial;scroll-margin-inline:initial;scroll-padding-block:initial;scroll-padding:initial;scroll-padding-inline:initial;scroll-snap-align:initial;scroll-snap-stop:initial;scroll-snap-type:initial;shape-image-threshold:initial;shape-margin:initial;shape-outside:initial;shape-rendering:initial;size:initial;speak:initial;stop-color:initial;stop-opacity:initial;stroke:initial;stroke-dasharray:initial;stroke-dashoffset:initial;stroke-linecap:initial;stroke-linejoin:initial;stroke-miterlimit:initial;stroke-opacity:initial;stroke-width:initial;tab-size:initial;table-layout:initial;text-align:initial;text-align-last:initial;text-anchor:initial;text-combine-upright:initial;text-decoration:initial;text-decoration-skip-ink:initial;text-indent:initial;text-overflow:initial;text-shadow:initial;text-size-adjust:initial;text-transform:initial;text-underline-position:initial;top:initial;touch-action:initial;transform:initial;transform-box:initial;transform-origin:initial;transform-style:initial;user-select:initial;vector-effect:initial;vertical-align:initial;visibility:initial;-webkit-app-region:initial;-webkit-appearance:initial;border-spacing:initial;-webkit-border-image:initial;-webkit-box-align:initial;-webkit-box-decoration-break:initial;-webkit-box-direction:initial;-webkit-box-flex:initial;-webkit-box-ordinal-group:initial;-webkit-box-orient:initial;-webkit-box-pack:initial;-webkit-box-reflect:initial;-webkit-font-size-delta:initial;-webkit-highlight:initial;-webkit-hyphenate-character:initial;-webkit-line-break:initial;-webkit-line-clamp:initial;-webkit-margin-collapse:initial;-webkit-margin-bottom-collapse:initial;-webkit-margin-top-collapse:initial;-webkit-mask-box-image:initial;-webkit-mask:initial;-webkit-mask-composite:initial;-webkit-perspective-origin-x:initial;-webkit-perspective-origin-y:initial;-webkit-print-color-adjust:initial;-webkit-rtl-ordering:initial;-webkit-ruby-position:initial;-webkit-tap-highlight-color:initial;-webkit-text-combine:initial;-webkit-text-decorations-in-effect:initial;-webkit-text-emphasis:initial;-webkit-text-emphasis-position:initial;-webkit-text-fill-color:initial;-webkit-text-security:initial;-webkit-text-stroke:initial;-webkit-transform-origin-x:initial;-webkit-transform-origin-y:initial;-webkit-transform-origin-z:initial;-webkit-user-drag:initial;-webkit-user-modify:initial;white-space:initial;widows:initial;width:initial;will-change:initial;word-break:initial;word-spacing:initial;x:initial;y:initial;z-index:initial><style>.saladbowl{position:fixed;z-index:2147483647;top:0;left:0;width:30px;height:30px;-moz-user-select:none;user-select:none;cursor:pointer}.isAnimate.saladbowl{will-change:transform;transition:transform .3s ease-out}.isAnimate.saladbowl.enableHover:hover .saladbowl-leaf{animation:saladbowl-leaf-shake .7s infinite linear}.isAnimate.saladbowl.enableHover:hover .saladbowl-orange{transform-origin:301.8px 187.4px;animation:saladbowl-orange-spin .7s infinite linear}.isAnimate.saladbowl.enableHover:hover .saladbowl-tomato{transform-origin:297.8px 126.4px;animation:saladbowl-tomato-shake .7s infinite linear}.isAnimate.saladbowl-enter-active>svg{animation:saladbowl-jelly 1s linear}.isAnimate.saladbowl-exit{opacity:1}.isAnimate.saladbowl-exit-active{opacity:0;transition:opacity .1s}.saladbowl-exit-done{display:none}@keyframes saladbowl-jelly{0%{transform:matrix3d(.5,0,0,0,0,.5,0,0,0,0,1,0,0,0,0,1)}3.40%{transform:matrix3d(.658,0,0,0,0,.703,0,0,0,0,1,0,0,0,0,1)}4.70%{transform:matrix3d(.725,0,0,0,0,.8,0,0,0,0,1,0,0,0,0,1)}6.81%{transform:matrix3d(.83,0,0,0,0,.946,0,0,0,0,1,0,0,0,0,1)}9.41%{transform:matrix3d(.942,0,0,0,0,1.084,0,0,0,0,1,0,0,0,0,1)}10.21%{transform:matrix3d(.971,0,0,0,0,1.113,0,0,0,0,1,0,0,0,0,1)}13.61%{transform:matrix3d(1.062,0,0,0,0,1.166,0,0,0,0,1,0,0,0,0,1)}14.11%{transform:matrix3d(1.07,0,0,0,0,1.165,0,0,0,0,1,0,0,0,0,1)}17.52%{transform:matrix3d(1.104,0,0,0,0,1.12,0,0,0,0,1,0,0,0,0,1)}18.72%{transform:matrix3d(1.106,0,0,0,0,1.094,0,0,0,0,1,0,0,0,0,1)}21.32%{transform:matrix3d(1.098,0,0,0,0,1.035,0,0,0,0,1,0,0,0,0,1)}24.32%{transform:matrix3d(1.075,0,0,0,0,.98,0,0,0,0,1,0,0,0,0,1)}25.23%{transform:matrix3d(1.067,0,0,0,0,.969,0,0,0,0,1,0,0,0,0,1)}29.03%{transform:matrix3d(1.031,0,0,0,0,.948,0,0,0,0,1,0,0,0,0,1)}29.93%{transform:matrix3d(1.024,0,0,0,0,.949,0,0,0,0,1,0,0,0,0,1)}35.54%{transform:matrix3d(.99,0,0,0,0,.981,0,0,0,0,1,0,0,0,0,1)}36.74%{transform:matrix3d(.986,0,0,0,0,.989,0,0,0,0,1,0,0,0,0,1)}41.04%{transform:matrix3d(.98,0,0,0,0,1.011,0,0,0,0,1,0,0,0,0,1)}44.44%{transform:matrix3d(.983,0,0,0,0,1.016,0,0,0,0,1,0,0,0,0,1)}52.15%{transform:matrix3d(.996,0,0,0,0,1.003,0,0,0,0,1,0,0,0,0,1)}59.86%{transform:matrix3d(1.003,0,0,0,0,.995,0,0,0,0,1,0,0,0,0,1)}63.26%{transform:matrix3d(1.004,0,0,0,0,.996,0,0,0,0,1,0,0,0,0,1)}75.28%{transform:matrix3d(1.001,0,0,0,0,1.002,0,0,0,0,1,0,0,0,0,1)}85.49%{transform:matrix3d(.999,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}90.69%{transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}100%{transform:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}}@keyframes saladbowl-leaf-shake{0%{transform:translate(2px,1px) rotate(0)}10%{transform:translate(-1px,-2px) rotate(1deg)}20%{transform:translate(-2px,0) rotate(1deg)}30%{transform:translate(0,2px) rotate(0)}40%{transform:translate(1px,-1px) rotate(1deg)}50%{transform:translate(-1px,2px) rotate(1deg)}60%{transform:translate(-2px,1px) rotate(0)}70%{transform:translate(2px,1px) rotate(1deg)}80%{transform:translate(-1px,-1px) rotate(1deg)}90%{transform:translate(2px,2px) rotate(0)}100%{transform:translate(1px,-2px) rotate(1deg)}}@keyframes saladbowl-orange-spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes saladbowl-tomato-shake{0%{transform:rotate(10deg)}30%{transform:rotate(0)}60%{transform:rotate(10deg)}90%{transform:rotate(0)}100%{transform:rotate(5deg)}}</style><div role=img class="saladbowl saladict-external enableHover saladbowl-enter-done" style=transform:translate(457px,510px);display:none!important><svg viewBox="0 0 612 612" width=30 height=30><g class=saladbowl-leaf><path fill=#6bbc57 d="M 577.557 184.258 C 560.417 140.85 519.54 59.214 519.54 59.214 L 519.543 59.204 C 519.543 59.204 436.903 97.626 396.441 120.878 C 366.171 138.274 354.981 169.755 352.221 177.621 C 349.001 186.851 339.891 228.811 358.341 268.481 C 382.271 319.921 409.201 374.521 409.201 374.521 L 409.201 374.531 C 409.201 374.531 464.511 348.701 515.291 323.401 C 554.451 303.891 573.591 265.441 576.821 256.221 C 579.571 248.356 590.398 216.746 577.574 184.271 Z"></path><path fill=#bde9b7 d="M 501.052 102.162 L 507.518 104.425 L 426.69 335.38 L 420.224 333.117 Z"></path></g><g class=saladbowl-orange><circle fill=#ffb30d cx=299.756 cy=198.246 r=178.613></circle><circle fill=#fce29c cx=299.756 cy=198.246 r=155.24></circle><path fill=#fcc329 d="M 299.756 189.873 L 341.269 113.475 C 349.169 82.543 324.349 58.588 299.749 57.891 C 275.149 57.201 248.229 82.781 256.489 113.481 L 299.749 189.881 Z M 307.026 194.757 L 393.974 194.757 C 424.928 187.083 434.124 153.681 422.994 131.737 C 411.864 109.795 376.534 98.357 353.5 120.27 L 307.025 194.757 Z M 308.79 203.444 L 354.885 277.168 C 377.925 299.268 410.995 289.438 423.701 268.368 C 436.411 247.298 427.381 211.276 396.591 203.362 L 308.801 203.442 Z M 300.208 206.618 L 259.628 283.516 C 252.098 314.543 277.214 338.193 301.815 338.591 C 326.415 338.991 353.022 313.081 344.392 282.491 L 300.208 206.631 Z M 292.058 203.3 L 205.108 203.415 C 174.163 211.277 165.014 244.54 176.172 266.468 C 187.33 288.396 226.052 300.541 249.056 278.598 L 292.056 203.301 Z M 292.465 194.83 L 246.497 121.024 C 223.494 98.884 190.409 108.658 177.667 129.706 C 164.925 150.753 173.893 186.791 204.669 194.756 L 292.459 194.829 Z"></path></g><g class=saladbowl-tomato><path fill=#a63131 d="M 71.014 337.344 C 147.291 422.594 278.234 429.866 363.482 353.589 L 87.258 44.87 C 2.01 121.15 -5.262 252.092 71.014 337.342 Z"></path><path fill=#bc5757 d="M 101.447 310.115 C 162.685 378.555 267.811 384.393 336.251 323.155 L 114.49 75.31 C 46.047 136.55 40.21 241.674 101.447 310.115 Z"></path><path fill=#f1d4af d="M 186.412 237.54 L 151.659 245.444 C 139.989 251.384 139.339 265.51 145.779 273.27 C 152.219 281.028 167.379 282.39 174.599 271.538 L 186.399 237.54 Z M 242.062 269.832 L 223.366 300.175 C 219.439 312.658 229.066 323.018 239.116 323.85 C 249.168 324.685 260.756 314.815 258.061 302.065 L 242.061 269.832 Z M 160.202 178.317 L 130.357 158.837 C 117.98 154.585 107.375 163.939 106.277 173.965 C 105.183 183.99 114.747 195.833 127.563 193.471 L 160.203 178.321 Z"></path></g><g class=saladbowl-bowl><path fill=#2d97b7 d="M 30.857 311.46 C 30.857 429.87 105.371 530.8 209.867 569.52 L 209.867 589.2 L 400.987 589.2 L 400.987 568.9 C 503.595 530.114 576.887 431.202 578.31 314.907 L 589.196 295.97 L 22.804 295.97 L 30.867 309.998 C 30.865 310.488 30.857 310.971 30.857 311.458 Z"></path><path fill=#fff d="M 540.565 321.42 C 540.585 322.587 540.595 323.755 540.595 324.927 C 540.595 405.941 497.513 476.884 433.015 516.122 L 437.178 523.317 C 504.152 482.64 548.895 409.009 548.895 324.927 C 548.895 323.755 548.885 322.587 548.865 321.419 Z M 399.885 532.68 C 388.298 537.31 376.237 541.002 363.793 543.654 L 363.793 544.45 L 364.971 551.893 C 378.481 549.049 391.551 545.018 404.081 539.935 Z"></path></g></svg></div></div></template></div></div>