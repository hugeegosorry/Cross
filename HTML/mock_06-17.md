

使用 [`Mock`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock) 的常见场景：

- 模拟函数调用
- 记录“对象上的方法调用”

替换一个对象上的方法，用于确认此方法被系统中的其他部分调用过，并且调用时使用了正确的参数。



```
>>> real = SomeClass()
>>> real.method = MagicMock(name='method')
>>> real.method(3, 4, 5, key='value')
<MagicMock name='method()' id='...'>
```

使用了 mock（本例中的 `real.method`）之后，它有方法和属性可以让你针对它是被如何使用的下断言。

注解

 

在多数示例中，[`Mock`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock) 与 [`MagicMock`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.MagicMock) 两个类可以相互替换，而 `MagicMock` 是一个更适用的类，通常情况下，使用它就可以了。









最简单的mock就是直接替换掉回传值即可，所以mock最简单的用法就是设定`return_value`:

:

```
from random import randint
from unittest.mock import MagicMock, patch

def get_n():
    return randint(0, 100)

def if_func_return_value_great_than_50(f):
    return f() > 50

if_func_return_value_great_than_50(get_n)

mock = MagicMock(return_value=51)
assert if_func_return_value_great_than_50(mock) is True
```

上述范例利用`MagicMock(return_value=51)`制造一个会永远return 51的mock ，所以我们就能够将mock代入`if_func_return_value_great_than_50`取代原本的`get_n()`，让测试案例永远都能够一直固定行为，避免randint的影响。

而除了利用mock代入`if_func_return_value_great_than_50`之外，还可以利用[patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)直接将randint改为mock ，让我们能够控制`get_n()`的行为，也就是下方范例的`patch('__main__.randint', return_value=51)`：

```
from random import randint
from unittest.mock import MagicMock, patch


def get_n():
    return randint(0, 100)


def if_func_return_value_great_than_50(f):
    return f() > 50


with patch('__main__.randint', return_value=51):
    print(get_n())
    assert True is if_func_return_value_great_than_50(get_n)
```

经过上述2个范例，应能够了解mock中return_value的实际功用与[patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)的用途。





### 副作用

由于return_value的定位是mock物件被呼叫时的回传值，所以它也没办法支援比较复杂的用法，例如raise Exception或者动态决定回传值，所以[side_effect](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock.side_effect)被用来弥补return_value的不足。

所以`side_effect`可以接受带入function, iterable甚至exception class ，让我们当作更复杂的return_value使用：

```
from random import randint
from unittest.mock import MagicMock, patch


def get_n_or_raise_value_error_if_n_eq_zero():
    n = randint(0, 100)
    if n == 0:
        raise ValueError('zero')
    return n


def if_func_return_value_great_than_50():
    try:
        return get_n_or_raise_value_error_if_n_eq_zero() > 50
    except ValueError:
        print('got zero')


with patch('__main__.randint', side_effect=ValueError):
    if_func_return_value_great_than_50()
```

另外，官方文件中也提到使用side_effect时，如果没有设定[DEFAULT](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.DEFAULT)时， side_effect的回传值就会被当作return_value ，也就是说同时设定return_value与side_effect的情况下， side_effect的回传值会盖掉return_value ！

> 每当调用Mock时都要调用的函数。对于引发异常或动态更改返回值很有用。该函数使用与模拟相同的参数调用，除非返回DEFAULT，否则将此函数的返回值用作返回值。

```
from random import randint
from unittest.mock import MagicMock, patch


def get_n():
    return randint(0, 100)


def if_func_return_value_great_than_50(f):
    return f() > 50


def get_n_side_effect(start, stop):
    return 1


with patch('__main__.randint', return_value=51, side_effect=get_n_side_effect):
    print(get_n())
    assert True is if_func_return_value_great_than_50(get_n)
```

上述范例执行结果如下，可以看到side_effect 盖掉return_value 设定，导致randint 始终回传值为1 ：

```
1
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-62-62a7f391aeae> in <module>()
     13 with patch('__main__.randint', return_value=51, side_effect=get_n_side_effect):
     14     print(get_n())
---> 15     assert True is if_func_return_value_great_than_50(get_n)

AssertionError: 
```

至此，我们已认识`return_value`与`side_effect`了！原则上mock单纯的回传值时，用`return_value`即可，若要控制mock抛出例外(raise Exception)或者动态变更回传值的话，用`side_effect`。









### 规格

预设的Mock / MagicMock 其实存取任何属性（甚至根本不存在的属性）、呼叫任何方法都会回传1 个mock ，虽然使用上相当方便，但是这样的行为表现就显得不真实。

因此Mock也提供`spec`参数， spec也就是规格的意思，其功用是让mock尽可能地按照规格模仿，试图取得不在规格内的属性或者方法，就抛出`AttributeError`，如此一来可避免mock预设的特性造成的困扰，测试案例的mock就更加严谨。

目前`spec`参数可代入object或者都是字串的list 。如果是object ， mock就会自行解读该object内的属性与方法，如果是字串list ，那么每一个字串元素都会被视为mock中的属性，可以参考范例。

以下为预设Mock与有使用`spec`的Mock比较，可以发现没有`spec`的情况下， mock存取任意属性与呼叫任何方法都不会有问题，而有使用`spec`的Mock遇到`spec`不支援的属性或方法时就会抛出`AttributeError`:

```
from unittest.mock import Mock


mock_without_spec = Mock()
mock_without_spec.attribute_a
mock_without_spec.attribute_b
mock_without_spec.print_attribute_a()
mock_without_spec.print_attribute_b()


class TheSpec(object):

    NAME = 'spec'

    def __init__(self):
        self.attribute_a = 'a'

    def print_attribute_a(self):
        print(self.attribute_a)


mock_with_spec = Mock(spec=TheSpec())
mock_with_spec.attribute_a
mock_with_spec.attribute_b  # AttributeError

mock_with_spec.print_attribute_a()
mock_with_spec.print_attribute_b()  # AttributeError

mock_with_spec = Mock(spec=['NAME', 'attribute_a', 'print_attribute_a'])
mock_with_spec.NAME
mock_with_spec.print_attribute_a()
mock_with_spec.attribute_b  # AttributeError
```

#### spec_set

谈完`spec`就能够进一步理解`spec_set`。

有使用`spec`的mock试图取得(get)不在规格内的属性时，会抛出`AttributeError`，但还是可以设定(set)不在规格内的属性或方法。

而使用`spec_set`的情况下，则是连设定(set)不在规格内的属性或方法时都会抛出`AttributeError`，可以说是相当严格的设定。

以下范例直接展示2 者的差别：

```
from unittest.mock import Mock


class TheSpec(object):

    NAME = 'spec'

    def __init__(self):
        self.attribute_a = 'a'

    def print_attribute_a(self):
        print(self.attribute_a)


mock_with_spec = Mock(spec=TheSpec())
mock_with_spec.attribute_b = 'b'

mock_with_spec_set = Mock(spec_set=TheSpec())
mock_with_spec_set.attribute_b = 'b'  # AttributeError
```

### 包裹

目前为止谈到的mock 都是虚假的object ，用来取代原本受测程式中的特定object 。

那么有没有一种mock ，在mock 的同时还能让原本模仿的对象实际执行？答案是，有！

这项行为被称为wraps ，简单说就是用mock 将模仿的对象包起来，在呼叫mock 的时候， mock 也会以相同的参数呼叫被包起来的object ，让该object 实际执行。

例如以下范例`mock_with_wraps`在呼叫`print_attribute_a('b', 'c')`时，参数`'b', 'c'`被代入`TheSpec`物件中的`print_attribute_a`方法，所以执行结果会印出`a ('b', 'c')`。

```
from unittest.mock import Mock


class TheSpec(object):

    NAME = 'spec'

    def __init__(self):
        self.attribute_a = 'a'

    def print_attribute_a(self, *args):
        print(self.attribute_a, args)
        return True


mock_with_wraps = Mock(wraps=TheSpec())
assert mock_with_wraps.print_attribute_a('b', 'c') is True  # will print a ('b', 'c')
```

这就是`wraps`的功用。

需要注意的是同时设定`return_value`与`wraps`的话， mock会忽略`wraps`的设定，直接传回`return_value`。

> 如果该模拟具有显式的return_value设置，则不会将调用传递给包装的对象，而是返回return_value。







如果 mock 被调用，它的 [`called`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.called) 属性就会变成 `True`，更重要的是，我们可以使用 [`assert_called_with()`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_called_with) 或者 [`assert_called_once_with()`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.Mock.assert_called_once_with) 方法来确认它在被调用时使用了正确的参数。









If you are patching a module (including [`builtins`](https://docs.python.org/zh-cn/3.9/library/builtins.html#module-builtins)) then use [`patch()`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch) instead of [`patch.object()`](https://docs.python.org/zh-cn/3.9/library/unittest.mock.html#unittest.mock.patch.object):

\>>>

```
>>> mock = MagicMock(return_value=sentinel.file_handle)
>>> with patch('builtins.open', mock):
...     handle = open('filename', 'r')
...
>>> mock.assert_called_with('filename', 'r')
>>> assert handle == sentinel.file_handle, "incorrect file handle returned"
```

The module name can be 'dotted', in the form `package.module` if needed:

\>>>

```
>>> @patch('package.module.ClassName.attribute', sentinel.attribute)
... def test():
...     from package.module import ClassName
...     assert ClassName.attribute == sentinel.attribute
...
>>> test()
```











## 5. 断言

断言，用于判断测试是否符合预期。Mock 相关的断言：

- assert_not_called，没调用过
- assert_called_with，调用过
- assert_called_once_with，仅调用过一次
- aseert_has_calls，按指定顺序调用过
- assert_any_calls，是否全局调用过
- reset_mock，重置调用记录



https://www.cnblogs.com/Zzbj/p/10606207.html

在Python中Mock模块是用来创建和管理mock对象的。



Mock模块中有两个非常重要的类Mock、MagicMock和一个重要的方法create_autospec。

mock.create_autospec为类提供了一个同等功能实例。这意味着，实际上来说，在使用返回的实例进行交互的时候，如果使用了非法的方法将会引发异常。更具体地说，如果一个方法被调用时的参数数目不正确，将引发一个异常。这对于重构来说是非常重要。当一个库发生变化的时候，中断测试正是所期望的。如果不使用auto-spec，即使底层的实现已经破坏，我们的测试仍然会通过。



这就是为什么你总是应该使用create_autospec方法，并且在使用@patch和@patch.object装饰方法时使用autospec参数。



@mock.patch整个对象，@mock.patch.object对象中的方法





target参数必须是一个str,格式为'package.module.ClassName'，
注意这里的格式一定要写对，如果你的函数或类写在pakege名称为a下，b.py脚本里，有个c的函数（或类），那这个参数就写“a.b.c”

示例

```
# 文件名：Mymodel
class MyTest(object):
    def func(self):
        pass
```

那么@mock.patch

```
import Mymodel


class AppMockTests(unit.TestCase):

    def setUp(self):
        super(AppMockTests, self).setUp()
        self.project_zbj = webtest.TestApp(self.loadapp('project_zbj'))

    @mock.patch('Mymodel.MyTest')  # 必须是字符串,具体到类
    def test_list(self, mock_MyTest):
        url = '/api/zzz'
        mock_MyTest.func.return_value = 500
        res = self.project_zbj.get(url)
        self.assertEqual(res.json['data'], 500)
```

 

而@mock.patch.object

```
import Mymodel


class AppMockTests(unit.TestCase):

    def setUp(self):
        super(AppMockTests, self).setUp()
        self.project_zbj = webtest.TestApp(self.loadapp('project_zbj'))

    @mock.patch.object(Mymodel.MyTest, 'func')  # 具体到某个方法 
    def test_list(self, mock_func):
        url = '/api/zzz'
        mock_func.return_value = 500
        res = self.project_zbj.get(url)
        self.assertEqual(res.json['data'], 500)
```

 

 





























